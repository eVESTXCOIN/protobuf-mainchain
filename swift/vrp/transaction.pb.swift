// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vrp/transaction.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Vrp_SignedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transaction: Vrp_SignedTransaction.OneOf_Transaction? = nil

  var vrpTransaction: Vrp_Transaction {
    get {
      if case .vrpTransaction(let v)? = transaction {return v}
      return Vrp_Transaction()
    }
    set {transaction = .vrpTransaction(newValue)}
  }

  var ethereumTransaction: Data {
    get {
      if case .ethereumTransaction(let v)? = transaction {return v}
      return Data()
    }
    set {transaction = .ethereumTransaction(newValue)}
  }

  var proofs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Transaction: Equatable {
    case vrpTransaction(Vrp_Transaction)
    case ethereumTransaction(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Vrp_SignedTransaction.OneOf_Transaction, rhs: Vrp_SignedTransaction.OneOf_Transaction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vrpTransaction, .vrpTransaction): return {
        guard case .vrpTransaction(let l) = lhs, case .vrpTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ethereumTransaction, .ethereumTransaction): return {
        guard case .ethereumTransaction(let l) = lhs, case .ethereumTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Vrp_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: Int32 = 0

  var senderPublicKey: Data = Data()

  var fee: Vrp_Amount {
    get {return _fee ?? Vrp_Amount()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {self._fee = nil}

  var timestamp: Int64 = 0

  var version: Int32 = 0

  var data: Vrp_Transaction.OneOf_Data? = nil

  var genesis: Vrp_GenesisTransactionData {
    get {
      if case .genesis(let v)? = data {return v}
      return Vrp_GenesisTransactionData()
    }
    set {data = .genesis(newValue)}
  }

  var payment: Vrp_PaymentTransactionData {
    get {
      if case .payment(let v)? = data {return v}
      return Vrp_PaymentTransactionData()
    }
    set {data = .payment(newValue)}
  }

  var issue: Vrp_IssueTransactionData {
    get {
      if case .issue(let v)? = data {return v}
      return Vrp_IssueTransactionData()
    }
    set {data = .issue(newValue)}
  }

  var transfer: Vrp_TransferTransactionData {
    get {
      if case .transfer(let v)? = data {return v}
      return Vrp_TransferTransactionData()
    }
    set {data = .transfer(newValue)}
  }

  var reissue: Vrp_ReissueTransactionData {
    get {
      if case .reissue(let v)? = data {return v}
      return Vrp_ReissueTransactionData()
    }
    set {data = .reissue(newValue)}
  }

  var burn: Vrp_BurnTransactionData {
    get {
      if case .burn(let v)? = data {return v}
      return Vrp_BurnTransactionData()
    }
    set {data = .burn(newValue)}
  }

  var exchange: Vrp_ExchangeTransactionData {
    get {
      if case .exchange(let v)? = data {return v}
      return Vrp_ExchangeTransactionData()
    }
    set {data = .exchange(newValue)}
  }

  var lease: Vrp_LeaseTransactionData {
    get {
      if case .lease(let v)? = data {return v}
      return Vrp_LeaseTransactionData()
    }
    set {data = .lease(newValue)}
  }

  var leaseCancel: Vrp_LeaseCancelTransactionData {
    get {
      if case .leaseCancel(let v)? = data {return v}
      return Vrp_LeaseCancelTransactionData()
    }
    set {data = .leaseCancel(newValue)}
  }

  var createAlias: Vrp_CreateAliasTransactionData {
    get {
      if case .createAlias(let v)? = data {return v}
      return Vrp_CreateAliasTransactionData()
    }
    set {data = .createAlias(newValue)}
  }

  var massTransfer: Vrp_MassTransferTransactionData {
    get {
      if case .massTransfer(let v)? = data {return v}
      return Vrp_MassTransferTransactionData()
    }
    set {data = .massTransfer(newValue)}
  }

  var dataTransaction: Vrp_DataTransactionData {
    get {
      if case .dataTransaction(let v)? = data {return v}
      return Vrp_DataTransactionData()
    }
    set {data = .dataTransaction(newValue)}
  }

  var setScript: Vrp_SetScriptTransactionData {
    get {
      if case .setScript(let v)? = data {return v}
      return Vrp_SetScriptTransactionData()
    }
    set {data = .setScript(newValue)}
  }

  var sponsorFee: Vrp_SponsorFeeTransactionData {
    get {
      if case .sponsorFee(let v)? = data {return v}
      return Vrp_SponsorFeeTransactionData()
    }
    set {data = .sponsorFee(newValue)}
  }

  var setAssetScript: Vrp_SetAssetScriptTransactionData {
    get {
      if case .setAssetScript(let v)? = data {return v}
      return Vrp_SetAssetScriptTransactionData()
    }
    set {data = .setAssetScript(newValue)}
  }

  var invokeScript: Vrp_InvokeScriptTransactionData {
    get {
      if case .invokeScript(let v)? = data {return v}
      return Vrp_InvokeScriptTransactionData()
    }
    set {data = .invokeScript(newValue)}
  }

  var updateAssetInfo: Vrp_UpdateAssetInfoTransactionData {
    get {
      if case .updateAssetInfo(let v)? = data {return v}
      return Vrp_UpdateAssetInfoTransactionData()
    }
    set {data = .updateAssetInfo(newValue)}
  }

  var anonymousTx: Vrp_PrivatePaymentTransactionData {
    get {
      if case .anonymousTx(let v)? = data {return v}
      return Vrp_PrivatePaymentTransactionData()
    }
    set {data = .anonymousTx(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case genesis(Vrp_GenesisTransactionData)
    case payment(Vrp_PaymentTransactionData)
    case issue(Vrp_IssueTransactionData)
    case transfer(Vrp_TransferTransactionData)
    case reissue(Vrp_ReissueTransactionData)
    case burn(Vrp_BurnTransactionData)
    case exchange(Vrp_ExchangeTransactionData)
    case lease(Vrp_LeaseTransactionData)
    case leaseCancel(Vrp_LeaseCancelTransactionData)
    case createAlias(Vrp_CreateAliasTransactionData)
    case massTransfer(Vrp_MassTransferTransactionData)
    case dataTransaction(Vrp_DataTransactionData)
    case setScript(Vrp_SetScriptTransactionData)
    case sponsorFee(Vrp_SponsorFeeTransactionData)
    case setAssetScript(Vrp_SetAssetScriptTransactionData)
    case invokeScript(Vrp_InvokeScriptTransactionData)
    case updateAssetInfo(Vrp_UpdateAssetInfoTransactionData)
    case anonymousTx(Vrp_PrivatePaymentTransactionData)

  #if !swift(>=4.1)
    static func ==(lhs: Vrp_Transaction.OneOf_Data, rhs: Vrp_Transaction.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.genesis, .genesis): return {
        guard case .genesis(let l) = lhs, case .genesis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.payment, .payment): return {
        guard case .payment(let l) = lhs, case .payment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.issue, .issue): return {
        guard case .issue(let l) = lhs, case .issue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reissue, .reissue): return {
        guard case .reissue(let l) = lhs, case .reissue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.burn, .burn): return {
        guard case .burn(let l) = lhs, case .burn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exchange, .exchange): return {
        guard case .exchange(let l) = lhs, case .exchange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lease, .lease): return {
        guard case .lease(let l) = lhs, case .lease(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.leaseCancel, .leaseCancel): return {
        guard case .leaseCancel(let l) = lhs, case .leaseCancel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createAlias, .createAlias): return {
        guard case .createAlias(let l) = lhs, case .createAlias(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.massTransfer, .massTransfer): return {
        guard case .massTransfer(let l) = lhs, case .massTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataTransaction, .dataTransaction): return {
        guard case .dataTransaction(let l) = lhs, case .dataTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setScript, .setScript): return {
        guard case .setScript(let l) = lhs, case .setScript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sponsorFee, .sponsorFee): return {
        guard case .sponsorFee(let l) = lhs, case .sponsorFee(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setAssetScript, .setAssetScript): return {
        guard case .setAssetScript(let l) = lhs, case .setAssetScript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invokeScript, .invokeScript): return {
        guard case .invokeScript(let l) = lhs, case .invokeScript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateAssetInfo, .updateAssetInfo): return {
        guard case .updateAssetInfo(let l) = lhs, case .updateAssetInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.anonymousTx, .anonymousTx): return {
        guard case .anonymousTx(let l) = lhs, case .anonymousTx(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _fee: Vrp_Amount? = nil
}

struct Vrp_GenesisTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recipientAddress: Data = Data()

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_PaymentTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recipientAddress: Data = Data()

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_TransferTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recipient: Vrp_Recipient {
    get {return _recipient ?? Vrp_Recipient()}
    set {_recipient = newValue}
  }
  /// Returns true if `recipient` has been explicitly set.
  var hasRecipient: Bool {return self._recipient != nil}
  /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
  mutating func clearRecipient() {self._recipient = nil}

  var amount: Vrp_Amount {
    get {return _amount ?? Vrp_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var attachment: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recipient: Vrp_Recipient? = nil
  fileprivate var _amount: Vrp_Amount? = nil
}

struct Vrp_CreateAliasTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alias: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_DataTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [Vrp_DataTransactionData.DataEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct DataEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String = String()

    var value: Vrp_DataTransactionData.DataEntry.OneOf_Value? = nil

    var intValue: Int64 {
      get {
        if case .intValue(let v)? = value {return v}
        return 0
      }
      set {value = .intValue(newValue)}
    }

    var boolValue: Bool {
      get {
        if case .boolValue(let v)? = value {return v}
        return false
      }
      set {value = .boolValue(newValue)}
    }

    var binaryValue: Data {
      get {
        if case .binaryValue(let v)? = value {return v}
        return Data()
      }
      set {value = .binaryValue(newValue)}
    }

    var stringValue: String {
      get {
        if case .stringValue(let v)? = value {return v}
        return String()
      }
      set {value = .stringValue(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Value: Equatable {
      case intValue(Int64)
      case boolValue(Bool)
      case binaryValue(Data)
      case stringValue(String)

    #if !swift(>=4.1)
      static func ==(lhs: Vrp_DataTransactionData.DataEntry.OneOf_Value, rhs: Vrp_DataTransactionData.DataEntry.OneOf_Value) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.intValue, .intValue): return {
          guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.boolValue, .boolValue): return {
          guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.binaryValue, .binaryValue): return {
          guard case .binaryValue(let l) = lhs, case .binaryValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.stringValue, .stringValue): return {
          guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

struct Vrp_MassTransferTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: Data = Data()

  var transfers: [Vrp_MassTransferTransactionData.Transfer] = []

  var attachment: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Transfer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var recipient: Vrp_Recipient {
      get {return _recipient ?? Vrp_Recipient()}
      set {_recipient = newValue}
    }
    /// Returns true if `recipient` has been explicitly set.
    var hasRecipient: Bool {return self._recipient != nil}
    /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
    mutating func clearRecipient() {self._recipient = nil}

    var amount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _recipient: Vrp_Recipient? = nil
  }

  init() {}
}

struct Vrp_LeaseTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recipient: Vrp_Recipient {
    get {return _recipient ?? Vrp_Recipient()}
    set {_recipient = newValue}
  }
  /// Returns true if `recipient` has been explicitly set.
  var hasRecipient: Bool {return self._recipient != nil}
  /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
  mutating func clearRecipient() {self._recipient = nil}

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recipient: Vrp_Recipient? = nil
}

struct Vrp_LeaseCancelTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var leaseID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_BurnTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetAmount: Vrp_Amount {
    get {return _assetAmount ?? Vrp_Amount()}
    set {_assetAmount = newValue}
  }
  /// Returns true if `assetAmount` has been explicitly set.
  var hasAssetAmount: Bool {return self._assetAmount != nil}
  /// Clears the value of `assetAmount`. Subsequent reads from it will return its default value.
  mutating func clearAssetAmount() {self._assetAmount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _assetAmount: Vrp_Amount? = nil
}

struct Vrp_IssueTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var description_p: String = String()

  var amount: Int64 = 0

  var decimals: Int32 = 0

  var reissuable: Bool = false

  var script: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_ReissueTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetAmount: Vrp_Amount {
    get {return _assetAmount ?? Vrp_Amount()}
    set {_assetAmount = newValue}
  }
  /// Returns true if `assetAmount` has been explicitly set.
  var hasAssetAmount: Bool {return self._assetAmount != nil}
  /// Clears the value of `assetAmount`. Subsequent reads from it will return its default value.
  mutating func clearAssetAmount() {self._assetAmount = nil}

  var reissuable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _assetAmount: Vrp_Amount? = nil
}

struct Vrp_SetAssetScriptTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: Data = Data()

  var script: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_SetScriptTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var script: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_ExchangeTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: Int64 = 0

  var price: Int64 = 0

  var buyMatcherFee: Int64 = 0

  var sellMatcherFee: Int64 = 0

  var orders: [Vrp_Order] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_SponsorFeeTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minFee: Vrp_Amount {
    get {return _minFee ?? Vrp_Amount()}
    set {_minFee = newValue}
  }
  /// Returns true if `minFee` has been explicitly set.
  var hasMinFee: Bool {return self._minFee != nil}
  /// Clears the value of `minFee`. Subsequent reads from it will return its default value.
  mutating func clearMinFee() {self._minFee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minFee: Vrp_Amount? = nil
}

struct Vrp_InvokeScriptTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dApp: Vrp_Recipient {
    get {return _dApp ?? Vrp_Recipient()}
    set {_dApp = newValue}
  }
  /// Returns true if `dApp` has been explicitly set.
  var hasDApp: Bool {return self._dApp != nil}
  /// Clears the value of `dApp`. Subsequent reads from it will return its default value.
  mutating func clearDApp() {self._dApp = nil}

  var functionCall: Data = Data()

  var payments: [Vrp_Amount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dApp: Vrp_Recipient? = nil
}

struct Vrp_UpdateAssetInfoTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetID: Data = Data()

  var name: String = String()

  var description_p: String = String()

  var image: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_InvokeExpressionTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expression: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_PrivatePaymentTransactionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recipientAddress: Data = Data()

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Vrp_SignedTransaction: @unchecked Sendable {}
extension Vrp_SignedTransaction.OneOf_Transaction: @unchecked Sendable {}
extension Vrp_Transaction: @unchecked Sendable {}
extension Vrp_Transaction.OneOf_Data: @unchecked Sendable {}
extension Vrp_GenesisTransactionData: @unchecked Sendable {}
extension Vrp_PaymentTransactionData: @unchecked Sendable {}
extension Vrp_TransferTransactionData: @unchecked Sendable {}
extension Vrp_CreateAliasTransactionData: @unchecked Sendable {}
extension Vrp_DataTransactionData: @unchecked Sendable {}
extension Vrp_DataTransactionData.DataEntry: @unchecked Sendable {}
extension Vrp_DataTransactionData.DataEntry.OneOf_Value: @unchecked Sendable {}
extension Vrp_MassTransferTransactionData: @unchecked Sendable {}
extension Vrp_MassTransferTransactionData.Transfer: @unchecked Sendable {}
extension Vrp_LeaseTransactionData: @unchecked Sendable {}
extension Vrp_LeaseCancelTransactionData: @unchecked Sendable {}
extension Vrp_BurnTransactionData: @unchecked Sendable {}
extension Vrp_IssueTransactionData: @unchecked Sendable {}
extension Vrp_ReissueTransactionData: @unchecked Sendable {}
extension Vrp_SetAssetScriptTransactionData: @unchecked Sendable {}
extension Vrp_SetScriptTransactionData: @unchecked Sendable {}
extension Vrp_ExchangeTransactionData: @unchecked Sendable {}
extension Vrp_SponsorFeeTransactionData: @unchecked Sendable {}
extension Vrp_InvokeScriptTransactionData: @unchecked Sendable {}
extension Vrp_UpdateAssetInfoTransactionData: @unchecked Sendable {}
extension Vrp_InvokeExpressionTransactionData: @unchecked Sendable {}
extension Vrp_PrivatePaymentTransactionData: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vrp"

extension Vrp_SignedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vrp_transaction"),
    3: .standard(proto: "ethereum_transaction"),
    2: .same(proto: "proofs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Vrp_Transaction?
        var hadOneofValue = false
        if let current = self.transaction {
          hadOneofValue = true
          if case .vrpTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transaction = .vrpTransaction(v)
        }
      }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.proofs) }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.transaction != nil {try decoder.handleConflictingOneOf()}
          self.transaction = .ethereumTransaction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .vrpTransaction(let v)? = self.transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.proofs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.proofs, fieldNumber: 2)
    }
    try { if case .ethereumTransaction(let v)? = self.transaction {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_SignedTransaction, rhs: Vrp_SignedTransaction) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.proofs != rhs.proofs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .standard(proto: "sender_public_key"),
    3: .same(proto: "fee"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "version"),
    101: .same(proto: "genesis"),
    102: .same(proto: "payment"),
    103: .same(proto: "issue"),
    104: .same(proto: "transfer"),
    105: .same(proto: "reissue"),
    106: .same(proto: "burn"),
    107: .same(proto: "exchange"),
    108: .same(proto: "lease"),
    109: .standard(proto: "lease_cancel"),
    110: .standard(proto: "create_alias"),
    111: .standard(proto: "mass_transfer"),
    112: .standard(proto: "data_transaction"),
    113: .standard(proto: "set_script"),
    114: .standard(proto: "sponsor_fee"),
    115: .standard(proto: "set_asset_script"),
    116: .standard(proto: "invoke_script"),
    117: .standard(proto: "update_asset_info"),
    118: .standard(proto: "anonymous_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.senderPublicKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 101: try {
        var v: Vrp_GenesisTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .genesis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .genesis(v)
        }
      }()
      case 102: try {
        var v: Vrp_PaymentTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .payment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .payment(v)
        }
      }()
      case 103: try {
        var v: Vrp_IssueTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .issue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .issue(v)
        }
      }()
      case 104: try {
        var v: Vrp_TransferTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .transfer(v)
        }
      }()
      case 105: try {
        var v: Vrp_ReissueTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .reissue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .reissue(v)
        }
      }()
      case 106: try {
        var v: Vrp_BurnTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .burn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .burn(v)
        }
      }()
      case 107: try {
        var v: Vrp_ExchangeTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .exchange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .exchange(v)
        }
      }()
      case 108: try {
        var v: Vrp_LeaseTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .lease(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .lease(v)
        }
      }()
      case 109: try {
        var v: Vrp_LeaseCancelTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .leaseCancel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .leaseCancel(v)
        }
      }()
      case 110: try {
        var v: Vrp_CreateAliasTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .createAlias(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .createAlias(v)
        }
      }()
      case 111: try {
        var v: Vrp_MassTransferTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .massTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .massTransfer(v)
        }
      }()
      case 112: try {
        var v: Vrp_DataTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .dataTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .dataTransaction(v)
        }
      }()
      case 113: try {
        var v: Vrp_SetScriptTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .setScript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .setScript(v)
        }
      }()
      case 114: try {
        var v: Vrp_SponsorFeeTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .sponsorFee(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .sponsorFee(v)
        }
      }()
      case 115: try {
        var v: Vrp_SetAssetScriptTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .setAssetScript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .setAssetScript(v)
        }
      }()
      case 116: try {
        var v: Vrp_InvokeScriptTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .invokeScript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .invokeScript(v)
        }
      }()
      case 117: try {
        var v: Vrp_UpdateAssetInfoTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .updateAssetInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .updateAssetInfo(v)
        }
      }()
      case 118: try {
        var v: Vrp_PrivatePaymentTransactionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .anonymousTx(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .anonymousTx(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.chainID != 0 {
      try visitor.visitSingularInt32Field(value: self.chainID, fieldNumber: 1)
    }
    if !self.senderPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderPublicKey, fieldNumber: 2)
    }
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 5)
    }
    switch self.data {
    case .genesis?: try {
      guard case .genesis(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .payment?: try {
      guard case .payment(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .issue?: try {
      guard case .issue(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .transfer?: try {
      guard case .transfer(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .reissue?: try {
      guard case .reissue(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .burn?: try {
      guard case .burn(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .exchange?: try {
      guard case .exchange(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .lease?: try {
      guard case .lease(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .leaseCancel?: try {
      guard case .leaseCancel(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .createAlias?: try {
      guard case .createAlias(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .massTransfer?: try {
      guard case .massTransfer(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .dataTransaction?: try {
      guard case .dataTransaction(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .setScript?: try {
      guard case .setScript(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .sponsorFee?: try {
      guard case .sponsorFee(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case .setAssetScript?: try {
      guard case .setAssetScript(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
    }()
    case .invokeScript?: try {
      guard case .invokeScript(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
    }()
    case .updateAssetInfo?: try {
      guard case .updateAssetInfo(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
    }()
    case .anonymousTx?: try {
      guard case .anonymousTx(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_Transaction, rhs: Vrp_Transaction) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.senderPublicKey != rhs.senderPublicKey {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.version != rhs.version {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_GenesisTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recipient_address"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.recipientAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recipientAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.recipientAddress, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_GenesisTransactionData, rhs: Vrp_GenesisTransactionData) -> Bool {
    if lhs.recipientAddress != rhs.recipientAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_PaymentTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recipient_address"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.recipientAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recipientAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.recipientAddress, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_PaymentTransactionData, rhs: Vrp_PaymentTransactionData) -> Bool {
    if lhs.recipientAddress != rhs.recipientAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_TransferTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipient"),
    2: .same(proto: "amount"),
    3: .same(proto: "attachment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recipient) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attachment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.attachment.isEmpty {
      try visitor.visitSingularBytesField(value: self.attachment, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_TransferTransactionData, rhs: Vrp_TransferTransactionData) -> Bool {
    if lhs._recipient != rhs._recipient {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.attachment != rhs.attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_CreateAliasTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAliasTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alias"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_CreateAliasTransactionData, rhs: Vrp_CreateAliasTransactionData) -> Bool {
    if lhs.alias != rhs.alias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_DataTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_DataTransactionData, rhs: Vrp_DataTransactionData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_DataTransactionData.DataEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_DataTransactionData.protoMessageName + ".DataEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    10: .standard(proto: "int_value"),
    11: .standard(proto: "bool_value"),
    12: .standard(proto: "binary_value"),
    13: .standard(proto: "string_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 10: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .intValue(v)
        }
      }()
      case 11: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolValue(v)
        }
      }()
      case 12: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .binaryValue(v)
        }
      }()
      case 13: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    switch self.value {
    case .intValue?: try {
      guard case .intValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 10)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }()
    case .binaryValue?: try {
      guard case .binaryValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_DataTransactionData.DataEntry, rhs: Vrp_DataTransactionData.DataEntry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_MassTransferTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MassTransferTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "transfers"),
    3: .same(proto: "attachment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.assetID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transfers) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attachment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetID, fieldNumber: 1)
    }
    if !self.transfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transfers, fieldNumber: 2)
    }
    if !self.attachment.isEmpty {
      try visitor.visitSingularBytesField(value: self.attachment, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_MassTransferTransactionData, rhs: Vrp_MassTransferTransactionData) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.transfers != rhs.transfers {return false}
    if lhs.attachment != rhs.attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_MassTransferTransactionData.Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_MassTransferTransactionData.protoMessageName + ".Transfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipient"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recipient) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_MassTransferTransactionData.Transfer, rhs: Vrp_MassTransferTransactionData.Transfer) -> Bool {
    if lhs._recipient != rhs._recipient {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_LeaseTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipient"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recipient) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_LeaseTransactionData, rhs: Vrp_LeaseTransactionData) -> Bool {
    if lhs._recipient != rhs._recipient {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_LeaseCancelTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseCancelTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lease_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.leaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaseID.isEmpty {
      try visitor.visitSingularBytesField(value: self.leaseID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_LeaseCancelTransactionData, rhs: Vrp_LeaseCancelTransactionData) -> Bool {
    if lhs.leaseID != rhs.leaseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_BurnTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BurnTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._assetAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._assetAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_BurnTransactionData, rhs: Vrp_BurnTransactionData) -> Bool {
    if lhs._assetAmount != rhs._assetAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_IssueTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssueTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "amount"),
    4: .same(proto: "decimals"),
    5: .same(proto: "reissuable"),
    6: .same(proto: "script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.decimals) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.reissuable) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.script) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    if self.decimals != 0 {
      try visitor.visitSingularInt32Field(value: self.decimals, fieldNumber: 4)
    }
    if self.reissuable != false {
      try visitor.visitSingularBoolField(value: self.reissuable, fieldNumber: 5)
    }
    if !self.script.isEmpty {
      try visitor.visitSingularBytesField(value: self.script, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_IssueTransactionData, rhs: Vrp_IssueTransactionData) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.reissuable != rhs.reissuable {return false}
    if lhs.script != rhs.script {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_ReissueTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReissueTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_amount"),
    2: .same(proto: "reissuable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._assetAmount) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.reissuable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._assetAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reissuable != false {
      try visitor.visitSingularBoolField(value: self.reissuable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_ReissueTransactionData, rhs: Vrp_ReissueTransactionData) -> Bool {
    if lhs._assetAmount != rhs._assetAmount {return false}
    if lhs.reissuable != rhs.reissuable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_SetAssetScriptTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAssetScriptTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.script) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetID, fieldNumber: 1)
    }
    if !self.script.isEmpty {
      try visitor.visitSingularBytesField(value: self.script, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_SetAssetScriptTransactionData, rhs: Vrp_SetAssetScriptTransactionData) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.script != rhs.script {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_SetScriptTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetScriptTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.script) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.script.isEmpty {
      try visitor.visitSingularBytesField(value: self.script, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_SetScriptTransactionData, rhs: Vrp_SetScriptTransactionData) -> Bool {
    if lhs.script != rhs.script {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_ExchangeTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "price"),
    3: .standard(proto: "buy_matcher_fee"),
    4: .standard(proto: "sell_matcher_fee"),
    5: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.price) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.buyMatcherFee) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.sellMatcherFee) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 1)
    }
    if self.price != 0 {
      try visitor.visitSingularInt64Field(value: self.price, fieldNumber: 2)
    }
    if self.buyMatcherFee != 0 {
      try visitor.visitSingularInt64Field(value: self.buyMatcherFee, fieldNumber: 3)
    }
    if self.sellMatcherFee != 0 {
      try visitor.visitSingularInt64Field(value: self.sellMatcherFee, fieldNumber: 4)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_ExchangeTransactionData, rhs: Vrp_ExchangeTransactionData) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.price != rhs.price {return false}
    if lhs.buyMatcherFee != rhs.buyMatcherFee {return false}
    if lhs.sellMatcherFee != rhs.sellMatcherFee {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_SponsorFeeTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SponsorFeeTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_SponsorFeeTransactionData, rhs: Vrp_SponsorFeeTransactionData) -> Bool {
    if lhs._minFee != rhs._minFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvokeScriptTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "d_app"),
    2: .standard(proto: "function_call"),
    3: .same(proto: "payments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dApp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.functionCall) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.payments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dApp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.functionCall.isEmpty {
      try visitor.visitSingularBytesField(value: self.functionCall, fieldNumber: 2)
    }
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptTransactionData, rhs: Vrp_InvokeScriptTransactionData) -> Bool {
    if lhs._dApp != rhs._dApp {return false}
    if lhs.functionCall != rhs.functionCall {return false}
    if lhs.payments != rhs.payments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_UpdateAssetInfoTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAssetInfoTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "image"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.image) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_UpdateAssetInfoTransactionData, rhs: Vrp_UpdateAssetInfoTransactionData) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.image != rhs.image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeExpressionTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvokeExpressionTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expression"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.expression) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expression.isEmpty {
      try visitor.visitSingularBytesField(value: self.expression, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeExpressionTransactionData, rhs: Vrp_InvokeExpressionTransactionData) -> Bool {
    if lhs.expression != rhs.expression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_PrivatePaymentTransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrivatePaymentTransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recipient_address"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.recipientAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recipientAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.recipientAddress, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_PrivatePaymentTransactionData, rhs: Vrp_PrivatePaymentTransactionData) -> Bool {
    if lhs.recipientAddress != rhs.recipientAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
