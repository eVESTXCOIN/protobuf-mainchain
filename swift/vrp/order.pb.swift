// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vrp/order.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Vrp_AssetPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amountAssetID: Data = Data()

  var priceAssetID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Vrp_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainID: Int64 = 0

  var matcherPublicKey: Data = Data()

  var assetPair: Vrp_AssetPair {
    get {return _assetPair ?? Vrp_AssetPair()}
    set {_assetPair = newValue}
  }
  /// Returns true if `assetPair` has been explicitly set.
  var hasAssetPair: Bool {return self._assetPair != nil}
  /// Clears the value of `assetPair`. Subsequent reads from it will return its default value.
  mutating func clearAssetPair() {self._assetPair = nil}

  var orderSide: Vrp_Order.Side = .buy

  var amount: Int64 = 0

  var price: Int64 = 0

  var timestamp: Int64 = 0

  var expiration: Int64 = 0

  var matcherFee: Vrp_Amount {
    get {return _matcherFee ?? Vrp_Amount()}
    set {_matcherFee = newValue}
  }
  /// Returns true if `matcherFee` has been explicitly set.
  var hasMatcherFee: Bool {return self._matcherFee != nil}
  /// Clears the value of `matcherFee`. Subsequent reads from it will return its default value.
  mutating func clearMatcherFee() {self._matcherFee = nil}

  var version: Int32 = 0

  var proofs: [Data] = []

  var priceMode: Vrp_Order.PriceMode = .default

  var sender: Vrp_Order.OneOf_Sender? = nil

  var senderPublicKey: Data {
    get {
      if case .senderPublicKey(let v)? = sender {return v}
      return Data()
    }
    set {sender = .senderPublicKey(newValue)}
  }

  var eip712Signature: Data {
    get {
      if case .eip712Signature(let v)? = sender {return v}
      return Data()
    }
    set {sender = .eip712Signature(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Sender: Equatable {
    case senderPublicKey(Data)
    case eip712Signature(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Vrp_Order.OneOf_Sender, rhs: Vrp_Order.OneOf_Sender) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.senderPublicKey, .senderPublicKey): return {
        guard case .senderPublicKey(let l) = lhs, case .senderPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eip712Signature, .eip712Signature): return {
        guard case .eip712Signature(let l) = lhs, case .eip712Signature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Side: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case buy // = 0
    case sell // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .buy
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .buy
      case 1: self = .sell
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .buy: return 0
      case .sell: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum PriceMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case fixedDecimals // = 1
    case assetDecimals // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .fixedDecimals
      case 2: self = .assetDecimals
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .fixedDecimals: return 1
      case .assetDecimals: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _assetPair: Vrp_AssetPair? = nil
  fileprivate var _matcherFee: Vrp_Amount? = nil
}

#if swift(>=4.2)

extension Vrp_Order.Side: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Vrp_Order.Side] = [
    .buy,
    .sell,
  ]
}

extension Vrp_Order.PriceMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Vrp_Order.PriceMode] = [
    .default,
    .fixedDecimals,
    .assetDecimals,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Vrp_AssetPair: @unchecked Sendable {}
extension Vrp_Order: @unchecked Sendable {}
extension Vrp_Order.OneOf_Sender: @unchecked Sendable {}
extension Vrp_Order.Side: @unchecked Sendable {}
extension Vrp_Order.PriceMode: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vrp"

extension Vrp_AssetPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "amount_asset_id"),
    2: .standard(proto: "price_asset_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.amountAssetID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.priceAssetID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amountAssetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.amountAssetID, fieldNumber: 1)
    }
    if !self.priceAssetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.priceAssetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_AssetPair, rhs: Vrp_AssetPair) -> Bool {
    if lhs.amountAssetID != rhs.amountAssetID {return false}
    if lhs.priceAssetID != rhs.priceAssetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    3: .standard(proto: "matcher_public_key"),
    4: .standard(proto: "asset_pair"),
    5: .standard(proto: "order_side"),
    6: .same(proto: "amount"),
    7: .same(proto: "price"),
    8: .same(proto: "timestamp"),
    9: .same(proto: "expiration"),
    10: .standard(proto: "matcher_fee"),
    11: .same(proto: "version"),
    12: .same(proto: "proofs"),
    14: .standard(proto: "price_mode"),
    2: .standard(proto: "sender_public_key"),
    13: .standard(proto: "eip712_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chainID) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.sender != nil {try decoder.handleConflictingOneOf()}
          self.sender = .senderPublicKey(v)
        }
      }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.matcherPublicKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._assetPair) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.orderSide) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.price) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.expiration) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._matcherFee) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 12: try { try decoder.decodeRepeatedBytesField(value: &self.proofs) }()
      case 13: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.sender != nil {try decoder.handleConflictingOneOf()}
          self.sender = .eip712Signature(v)
        }
      }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.priceMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.chainID != 0 {
      try visitor.visitSingularInt64Field(value: self.chainID, fieldNumber: 1)
    }
    try { if case .senderPublicKey(let v)? = self.sender {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if !self.matcherPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.matcherPublicKey, fieldNumber: 3)
    }
    try { if let v = self._assetPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.orderSide != .buy {
      try visitor.visitSingularEnumField(value: self.orderSide, fieldNumber: 5)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 6)
    }
    if self.price != 0 {
      try visitor.visitSingularInt64Field(value: self.price, fieldNumber: 7)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 8)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 9)
    }
    try { if let v = self._matcherFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 11)
    }
    if !self.proofs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.proofs, fieldNumber: 12)
    }
    try { if case .eip712Signature(let v)? = self.sender {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 13)
    } }()
    if self.priceMode != .default {
      try visitor.visitSingularEnumField(value: self.priceMode, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_Order, rhs: Vrp_Order) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.matcherPublicKey != rhs.matcherPublicKey {return false}
    if lhs._assetPair != rhs._assetPair {return false}
    if lhs.orderSide != rhs.orderSide {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.price != rhs.price {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs._matcherFee != rhs._matcherFee {return false}
    if lhs.version != rhs.version {return false}
    if lhs.proofs != rhs.proofs {return false}
    if lhs.priceMode != rhs.priceMode {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_Order.Side: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUY"),
    1: .same(proto: "SELL"),
  ]
}

extension Vrp_Order.PriceMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "FIXED_DECIMALS"),
    2: .same(proto: "ASSET_DECIMALS"),
  ]
}
