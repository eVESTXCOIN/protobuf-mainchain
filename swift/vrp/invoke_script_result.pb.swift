// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vrp/invoke_script_result.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Vrp_InvokeScriptResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [Vrp_DataTransactionData.DataEntry] = []

  var transfers: [Vrp_InvokeScriptResult.Payment] = []

  var issues: [Vrp_InvokeScriptResult.Issue] = []

  var reissues: [Vrp_InvokeScriptResult.Reissue] = []

  var burns: [Vrp_InvokeScriptResult.Burn] = []

  var errorMessage: Vrp_InvokeScriptResult.ErrorMessage {
    get {return _errorMessage ?? Vrp_InvokeScriptResult.ErrorMessage()}
    set {_errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  var hasErrorMessage: Bool {return self._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  mutating func clearErrorMessage() {self._errorMessage = nil}

  var sponsorFees: [Vrp_InvokeScriptResult.SponsorFee] = []

  var leases: [Vrp_InvokeScriptResult.Lease] = []

  var leaseCancels: [Vrp_InvokeScriptResult.LeaseCancel] = []

  var invokes: [Vrp_InvokeScriptResult.Invocation] = []

  var privatePayment: [Vrp_InvokeScriptResult.PrivatePayment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Payment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = Data()

    var amount: Vrp_Amount {
      get {return _amount ?? Vrp_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _amount: Vrp_Amount? = nil
  }

  struct PrivatePayment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = Data()

    var amount: Vrp_Amount {
      get {return _amount ?? Vrp_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _amount: Vrp_Amount? = nil
  }

  struct Issue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var assetID: Data = Data()

    var name: String = String()

    var description_p: String = String()

    var image: String = String()

    var amount: Int64 = 0

    var decimals: Int32 = 0

    var reissuable: Bool = false

    var script: Data = Data()

    var nonce: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Reissue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var assetID: Data = Data()

    var amount: Int64 = 0

    var isReissuable: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Burn {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var assetID: Data = Data()

    var amount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SponsorFee {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var minFee: Vrp_Amount {
      get {return _minFee ?? Vrp_Amount()}
      set {_minFee = newValue}
    }
    /// Returns true if `minFee` has been explicitly set.
    var hasMinFee: Bool {return self._minFee != nil}
    /// Clears the value of `minFee`. Subsequent reads from it will return its default value.
    mutating func clearMinFee() {self._minFee = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _minFee: Vrp_Amount? = nil
  }

  struct Lease {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var recipient: Vrp_Recipient {
      get {return _recipient ?? Vrp_Recipient()}
      set {_recipient = newValue}
    }
    /// Returns true if `recipient` has been explicitly set.
    var hasRecipient: Bool {return self._recipient != nil}
    /// Clears the value of `recipient`. Subsequent reads from it will return its default value.
    mutating func clearRecipient() {self._recipient = nil}

    var amount: Int64 = 0

    var nonce: Int64 = 0

    var leaseID: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _recipient: Vrp_Recipient? = nil
  }

  struct LeaseCancel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var leaseID: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ErrorMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var code: Int32 = 0

    var text: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Call {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var function: String = String()

    var argsBytes: [Data] = []

    var args: [Vrp_InvokeScriptResult.Call.Argument] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Argument {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Vrp_InvokeScriptResult.Call.Argument.OneOf_Value? = nil

      var integerValue: Int64 {
        get {
          if case .integerValue(let v)? = value {return v}
          return 0
        }
        set {value = .integerValue(newValue)}
      }

      var binaryValue: Data {
        get {
          if case .binaryValue(let v)? = value {return v}
          return Data()
        }
        set {value = .binaryValue(newValue)}
      }

      var stringValue: String {
        get {
          if case .stringValue(let v)? = value {return v}
          return String()
        }
        set {value = .stringValue(newValue)}
      }

      var booleanValue: Bool {
        get {
          if case .booleanValue(let v)? = value {return v}
          return false
        }
        set {value = .booleanValue(newValue)}
      }

      var caseObj: Data {
        get {
          if case .caseObj(let v)? = value {return v}
          return Data()
        }
        set {value = .caseObj(newValue)}
      }

      var list: Vrp_InvokeScriptResult.Call.Argument.List {
        get {
          if case .list(let v)? = value {return v}
          return Vrp_InvokeScriptResult.Call.Argument.List()
        }
        set {value = .list(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Value: Equatable {
        case integerValue(Int64)
        case binaryValue(Data)
        case stringValue(String)
        case booleanValue(Bool)
        case caseObj(Data)
        case list(Vrp_InvokeScriptResult.Call.Argument.List)

      #if !swift(>=4.1)
        static func ==(lhs: Vrp_InvokeScriptResult.Call.Argument.OneOf_Value, rhs: Vrp_InvokeScriptResult.Call.Argument.OneOf_Value) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.integerValue, .integerValue): return {
            guard case .integerValue(let l) = lhs, case .integerValue(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.binaryValue, .binaryValue): return {
            guard case .binaryValue(let l) = lhs, case .binaryValue(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.stringValue, .stringValue): return {
            guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.booleanValue, .booleanValue): return {
            guard case .booleanValue(let l) = lhs, case .booleanValue(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.caseObj, .caseObj): return {
            guard case .caseObj(let l) = lhs, case .caseObj(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.list, .list): return {
            guard case .list(let l) = lhs, case .list(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      struct List {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var items: [Vrp_InvokeScriptResult.Call.Argument] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct Invocation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dApp: Data {
      get {return _storage._dApp}
      set {_uniqueStorage()._dApp = newValue}
    }

    var call: Vrp_InvokeScriptResult.Call {
      get {return _storage._call ?? Vrp_InvokeScriptResult.Call()}
      set {_uniqueStorage()._call = newValue}
    }
    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool {return _storage._call != nil}
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() {_uniqueStorage()._call = nil}

    var payments: [Vrp_Amount] {
      get {return _storage._payments}
      set {_uniqueStorage()._payments = newValue}
    }

    var stateChanges: Vrp_InvokeScriptResult {
      get {return _storage._stateChanges ?? Vrp_InvokeScriptResult()}
      set {_uniqueStorage()._stateChanges = newValue}
    }
    /// Returns true if `stateChanges` has been explicitly set.
    var hasStateChanges: Bool {return _storage._stateChanges != nil}
    /// Clears the value of `stateChanges`. Subsequent reads from it will return its default value.
    mutating func clearStateChanges() {_uniqueStorage()._stateChanges = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _errorMessage: Vrp_InvokeScriptResult.ErrorMessage? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Vrp_InvokeScriptResult: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Payment: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.PrivatePayment: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Issue: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Reissue: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Burn: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.SponsorFee: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Lease: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.LeaseCancel: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.ErrorMessage: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Call: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Call.Argument: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Call.Argument.OneOf_Value: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Call.Argument.List: @unchecked Sendable {}
extension Vrp_InvokeScriptResult.Invocation: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vrp"

extension Vrp_InvokeScriptResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvokeScriptResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "transfers"),
    3: .same(proto: "issues"),
    4: .same(proto: "reissues"),
    5: .same(proto: "burns"),
    6: .standard(proto: "error_message"),
    7: .standard(proto: "sponsor_fees"),
    8: .same(proto: "leases"),
    9: .standard(proto: "lease_cancels"),
    10: .same(proto: "invokes"),
    11: .standard(proto: "private_payment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transfers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.issues) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.reissues) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.burns) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._errorMessage) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.sponsorFees) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.leases) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.leaseCancels) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.invokes) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.privatePayment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    if !self.transfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transfers, fieldNumber: 2)
    }
    if !self.issues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.issues, fieldNumber: 3)
    }
    if !self.reissues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reissues, fieldNumber: 4)
    }
    if !self.burns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.burns, fieldNumber: 5)
    }
    try { if let v = self._errorMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.sponsorFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sponsorFees, fieldNumber: 7)
    }
    if !self.leases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leases, fieldNumber: 8)
    }
    if !self.leaseCancels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaseCancels, fieldNumber: 9)
    }
    if !self.invokes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invokes, fieldNumber: 10)
    }
    if !self.privatePayment.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.privatePayment, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult, rhs: Vrp_InvokeScriptResult) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.transfers != rhs.transfers {return false}
    if lhs.issues != rhs.issues {return false}
    if lhs.reissues != rhs.reissues {return false}
    if lhs.burns != rhs.burns {return false}
    if lhs._errorMessage != rhs._errorMessage {return false}
    if lhs.sponsorFees != rhs.sponsorFees {return false}
    if lhs.leases != rhs.leases {return false}
    if lhs.leaseCancels != rhs.leaseCancels {return false}
    if lhs.invokes != rhs.invokes {return false}
    if lhs.privatePayment != rhs.privatePayment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Payment, rhs: Vrp_InvokeScriptResult.Payment) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.PrivatePayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".PrivatePayment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.PrivatePayment, rhs: Vrp_InvokeScriptResult.PrivatePayment) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Issue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".Issue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "image"),
    5: .same(proto: "amount"),
    6: .same(proto: "decimals"),
    7: .same(proto: "reissuable"),
    8: .same(proto: "script"),
    9: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.image) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.decimals) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.reissuable) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.script) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 4)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 5)
    }
    if self.decimals != 0 {
      try visitor.visitSingularInt32Field(value: self.decimals, fieldNumber: 6)
    }
    if self.reissuable != false {
      try visitor.visitSingularBoolField(value: self.reissuable, fieldNumber: 7)
    }
    if !self.script.isEmpty {
      try visitor.visitSingularBytesField(value: self.script, fieldNumber: 8)
    }
    if self.nonce != 0 {
      try visitor.visitSingularInt64Field(value: self.nonce, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Issue, rhs: Vrp_InvokeScriptResult.Issue) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.image != rhs.image {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.reissuable != rhs.reissuable {return false}
    if lhs.script != rhs.script {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Reissue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".Reissue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "amount"),
    3: .standard(proto: "is_reissuable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isReissuable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetID, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.isReissuable != false {
      try visitor.visitSingularBoolField(value: self.isReissuable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Reissue, rhs: Vrp_InvokeScriptResult.Reissue) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.isReissuable != rhs.isReissuable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Burn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".Burn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.assetID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetID, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Burn, rhs: Vrp_InvokeScriptResult.Burn) -> Bool {
    if lhs.assetID != rhs.assetID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.SponsorFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".SponsorFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.SponsorFee, rhs: Vrp_InvokeScriptResult.SponsorFee) -> Bool {
    if lhs._minFee != rhs._minFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Lease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".Lease"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipient"),
    2: .same(proto: "amount"),
    3: .same(proto: "nonce"),
    4: .standard(proto: "lease_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recipient) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.nonce) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.leaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.nonce != 0 {
      try visitor.visitSingularInt64Field(value: self.nonce, fieldNumber: 3)
    }
    if !self.leaseID.isEmpty {
      try visitor.visitSingularBytesField(value: self.leaseID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Lease, rhs: Vrp_InvokeScriptResult.Lease) -> Bool {
    if lhs._recipient != rhs._recipient {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.leaseID != rhs.leaseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.LeaseCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".LeaseCancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lease_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.leaseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaseID.isEmpty {
      try visitor.visitSingularBytesField(value: self.leaseID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.LeaseCancel, rhs: Vrp_InvokeScriptResult.LeaseCancel) -> Bool {
    if lhs.leaseID != rhs.leaseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.ErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".ErrorMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.ErrorMessage, rhs: Vrp_InvokeScriptResult.ErrorMessage) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "function"),
    2: .standard(proto: "args_bytes"),
    3: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.function) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.argsBytes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.function.isEmpty {
      try visitor.visitSingularStringField(value: self.function, fieldNumber: 1)
    }
    if !self.argsBytes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.argsBytes, fieldNumber: 2)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.args, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Call, rhs: Vrp_InvokeScriptResult.Call) -> Bool {
    if lhs.function != rhs.function {return false}
    if lhs.argsBytes != rhs.argsBytes {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Call.Argument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.Call.protoMessageName + ".Argument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "integer_value"),
    2: .standard(proto: "binary_value"),
    3: .standard(proto: "string_value"),
    4: .standard(proto: "boolean_value"),
    5: .standard(proto: "case_obj"),
    10: .same(proto: "list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .integerValue(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .binaryValue(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .booleanValue(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .caseObj(v)
        }
      }()
      case 10: try {
        var v: Vrp_InvokeScriptResult.Call.Argument.List?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .list(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .binaryValue?: try {
      guard case .binaryValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .booleanValue?: try {
      guard case .booleanValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .caseObj?: try {
      guard case .caseObj(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .list?: try {
      guard case .list(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Call.Argument, rhs: Vrp_InvokeScriptResult.Call.Argument) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Call.Argument.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.Call.Argument.protoMessageName + ".List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Call.Argument.List, rhs: Vrp_InvokeScriptResult.Call.Argument.List) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vrp_InvokeScriptResult.Invocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Vrp_InvokeScriptResult.protoMessageName + ".Invocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dApp"),
    2: .same(proto: "call"),
    3: .same(proto: "payments"),
    4: .same(proto: "stateChanges"),
  ]

  fileprivate class _StorageClass {
    var _dApp: Data = Data()
    var _call: Vrp_InvokeScriptResult.Call? = nil
    var _payments: [Vrp_Amount] = []
    var _stateChanges: Vrp_InvokeScriptResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dApp = source._dApp
      _call = source._call
      _payments = source._payments
      _stateChanges = source._stateChanges
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._dApp) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._payments) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stateChanges) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._dApp.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dApp, fieldNumber: 1)
      }
      try { if let v = _storage._call {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._payments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._payments, fieldNumber: 3)
      }
      try { if let v = _storage._stateChanges {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Vrp_InvokeScriptResult.Invocation, rhs: Vrp_InvokeScriptResult.Invocation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dApp != rhs_storage._dApp {return false}
        if _storage._call != rhs_storage._call {return false}
        if _storage._payments != rhs_storage._payments {return false}
        if _storage._stateChanges != rhs_storage._stateChanges {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
