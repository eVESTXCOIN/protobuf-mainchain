// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vrp/transaction.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vrp_2ftransaction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vrp_2ftransaction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "vrp/amount.pb.h"
#include "vrp/recipient.pb.h"
#include "vrp/order.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vrp_2ftransaction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vrp_2ftransaction_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vrp_2ftransaction_2eproto;
namespace vrp {
class BurnTransactionData;
struct BurnTransactionDataDefaultTypeInternal;
extern BurnTransactionDataDefaultTypeInternal _BurnTransactionData_default_instance_;
class CreateAliasTransactionData;
struct CreateAliasTransactionDataDefaultTypeInternal;
extern CreateAliasTransactionDataDefaultTypeInternal _CreateAliasTransactionData_default_instance_;
class DataTransactionData;
struct DataTransactionDataDefaultTypeInternal;
extern DataTransactionDataDefaultTypeInternal _DataTransactionData_default_instance_;
class DataTransactionData_DataEntry;
struct DataTransactionData_DataEntryDefaultTypeInternal;
extern DataTransactionData_DataEntryDefaultTypeInternal _DataTransactionData_DataEntry_default_instance_;
class ExchangeTransactionData;
struct ExchangeTransactionDataDefaultTypeInternal;
extern ExchangeTransactionDataDefaultTypeInternal _ExchangeTransactionData_default_instance_;
class GenesisTransactionData;
struct GenesisTransactionDataDefaultTypeInternal;
extern GenesisTransactionDataDefaultTypeInternal _GenesisTransactionData_default_instance_;
class InvokeExpressionTransactionData;
struct InvokeExpressionTransactionDataDefaultTypeInternal;
extern InvokeExpressionTransactionDataDefaultTypeInternal _InvokeExpressionTransactionData_default_instance_;
class InvokeScriptTransactionData;
struct InvokeScriptTransactionDataDefaultTypeInternal;
extern InvokeScriptTransactionDataDefaultTypeInternal _InvokeScriptTransactionData_default_instance_;
class IssueTransactionData;
struct IssueTransactionDataDefaultTypeInternal;
extern IssueTransactionDataDefaultTypeInternal _IssueTransactionData_default_instance_;
class LeaseCancelTransactionData;
struct LeaseCancelTransactionDataDefaultTypeInternal;
extern LeaseCancelTransactionDataDefaultTypeInternal _LeaseCancelTransactionData_default_instance_;
class LeaseTransactionData;
struct LeaseTransactionDataDefaultTypeInternal;
extern LeaseTransactionDataDefaultTypeInternal _LeaseTransactionData_default_instance_;
class MassTransferTransactionData;
struct MassTransferTransactionDataDefaultTypeInternal;
extern MassTransferTransactionDataDefaultTypeInternal _MassTransferTransactionData_default_instance_;
class MassTransferTransactionData_Transfer;
struct MassTransferTransactionData_TransferDefaultTypeInternal;
extern MassTransferTransactionData_TransferDefaultTypeInternal _MassTransferTransactionData_Transfer_default_instance_;
class PaymentTransactionData;
struct PaymentTransactionDataDefaultTypeInternal;
extern PaymentTransactionDataDefaultTypeInternal _PaymentTransactionData_default_instance_;
class PrivatePaymentTransactionData;
struct PrivatePaymentTransactionDataDefaultTypeInternal;
extern PrivatePaymentTransactionDataDefaultTypeInternal _PrivatePaymentTransactionData_default_instance_;
class ReissueTransactionData;
struct ReissueTransactionDataDefaultTypeInternal;
extern ReissueTransactionDataDefaultTypeInternal _ReissueTransactionData_default_instance_;
class SetAssetScriptTransactionData;
struct SetAssetScriptTransactionDataDefaultTypeInternal;
extern SetAssetScriptTransactionDataDefaultTypeInternal _SetAssetScriptTransactionData_default_instance_;
class SetScriptTransactionData;
struct SetScriptTransactionDataDefaultTypeInternal;
extern SetScriptTransactionDataDefaultTypeInternal _SetScriptTransactionData_default_instance_;
class SignedTransaction;
struct SignedTransactionDefaultTypeInternal;
extern SignedTransactionDefaultTypeInternal _SignedTransaction_default_instance_;
class SponsorFeeTransactionData;
struct SponsorFeeTransactionDataDefaultTypeInternal;
extern SponsorFeeTransactionDataDefaultTypeInternal _SponsorFeeTransactionData_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransferTransactionData;
struct TransferTransactionDataDefaultTypeInternal;
extern TransferTransactionDataDefaultTypeInternal _TransferTransactionData_default_instance_;
class UpdateAssetInfoTransactionData;
struct UpdateAssetInfoTransactionDataDefaultTypeInternal;
extern UpdateAssetInfoTransactionDataDefaultTypeInternal _UpdateAssetInfoTransactionData_default_instance_;
}  // namespace vrp
PROTOBUF_NAMESPACE_OPEN
template<> ::vrp::BurnTransactionData* Arena::CreateMaybeMessage<::vrp::BurnTransactionData>(Arena*);
template<> ::vrp::CreateAliasTransactionData* Arena::CreateMaybeMessage<::vrp::CreateAliasTransactionData>(Arena*);
template<> ::vrp::DataTransactionData* Arena::CreateMaybeMessage<::vrp::DataTransactionData>(Arena*);
template<> ::vrp::DataTransactionData_DataEntry* Arena::CreateMaybeMessage<::vrp::DataTransactionData_DataEntry>(Arena*);
template<> ::vrp::ExchangeTransactionData* Arena::CreateMaybeMessage<::vrp::ExchangeTransactionData>(Arena*);
template<> ::vrp::GenesisTransactionData* Arena::CreateMaybeMessage<::vrp::GenesisTransactionData>(Arena*);
template<> ::vrp::InvokeExpressionTransactionData* Arena::CreateMaybeMessage<::vrp::InvokeExpressionTransactionData>(Arena*);
template<> ::vrp::InvokeScriptTransactionData* Arena::CreateMaybeMessage<::vrp::InvokeScriptTransactionData>(Arena*);
template<> ::vrp::IssueTransactionData* Arena::CreateMaybeMessage<::vrp::IssueTransactionData>(Arena*);
template<> ::vrp::LeaseCancelTransactionData* Arena::CreateMaybeMessage<::vrp::LeaseCancelTransactionData>(Arena*);
template<> ::vrp::LeaseTransactionData* Arena::CreateMaybeMessage<::vrp::LeaseTransactionData>(Arena*);
template<> ::vrp::MassTransferTransactionData* Arena::CreateMaybeMessage<::vrp::MassTransferTransactionData>(Arena*);
template<> ::vrp::MassTransferTransactionData_Transfer* Arena::CreateMaybeMessage<::vrp::MassTransferTransactionData_Transfer>(Arena*);
template<> ::vrp::PaymentTransactionData* Arena::CreateMaybeMessage<::vrp::PaymentTransactionData>(Arena*);
template<> ::vrp::PrivatePaymentTransactionData* Arena::CreateMaybeMessage<::vrp::PrivatePaymentTransactionData>(Arena*);
template<> ::vrp::ReissueTransactionData* Arena::CreateMaybeMessage<::vrp::ReissueTransactionData>(Arena*);
template<> ::vrp::SetAssetScriptTransactionData* Arena::CreateMaybeMessage<::vrp::SetAssetScriptTransactionData>(Arena*);
template<> ::vrp::SetScriptTransactionData* Arena::CreateMaybeMessage<::vrp::SetScriptTransactionData>(Arena*);
template<> ::vrp::SignedTransaction* Arena::CreateMaybeMessage<::vrp::SignedTransaction>(Arena*);
template<> ::vrp::SponsorFeeTransactionData* Arena::CreateMaybeMessage<::vrp::SponsorFeeTransactionData>(Arena*);
template<> ::vrp::Transaction* Arena::CreateMaybeMessage<::vrp::Transaction>(Arena*);
template<> ::vrp::TransferTransactionData* Arena::CreateMaybeMessage<::vrp::TransferTransactionData>(Arena*);
template<> ::vrp::UpdateAssetInfoTransactionData* Arena::CreateMaybeMessage<::vrp::UpdateAssetInfoTransactionData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vrp {

// ===================================================================

class SignedTransaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.SignedTransaction) */ {
 public:
  inline SignedTransaction() : SignedTransaction(nullptr) {}
  ~SignedTransaction() override;
  explicit PROTOBUF_CONSTEXPR SignedTransaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedTransaction(const SignedTransaction& from);
  SignedTransaction(SignedTransaction&& from) noexcept
    : SignedTransaction() {
    *this = ::std::move(from);
  }

  inline SignedTransaction& operator=(const SignedTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedTransaction& operator=(SignedTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedTransaction& default_instance() {
    return *internal_default_instance();
  }
  enum TransactionCase {
    kVrpTransaction = 1,
    kEthereumTransaction = 3,
    TRANSACTION_NOT_SET = 0,
  };

  static inline const SignedTransaction* internal_default_instance() {
    return reinterpret_cast<const SignedTransaction*>(
               &_SignedTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SignedTransaction& a, SignedTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedTransaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedTransaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedTransaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignedTransaction& from) {
    SignedTransaction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedTransaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.SignedTransaction";
  }
  protected:
  explicit SignedTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofsFieldNumber = 2,
    kVrpTransactionFieldNumber = 1,
    kEthereumTransactionFieldNumber = 3,
  };
  // repeated bytes proofs = 2;
  int proofs_size() const;
  private:
  int _internal_proofs_size() const;
  public:
  void clear_proofs();
  const std::string& proofs(int index) const;
  std::string* mutable_proofs(int index);
  void set_proofs(int index, const std::string& value);
  void set_proofs(int index, std::string&& value);
  void set_proofs(int index, const char* value);
  void set_proofs(int index, const void* value, size_t size);
  std::string* add_proofs();
  void add_proofs(const std::string& value);
  void add_proofs(std::string&& value);
  void add_proofs(const char* value);
  void add_proofs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proofs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proofs();
  private:
  const std::string& _internal_proofs(int index) const;
  std::string* _internal_add_proofs();
  public:

  // .vrp.Transaction vrp_transaction = 1;
  bool has_vrp_transaction() const;
  private:
  bool _internal_has_vrp_transaction() const;
  public:
  void clear_vrp_transaction();
  const ::vrp::Transaction& vrp_transaction() const;
  PROTOBUF_NODISCARD ::vrp::Transaction* release_vrp_transaction();
  ::vrp::Transaction* mutable_vrp_transaction();
  void set_allocated_vrp_transaction(::vrp::Transaction* vrp_transaction);
  private:
  const ::vrp::Transaction& _internal_vrp_transaction() const;
  ::vrp::Transaction* _internal_mutable_vrp_transaction();
  public:
  void unsafe_arena_set_allocated_vrp_transaction(
      ::vrp::Transaction* vrp_transaction);
  ::vrp::Transaction* unsafe_arena_release_vrp_transaction();

  // bytes ethereum_transaction = 3;
  bool has_ethereum_transaction() const;
  private:
  bool _internal_has_ethereum_transaction() const;
  public:
  void clear_ethereum_transaction();
  const std::string& ethereum_transaction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ethereum_transaction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ethereum_transaction();
  PROTOBUF_NODISCARD std::string* release_ethereum_transaction();
  void set_allocated_ethereum_transaction(std::string* ethereum_transaction);
  private:
  const std::string& _internal_ethereum_transaction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ethereum_transaction(const std::string& value);
  std::string* _internal_mutable_ethereum_transaction();
  public:

  void clear_transaction();
  TransactionCase transaction_case() const;
  // @@protoc_insertion_point(class_scope:vrp.SignedTransaction)
 private:
  class _Internal;
  void set_has_vrp_transaction();
  void set_has_ethereum_transaction();

  inline bool has_transaction() const;
  inline void clear_has_transaction();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proofs_;
    union TransactionUnion {
      constexpr TransactionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vrp::Transaction* vrp_transaction_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ethereum_transaction_;
    } transaction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  ~Transaction() override;
  explicit PROTOBUF_CONSTEXPR Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kGenesis = 101,
    kPayment = 102,
    kIssue = 103,
    kTransfer = 104,
    kReissue = 105,
    kBurn = 106,
    kExchange = 107,
    kLease = 108,
    kLeaseCancel = 109,
    kCreateAlias = 110,
    kMassTransfer = 111,
    kDataTransaction = 112,
    kSetScript = 113,
    kSponsorFee = 114,
    kSetAssetScript = 115,
    kInvokeScript = 116,
    kUpdateAssetInfo = 117,
    kAnonymousTx = 118,
    DATA_NOT_SET = 0,
  };

  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transaction& from) {
    Transaction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderPublicKeyFieldNumber = 2,
    kFeeFieldNumber = 3,
    kChainIdFieldNumber = 1,
    kVersionFieldNumber = 5,
    kTimestampFieldNumber = 4,
    kGenesisFieldNumber = 101,
    kPaymentFieldNumber = 102,
    kIssueFieldNumber = 103,
    kTransferFieldNumber = 104,
    kReissueFieldNumber = 105,
    kBurnFieldNumber = 106,
    kExchangeFieldNumber = 107,
    kLeaseFieldNumber = 108,
    kLeaseCancelFieldNumber = 109,
    kCreateAliasFieldNumber = 110,
    kMassTransferFieldNumber = 111,
    kDataTransactionFieldNumber = 112,
    kSetScriptFieldNumber = 113,
    kSponsorFeeFieldNumber = 114,
    kSetAssetScriptFieldNumber = 115,
    kInvokeScriptFieldNumber = 116,
    kUpdateAssetInfoFieldNumber = 117,
    kAnonymousTxFieldNumber = 118,
  };
  // bytes sender_public_key = 2;
  void clear_sender_public_key();
  const std::string& sender_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_public_key();
  PROTOBUF_NODISCARD std::string* release_sender_public_key();
  void set_allocated_sender_public_key(std::string* sender_public_key);
  private:
  const std::string& _internal_sender_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_public_key(const std::string& value);
  std::string* _internal_mutable_sender_public_key();
  public:

  // .vrp.Amount fee = 3;
  bool has_fee() const;
  private:
  bool _internal_has_fee() const;
  public:
  void clear_fee();
  const ::vrp::Amount& fee() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_fee();
  ::vrp::Amount* mutable_fee();
  void set_allocated_fee(::vrp::Amount* fee);
  private:
  const ::vrp::Amount& _internal_fee() const;
  ::vrp::Amount* _internal_mutable_fee();
  public:
  void unsafe_arena_set_allocated_fee(
      ::vrp::Amount* fee);
  ::vrp::Amount* unsafe_arena_release_fee();

  // int32 chain_id = 1;
  void clear_chain_id();
  int32_t chain_id() const;
  void set_chain_id(int32_t value);
  private:
  int32_t _internal_chain_id() const;
  void _internal_set_chain_id(int32_t value);
  public:

  // int32 version = 5;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // int64 timestamp = 4;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .vrp.GenesisTransactionData genesis = 101;
  bool has_genesis() const;
  private:
  bool _internal_has_genesis() const;
  public:
  void clear_genesis();
  const ::vrp::GenesisTransactionData& genesis() const;
  PROTOBUF_NODISCARD ::vrp::GenesisTransactionData* release_genesis();
  ::vrp::GenesisTransactionData* mutable_genesis();
  void set_allocated_genesis(::vrp::GenesisTransactionData* genesis);
  private:
  const ::vrp::GenesisTransactionData& _internal_genesis() const;
  ::vrp::GenesisTransactionData* _internal_mutable_genesis();
  public:
  void unsafe_arena_set_allocated_genesis(
      ::vrp::GenesisTransactionData* genesis);
  ::vrp::GenesisTransactionData* unsafe_arena_release_genesis();

  // .vrp.PaymentTransactionData payment = 102;
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::vrp::PaymentTransactionData& payment() const;
  PROTOBUF_NODISCARD ::vrp::PaymentTransactionData* release_payment();
  ::vrp::PaymentTransactionData* mutable_payment();
  void set_allocated_payment(::vrp::PaymentTransactionData* payment);
  private:
  const ::vrp::PaymentTransactionData& _internal_payment() const;
  ::vrp::PaymentTransactionData* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::vrp::PaymentTransactionData* payment);
  ::vrp::PaymentTransactionData* unsafe_arena_release_payment();

  // .vrp.IssueTransactionData issue = 103;
  bool has_issue() const;
  private:
  bool _internal_has_issue() const;
  public:
  void clear_issue();
  const ::vrp::IssueTransactionData& issue() const;
  PROTOBUF_NODISCARD ::vrp::IssueTransactionData* release_issue();
  ::vrp::IssueTransactionData* mutable_issue();
  void set_allocated_issue(::vrp::IssueTransactionData* issue);
  private:
  const ::vrp::IssueTransactionData& _internal_issue() const;
  ::vrp::IssueTransactionData* _internal_mutable_issue();
  public:
  void unsafe_arena_set_allocated_issue(
      ::vrp::IssueTransactionData* issue);
  ::vrp::IssueTransactionData* unsafe_arena_release_issue();

  // .vrp.TransferTransactionData transfer = 104;
  bool has_transfer() const;
  private:
  bool _internal_has_transfer() const;
  public:
  void clear_transfer();
  const ::vrp::TransferTransactionData& transfer() const;
  PROTOBUF_NODISCARD ::vrp::TransferTransactionData* release_transfer();
  ::vrp::TransferTransactionData* mutable_transfer();
  void set_allocated_transfer(::vrp::TransferTransactionData* transfer);
  private:
  const ::vrp::TransferTransactionData& _internal_transfer() const;
  ::vrp::TransferTransactionData* _internal_mutable_transfer();
  public:
  void unsafe_arena_set_allocated_transfer(
      ::vrp::TransferTransactionData* transfer);
  ::vrp::TransferTransactionData* unsafe_arena_release_transfer();

  // .vrp.ReissueTransactionData reissue = 105;
  bool has_reissue() const;
  private:
  bool _internal_has_reissue() const;
  public:
  void clear_reissue();
  const ::vrp::ReissueTransactionData& reissue() const;
  PROTOBUF_NODISCARD ::vrp::ReissueTransactionData* release_reissue();
  ::vrp::ReissueTransactionData* mutable_reissue();
  void set_allocated_reissue(::vrp::ReissueTransactionData* reissue);
  private:
  const ::vrp::ReissueTransactionData& _internal_reissue() const;
  ::vrp::ReissueTransactionData* _internal_mutable_reissue();
  public:
  void unsafe_arena_set_allocated_reissue(
      ::vrp::ReissueTransactionData* reissue);
  ::vrp::ReissueTransactionData* unsafe_arena_release_reissue();

  // .vrp.BurnTransactionData burn = 106;
  bool has_burn() const;
  private:
  bool _internal_has_burn() const;
  public:
  void clear_burn();
  const ::vrp::BurnTransactionData& burn() const;
  PROTOBUF_NODISCARD ::vrp::BurnTransactionData* release_burn();
  ::vrp::BurnTransactionData* mutable_burn();
  void set_allocated_burn(::vrp::BurnTransactionData* burn);
  private:
  const ::vrp::BurnTransactionData& _internal_burn() const;
  ::vrp::BurnTransactionData* _internal_mutable_burn();
  public:
  void unsafe_arena_set_allocated_burn(
      ::vrp::BurnTransactionData* burn);
  ::vrp::BurnTransactionData* unsafe_arena_release_burn();

  // .vrp.ExchangeTransactionData exchange = 107;
  bool has_exchange() const;
  private:
  bool _internal_has_exchange() const;
  public:
  void clear_exchange();
  const ::vrp::ExchangeTransactionData& exchange() const;
  PROTOBUF_NODISCARD ::vrp::ExchangeTransactionData* release_exchange();
  ::vrp::ExchangeTransactionData* mutable_exchange();
  void set_allocated_exchange(::vrp::ExchangeTransactionData* exchange);
  private:
  const ::vrp::ExchangeTransactionData& _internal_exchange() const;
  ::vrp::ExchangeTransactionData* _internal_mutable_exchange();
  public:
  void unsafe_arena_set_allocated_exchange(
      ::vrp::ExchangeTransactionData* exchange);
  ::vrp::ExchangeTransactionData* unsafe_arena_release_exchange();

  // .vrp.LeaseTransactionData lease = 108;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::vrp::LeaseTransactionData& lease() const;
  PROTOBUF_NODISCARD ::vrp::LeaseTransactionData* release_lease();
  ::vrp::LeaseTransactionData* mutable_lease();
  void set_allocated_lease(::vrp::LeaseTransactionData* lease);
  private:
  const ::vrp::LeaseTransactionData& _internal_lease() const;
  ::vrp::LeaseTransactionData* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::vrp::LeaseTransactionData* lease);
  ::vrp::LeaseTransactionData* unsafe_arena_release_lease();

  // .vrp.LeaseCancelTransactionData lease_cancel = 109;
  bool has_lease_cancel() const;
  private:
  bool _internal_has_lease_cancel() const;
  public:
  void clear_lease_cancel();
  const ::vrp::LeaseCancelTransactionData& lease_cancel() const;
  PROTOBUF_NODISCARD ::vrp::LeaseCancelTransactionData* release_lease_cancel();
  ::vrp::LeaseCancelTransactionData* mutable_lease_cancel();
  void set_allocated_lease_cancel(::vrp::LeaseCancelTransactionData* lease_cancel);
  private:
  const ::vrp::LeaseCancelTransactionData& _internal_lease_cancel() const;
  ::vrp::LeaseCancelTransactionData* _internal_mutable_lease_cancel();
  public:
  void unsafe_arena_set_allocated_lease_cancel(
      ::vrp::LeaseCancelTransactionData* lease_cancel);
  ::vrp::LeaseCancelTransactionData* unsafe_arena_release_lease_cancel();

  // .vrp.CreateAliasTransactionData create_alias = 110;
  bool has_create_alias() const;
  private:
  bool _internal_has_create_alias() const;
  public:
  void clear_create_alias();
  const ::vrp::CreateAliasTransactionData& create_alias() const;
  PROTOBUF_NODISCARD ::vrp::CreateAliasTransactionData* release_create_alias();
  ::vrp::CreateAliasTransactionData* mutable_create_alias();
  void set_allocated_create_alias(::vrp::CreateAliasTransactionData* create_alias);
  private:
  const ::vrp::CreateAliasTransactionData& _internal_create_alias() const;
  ::vrp::CreateAliasTransactionData* _internal_mutable_create_alias();
  public:
  void unsafe_arena_set_allocated_create_alias(
      ::vrp::CreateAliasTransactionData* create_alias);
  ::vrp::CreateAliasTransactionData* unsafe_arena_release_create_alias();

  // .vrp.MassTransferTransactionData mass_transfer = 111;
  bool has_mass_transfer() const;
  private:
  bool _internal_has_mass_transfer() const;
  public:
  void clear_mass_transfer();
  const ::vrp::MassTransferTransactionData& mass_transfer() const;
  PROTOBUF_NODISCARD ::vrp::MassTransferTransactionData* release_mass_transfer();
  ::vrp::MassTransferTransactionData* mutable_mass_transfer();
  void set_allocated_mass_transfer(::vrp::MassTransferTransactionData* mass_transfer);
  private:
  const ::vrp::MassTransferTransactionData& _internal_mass_transfer() const;
  ::vrp::MassTransferTransactionData* _internal_mutable_mass_transfer();
  public:
  void unsafe_arena_set_allocated_mass_transfer(
      ::vrp::MassTransferTransactionData* mass_transfer);
  ::vrp::MassTransferTransactionData* unsafe_arena_release_mass_transfer();

  // .vrp.DataTransactionData data_transaction = 112;
  bool has_data_transaction() const;
  private:
  bool _internal_has_data_transaction() const;
  public:
  void clear_data_transaction();
  const ::vrp::DataTransactionData& data_transaction() const;
  PROTOBUF_NODISCARD ::vrp::DataTransactionData* release_data_transaction();
  ::vrp::DataTransactionData* mutable_data_transaction();
  void set_allocated_data_transaction(::vrp::DataTransactionData* data_transaction);
  private:
  const ::vrp::DataTransactionData& _internal_data_transaction() const;
  ::vrp::DataTransactionData* _internal_mutable_data_transaction();
  public:
  void unsafe_arena_set_allocated_data_transaction(
      ::vrp::DataTransactionData* data_transaction);
  ::vrp::DataTransactionData* unsafe_arena_release_data_transaction();

  // .vrp.SetScriptTransactionData set_script = 113;
  bool has_set_script() const;
  private:
  bool _internal_has_set_script() const;
  public:
  void clear_set_script();
  const ::vrp::SetScriptTransactionData& set_script() const;
  PROTOBUF_NODISCARD ::vrp::SetScriptTransactionData* release_set_script();
  ::vrp::SetScriptTransactionData* mutable_set_script();
  void set_allocated_set_script(::vrp::SetScriptTransactionData* set_script);
  private:
  const ::vrp::SetScriptTransactionData& _internal_set_script() const;
  ::vrp::SetScriptTransactionData* _internal_mutable_set_script();
  public:
  void unsafe_arena_set_allocated_set_script(
      ::vrp::SetScriptTransactionData* set_script);
  ::vrp::SetScriptTransactionData* unsafe_arena_release_set_script();

  // .vrp.SponsorFeeTransactionData sponsor_fee = 114;
  bool has_sponsor_fee() const;
  private:
  bool _internal_has_sponsor_fee() const;
  public:
  void clear_sponsor_fee();
  const ::vrp::SponsorFeeTransactionData& sponsor_fee() const;
  PROTOBUF_NODISCARD ::vrp::SponsorFeeTransactionData* release_sponsor_fee();
  ::vrp::SponsorFeeTransactionData* mutable_sponsor_fee();
  void set_allocated_sponsor_fee(::vrp::SponsorFeeTransactionData* sponsor_fee);
  private:
  const ::vrp::SponsorFeeTransactionData& _internal_sponsor_fee() const;
  ::vrp::SponsorFeeTransactionData* _internal_mutable_sponsor_fee();
  public:
  void unsafe_arena_set_allocated_sponsor_fee(
      ::vrp::SponsorFeeTransactionData* sponsor_fee);
  ::vrp::SponsorFeeTransactionData* unsafe_arena_release_sponsor_fee();

  // .vrp.SetAssetScriptTransactionData set_asset_script = 115;
  bool has_set_asset_script() const;
  private:
  bool _internal_has_set_asset_script() const;
  public:
  void clear_set_asset_script();
  const ::vrp::SetAssetScriptTransactionData& set_asset_script() const;
  PROTOBUF_NODISCARD ::vrp::SetAssetScriptTransactionData* release_set_asset_script();
  ::vrp::SetAssetScriptTransactionData* mutable_set_asset_script();
  void set_allocated_set_asset_script(::vrp::SetAssetScriptTransactionData* set_asset_script);
  private:
  const ::vrp::SetAssetScriptTransactionData& _internal_set_asset_script() const;
  ::vrp::SetAssetScriptTransactionData* _internal_mutable_set_asset_script();
  public:
  void unsafe_arena_set_allocated_set_asset_script(
      ::vrp::SetAssetScriptTransactionData* set_asset_script);
  ::vrp::SetAssetScriptTransactionData* unsafe_arena_release_set_asset_script();

  // .vrp.InvokeScriptTransactionData invoke_script = 116;
  bool has_invoke_script() const;
  private:
  bool _internal_has_invoke_script() const;
  public:
  void clear_invoke_script();
  const ::vrp::InvokeScriptTransactionData& invoke_script() const;
  PROTOBUF_NODISCARD ::vrp::InvokeScriptTransactionData* release_invoke_script();
  ::vrp::InvokeScriptTransactionData* mutable_invoke_script();
  void set_allocated_invoke_script(::vrp::InvokeScriptTransactionData* invoke_script);
  private:
  const ::vrp::InvokeScriptTransactionData& _internal_invoke_script() const;
  ::vrp::InvokeScriptTransactionData* _internal_mutable_invoke_script();
  public:
  void unsafe_arena_set_allocated_invoke_script(
      ::vrp::InvokeScriptTransactionData* invoke_script);
  ::vrp::InvokeScriptTransactionData* unsafe_arena_release_invoke_script();

  // .vrp.UpdateAssetInfoTransactionData update_asset_info = 117;
  bool has_update_asset_info() const;
  private:
  bool _internal_has_update_asset_info() const;
  public:
  void clear_update_asset_info();
  const ::vrp::UpdateAssetInfoTransactionData& update_asset_info() const;
  PROTOBUF_NODISCARD ::vrp::UpdateAssetInfoTransactionData* release_update_asset_info();
  ::vrp::UpdateAssetInfoTransactionData* mutable_update_asset_info();
  void set_allocated_update_asset_info(::vrp::UpdateAssetInfoTransactionData* update_asset_info);
  private:
  const ::vrp::UpdateAssetInfoTransactionData& _internal_update_asset_info() const;
  ::vrp::UpdateAssetInfoTransactionData* _internal_mutable_update_asset_info();
  public:
  void unsafe_arena_set_allocated_update_asset_info(
      ::vrp::UpdateAssetInfoTransactionData* update_asset_info);
  ::vrp::UpdateAssetInfoTransactionData* unsafe_arena_release_update_asset_info();

  // .vrp.PrivatePaymentTransactionData anonymous_tx = 118;
  bool has_anonymous_tx() const;
  private:
  bool _internal_has_anonymous_tx() const;
  public:
  void clear_anonymous_tx();
  const ::vrp::PrivatePaymentTransactionData& anonymous_tx() const;
  PROTOBUF_NODISCARD ::vrp::PrivatePaymentTransactionData* release_anonymous_tx();
  ::vrp::PrivatePaymentTransactionData* mutable_anonymous_tx();
  void set_allocated_anonymous_tx(::vrp::PrivatePaymentTransactionData* anonymous_tx);
  private:
  const ::vrp::PrivatePaymentTransactionData& _internal_anonymous_tx() const;
  ::vrp::PrivatePaymentTransactionData* _internal_mutable_anonymous_tx();
  public:
  void unsafe_arena_set_allocated_anonymous_tx(
      ::vrp::PrivatePaymentTransactionData* anonymous_tx);
  ::vrp::PrivatePaymentTransactionData* unsafe_arena_release_anonymous_tx();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:vrp.Transaction)
 private:
  class _Internal;
  void set_has_genesis();
  void set_has_payment();
  void set_has_issue();
  void set_has_transfer();
  void set_has_reissue();
  void set_has_burn();
  void set_has_exchange();
  void set_has_lease();
  void set_has_lease_cancel();
  void set_has_create_alias();
  void set_has_mass_transfer();
  void set_has_data_transaction();
  void set_has_set_script();
  void set_has_sponsor_fee();
  void set_has_set_asset_script();
  void set_has_invoke_script();
  void set_has_update_asset_info();
  void set_has_anonymous_tx();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_public_key_;
    ::vrp::Amount* fee_;
    int32_t chain_id_;
    int32_t version_;
    int64_t timestamp_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vrp::GenesisTransactionData* genesis_;
      ::vrp::PaymentTransactionData* payment_;
      ::vrp::IssueTransactionData* issue_;
      ::vrp::TransferTransactionData* transfer_;
      ::vrp::ReissueTransactionData* reissue_;
      ::vrp::BurnTransactionData* burn_;
      ::vrp::ExchangeTransactionData* exchange_;
      ::vrp::LeaseTransactionData* lease_;
      ::vrp::LeaseCancelTransactionData* lease_cancel_;
      ::vrp::CreateAliasTransactionData* create_alias_;
      ::vrp::MassTransferTransactionData* mass_transfer_;
      ::vrp::DataTransactionData* data_transaction_;
      ::vrp::SetScriptTransactionData* set_script_;
      ::vrp::SponsorFeeTransactionData* sponsor_fee_;
      ::vrp::SetAssetScriptTransactionData* set_asset_script_;
      ::vrp::InvokeScriptTransactionData* invoke_script_;
      ::vrp::UpdateAssetInfoTransactionData* update_asset_info_;
      ::vrp::PrivatePaymentTransactionData* anonymous_tx_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class GenesisTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.GenesisTransactionData) */ {
 public:
  inline GenesisTransactionData() : GenesisTransactionData(nullptr) {}
  ~GenesisTransactionData() override;
  explicit PROTOBUF_CONSTEXPR GenesisTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenesisTransactionData(const GenesisTransactionData& from);
  GenesisTransactionData(GenesisTransactionData&& from) noexcept
    : GenesisTransactionData() {
    *this = ::std::move(from);
  }

  inline GenesisTransactionData& operator=(const GenesisTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenesisTransactionData& operator=(GenesisTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenesisTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenesisTransactionData* internal_default_instance() {
    return reinterpret_cast<const GenesisTransactionData*>(
               &_GenesisTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GenesisTransactionData& a, GenesisTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(GenesisTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenesisTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenesisTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenesisTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenesisTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenesisTransactionData& from) {
    GenesisTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenesisTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.GenesisTransactionData";
  }
  protected:
  explicit GenesisTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes recipient_address = 1;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.GenesisTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class PaymentTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.PaymentTransactionData) */ {
 public:
  inline PaymentTransactionData() : PaymentTransactionData(nullptr) {}
  ~PaymentTransactionData() override;
  explicit PROTOBUF_CONSTEXPR PaymentTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentTransactionData(const PaymentTransactionData& from);
  PaymentTransactionData(PaymentTransactionData&& from) noexcept
    : PaymentTransactionData() {
    *this = ::std::move(from);
  }

  inline PaymentTransactionData& operator=(const PaymentTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentTransactionData& operator=(PaymentTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentTransactionData* internal_default_instance() {
    return reinterpret_cast<const PaymentTransactionData*>(
               &_PaymentTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PaymentTransactionData& a, PaymentTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaymentTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaymentTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaymentTransactionData& from) {
    PaymentTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.PaymentTransactionData";
  }
  protected:
  explicit PaymentTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes recipient_address = 1;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.PaymentTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransferTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.TransferTransactionData) */ {
 public:
  inline TransferTransactionData() : TransferTransactionData(nullptr) {}
  ~TransferTransactionData() override;
  explicit PROTOBUF_CONSTEXPR TransferTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferTransactionData(const TransferTransactionData& from);
  TransferTransactionData(TransferTransactionData&& from) noexcept
    : TransferTransactionData() {
    *this = ::std::move(from);
  }

  inline TransferTransactionData& operator=(const TransferTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferTransactionData& operator=(TransferTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferTransactionData* internal_default_instance() {
    return reinterpret_cast<const TransferTransactionData*>(
               &_TransferTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TransferTransactionData& a, TransferTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferTransactionData& from) {
    TransferTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.TransferTransactionData";
  }
  protected:
  explicit TransferTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentFieldNumber = 3,
    kRecipientFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes attachment = 3;
  void clear_attachment();
  const std::string& attachment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachment();
  PROTOBUF_NODISCARD std::string* release_attachment();
  void set_allocated_attachment(std::string* attachment);
  private:
  const std::string& _internal_attachment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachment(const std::string& value);
  std::string* _internal_mutable_attachment();
  public:

  // .vrp.Recipient recipient = 1;
  bool has_recipient() const;
  private:
  bool _internal_has_recipient() const;
  public:
  void clear_recipient();
  const ::vrp::Recipient& recipient() const;
  PROTOBUF_NODISCARD ::vrp::Recipient* release_recipient();
  ::vrp::Recipient* mutable_recipient();
  void set_allocated_recipient(::vrp::Recipient* recipient);
  private:
  const ::vrp::Recipient& _internal_recipient() const;
  ::vrp::Recipient* _internal_mutable_recipient();
  public:
  void unsafe_arena_set_allocated_recipient(
      ::vrp::Recipient* recipient);
  ::vrp::Recipient* unsafe_arena_release_recipient();

  // .vrp.Amount amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::vrp::Amount& amount() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_amount();
  ::vrp::Amount* mutable_amount();
  void set_allocated_amount(::vrp::Amount* amount);
  private:
  const ::vrp::Amount& _internal_amount() const;
  ::vrp::Amount* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::vrp::Amount* amount);
  ::vrp::Amount* unsafe_arena_release_amount();

  // @@protoc_insertion_point(class_scope:vrp.TransferTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachment_;
    ::vrp::Recipient* recipient_;
    ::vrp::Amount* amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class CreateAliasTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.CreateAliasTransactionData) */ {
 public:
  inline CreateAliasTransactionData() : CreateAliasTransactionData(nullptr) {}
  ~CreateAliasTransactionData() override;
  explicit PROTOBUF_CONSTEXPR CreateAliasTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAliasTransactionData(const CreateAliasTransactionData& from);
  CreateAliasTransactionData(CreateAliasTransactionData&& from) noexcept
    : CreateAliasTransactionData() {
    *this = ::std::move(from);
  }

  inline CreateAliasTransactionData& operator=(const CreateAliasTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAliasTransactionData& operator=(CreateAliasTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAliasTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAliasTransactionData* internal_default_instance() {
    return reinterpret_cast<const CreateAliasTransactionData*>(
               &_CreateAliasTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateAliasTransactionData& a, CreateAliasTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAliasTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAliasTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAliasTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAliasTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAliasTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAliasTransactionData& from) {
    CreateAliasTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAliasTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.CreateAliasTransactionData";
  }
  protected:
  explicit CreateAliasTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliasFieldNumber = 1,
  };
  // string alias = 1;
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // @@protoc_insertion_point(class_scope:vrp.CreateAliasTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class DataTransactionData_DataEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.DataTransactionData.DataEntry) */ {
 public:
  inline DataTransactionData_DataEntry() : DataTransactionData_DataEntry(nullptr) {}
  ~DataTransactionData_DataEntry() override;
  explicit PROTOBUF_CONSTEXPR DataTransactionData_DataEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataTransactionData_DataEntry(const DataTransactionData_DataEntry& from);
  DataTransactionData_DataEntry(DataTransactionData_DataEntry&& from) noexcept
    : DataTransactionData_DataEntry() {
    *this = ::std::move(from);
  }

  inline DataTransactionData_DataEntry& operator=(const DataTransactionData_DataEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTransactionData_DataEntry& operator=(DataTransactionData_DataEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataTransactionData_DataEntry& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kIntValue = 10,
    kBoolValue = 11,
    kBinaryValue = 12,
    kStringValue = 13,
    VALUE_NOT_SET = 0,
  };

  static inline const DataTransactionData_DataEntry* internal_default_instance() {
    return reinterpret_cast<const DataTransactionData_DataEntry*>(
               &_DataTransactionData_DataEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataTransactionData_DataEntry& a, DataTransactionData_DataEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DataTransactionData_DataEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataTransactionData_DataEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataTransactionData_DataEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataTransactionData_DataEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataTransactionData_DataEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataTransactionData_DataEntry& from) {
    DataTransactionData_DataEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTransactionData_DataEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.DataTransactionData.DataEntry";
  }
  protected:
  explicit DataTransactionData_DataEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kIntValueFieldNumber = 10,
    kBoolValueFieldNumber = 11,
    kBinaryValueFieldNumber = 12,
    kStringValueFieldNumber = 13,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int64 int_value = 10;
  bool has_int_value() const;
  private:
  bool _internal_has_int_value() const;
  public:
  void clear_int_value();
  int64_t int_value() const;
  void set_int_value(int64_t value);
  private:
  int64_t _internal_int_value() const;
  void _internal_set_int_value(int64_t value);
  public:

  // bool bool_value = 11;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // bytes binary_value = 12;
  bool has_binary_value() const;
  private:
  bool _internal_has_binary_value() const;
  public:
  void clear_binary_value();
  const std::string& binary_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_value();
  PROTOBUF_NODISCARD std::string* release_binary_value();
  void set_allocated_binary_value(std::string* binary_value);
  private:
  const std::string& _internal_binary_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_value(const std::string& value);
  std::string* _internal_mutable_binary_value();
  public:

  // string string_value = 13;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:vrp.DataTransactionData.DataEntry)
 private:
  class _Internal;
  void set_has_int_value();
  void set_has_bool_value();
  void set_has_binary_value();
  void set_has_string_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t int_value_;
      bool bool_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class DataTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.DataTransactionData) */ {
 public:
  inline DataTransactionData() : DataTransactionData(nullptr) {}
  ~DataTransactionData() override;
  explicit PROTOBUF_CONSTEXPR DataTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataTransactionData(const DataTransactionData& from);
  DataTransactionData(DataTransactionData&& from) noexcept
    : DataTransactionData() {
    *this = ::std::move(from);
  }

  inline DataTransactionData& operator=(const DataTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTransactionData& operator=(DataTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataTransactionData* internal_default_instance() {
    return reinterpret_cast<const DataTransactionData*>(
               &_DataTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataTransactionData& a, DataTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(DataTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataTransactionData& from) {
    DataTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.DataTransactionData";
  }
  protected:
  explicit DataTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataTransactionData_DataEntry DataEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .vrp.DataTransactionData.DataEntry data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::vrp::DataTransactionData_DataEntry* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >*
      mutable_data();
  private:
  const ::vrp::DataTransactionData_DataEntry& _internal_data(int index) const;
  ::vrp::DataTransactionData_DataEntry* _internal_add_data();
  public:
  const ::vrp::DataTransactionData_DataEntry& data(int index) const;
  ::vrp::DataTransactionData_DataEntry* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >&
      data() const;

  // @@protoc_insertion_point(class_scope:vrp.DataTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry > data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class MassTransferTransactionData_Transfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.MassTransferTransactionData.Transfer) */ {
 public:
  inline MassTransferTransactionData_Transfer() : MassTransferTransactionData_Transfer(nullptr) {}
  ~MassTransferTransactionData_Transfer() override;
  explicit PROTOBUF_CONSTEXPR MassTransferTransactionData_Transfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MassTransferTransactionData_Transfer(const MassTransferTransactionData_Transfer& from);
  MassTransferTransactionData_Transfer(MassTransferTransactionData_Transfer&& from) noexcept
    : MassTransferTransactionData_Transfer() {
    *this = ::std::move(from);
  }

  inline MassTransferTransactionData_Transfer& operator=(const MassTransferTransactionData_Transfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline MassTransferTransactionData_Transfer& operator=(MassTransferTransactionData_Transfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MassTransferTransactionData_Transfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const MassTransferTransactionData_Transfer* internal_default_instance() {
    return reinterpret_cast<const MassTransferTransactionData_Transfer*>(
               &_MassTransferTransactionData_Transfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MassTransferTransactionData_Transfer& a, MassTransferTransactionData_Transfer& b) {
    a.Swap(&b);
  }
  inline void Swap(MassTransferTransactionData_Transfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MassTransferTransactionData_Transfer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MassTransferTransactionData_Transfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MassTransferTransactionData_Transfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MassTransferTransactionData_Transfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MassTransferTransactionData_Transfer& from) {
    MassTransferTransactionData_Transfer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MassTransferTransactionData_Transfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.MassTransferTransactionData.Transfer";
  }
  protected:
  explicit MassTransferTransactionData_Transfer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // .vrp.Recipient recipient = 1;
  bool has_recipient() const;
  private:
  bool _internal_has_recipient() const;
  public:
  void clear_recipient();
  const ::vrp::Recipient& recipient() const;
  PROTOBUF_NODISCARD ::vrp::Recipient* release_recipient();
  ::vrp::Recipient* mutable_recipient();
  void set_allocated_recipient(::vrp::Recipient* recipient);
  private:
  const ::vrp::Recipient& _internal_recipient() const;
  ::vrp::Recipient* _internal_mutable_recipient();
  public:
  void unsafe_arena_set_allocated_recipient(
      ::vrp::Recipient* recipient);
  ::vrp::Recipient* unsafe_arena_release_recipient();

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.MassTransferTransactionData.Transfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vrp::Recipient* recipient_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class MassTransferTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.MassTransferTransactionData) */ {
 public:
  inline MassTransferTransactionData() : MassTransferTransactionData(nullptr) {}
  ~MassTransferTransactionData() override;
  explicit PROTOBUF_CONSTEXPR MassTransferTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MassTransferTransactionData(const MassTransferTransactionData& from);
  MassTransferTransactionData(MassTransferTransactionData&& from) noexcept
    : MassTransferTransactionData() {
    *this = ::std::move(from);
  }

  inline MassTransferTransactionData& operator=(const MassTransferTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MassTransferTransactionData& operator=(MassTransferTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MassTransferTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MassTransferTransactionData* internal_default_instance() {
    return reinterpret_cast<const MassTransferTransactionData*>(
               &_MassTransferTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MassTransferTransactionData& a, MassTransferTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(MassTransferTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MassTransferTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MassTransferTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MassTransferTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MassTransferTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MassTransferTransactionData& from) {
    MassTransferTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MassTransferTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.MassTransferTransactionData";
  }
  protected:
  explicit MassTransferTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MassTransferTransactionData_Transfer Transfer;

  // accessors -------------------------------------------------------

  enum : int {
    kTransfersFieldNumber = 2,
    kAssetIdFieldNumber = 1,
    kAttachmentFieldNumber = 3,
  };
  // repeated .vrp.MassTransferTransactionData.Transfer transfers = 2;
  int transfers_size() const;
  private:
  int _internal_transfers_size() const;
  public:
  void clear_transfers();
  ::vrp::MassTransferTransactionData_Transfer* mutable_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::MassTransferTransactionData_Transfer >*
      mutable_transfers();
  private:
  const ::vrp::MassTransferTransactionData_Transfer& _internal_transfers(int index) const;
  ::vrp::MassTransferTransactionData_Transfer* _internal_add_transfers();
  public:
  const ::vrp::MassTransferTransactionData_Transfer& transfers(int index) const;
  ::vrp::MassTransferTransactionData_Transfer* add_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::MassTransferTransactionData_Transfer >&
      transfers() const;

  // bytes asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // bytes attachment = 3;
  void clear_attachment();
  const std::string& attachment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachment();
  PROTOBUF_NODISCARD std::string* release_attachment();
  void set_allocated_attachment(std::string* attachment);
  private:
  const std::string& _internal_attachment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachment(const std::string& value);
  std::string* _internal_mutable_attachment();
  public:

  // @@protoc_insertion_point(class_scope:vrp.MassTransferTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::MassTransferTransactionData_Transfer > transfers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class LeaseTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.LeaseTransactionData) */ {
 public:
  inline LeaseTransactionData() : LeaseTransactionData(nullptr) {}
  ~LeaseTransactionData() override;
  explicit PROTOBUF_CONSTEXPR LeaseTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseTransactionData(const LeaseTransactionData& from);
  LeaseTransactionData(LeaseTransactionData&& from) noexcept
    : LeaseTransactionData() {
    *this = ::std::move(from);
  }

  inline LeaseTransactionData& operator=(const LeaseTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseTransactionData& operator=(LeaseTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseTransactionData* internal_default_instance() {
    return reinterpret_cast<const LeaseTransactionData*>(
               &_LeaseTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LeaseTransactionData& a, LeaseTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseTransactionData& from) {
    LeaseTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.LeaseTransactionData";
  }
  protected:
  explicit LeaseTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // .vrp.Recipient recipient = 1;
  bool has_recipient() const;
  private:
  bool _internal_has_recipient() const;
  public:
  void clear_recipient();
  const ::vrp::Recipient& recipient() const;
  PROTOBUF_NODISCARD ::vrp::Recipient* release_recipient();
  ::vrp::Recipient* mutable_recipient();
  void set_allocated_recipient(::vrp::Recipient* recipient);
  private:
  const ::vrp::Recipient& _internal_recipient() const;
  ::vrp::Recipient* _internal_mutable_recipient();
  public:
  void unsafe_arena_set_allocated_recipient(
      ::vrp::Recipient* recipient);
  ::vrp::Recipient* unsafe_arena_release_recipient();

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.LeaseTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vrp::Recipient* recipient_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class LeaseCancelTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.LeaseCancelTransactionData) */ {
 public:
  inline LeaseCancelTransactionData() : LeaseCancelTransactionData(nullptr) {}
  ~LeaseCancelTransactionData() override;
  explicit PROTOBUF_CONSTEXPR LeaseCancelTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaseCancelTransactionData(const LeaseCancelTransactionData& from);
  LeaseCancelTransactionData(LeaseCancelTransactionData&& from) noexcept
    : LeaseCancelTransactionData() {
    *this = ::std::move(from);
  }

  inline LeaseCancelTransactionData& operator=(const LeaseCancelTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseCancelTransactionData& operator=(LeaseCancelTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaseCancelTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaseCancelTransactionData* internal_default_instance() {
    return reinterpret_cast<const LeaseCancelTransactionData*>(
               &_LeaseCancelTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LeaseCancelTransactionData& a, LeaseCancelTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseCancelTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseCancelTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaseCancelTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaseCancelTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaseCancelTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaseCancelTransactionData& from) {
    LeaseCancelTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseCancelTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.LeaseCancelTransactionData";
  }
  protected:
  explicit LeaseCancelTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseIdFieldNumber = 1,
  };
  // bytes lease_id = 1;
  void clear_lease_id();
  const std::string& lease_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lease_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lease_id();
  PROTOBUF_NODISCARD std::string* release_lease_id();
  void set_allocated_lease_id(std::string* lease_id);
  private:
  const std::string& _internal_lease_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lease_id(const std::string& value);
  std::string* _internal_mutable_lease_id();
  public:

  // @@protoc_insertion_point(class_scope:vrp.LeaseCancelTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lease_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class BurnTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.BurnTransactionData) */ {
 public:
  inline BurnTransactionData() : BurnTransactionData(nullptr) {}
  ~BurnTransactionData() override;
  explicit PROTOBUF_CONSTEXPR BurnTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BurnTransactionData(const BurnTransactionData& from);
  BurnTransactionData(BurnTransactionData&& from) noexcept
    : BurnTransactionData() {
    *this = ::std::move(from);
  }

  inline BurnTransactionData& operator=(const BurnTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BurnTransactionData& operator=(BurnTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BurnTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BurnTransactionData* internal_default_instance() {
    return reinterpret_cast<const BurnTransactionData*>(
               &_BurnTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BurnTransactionData& a, BurnTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(BurnTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BurnTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BurnTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BurnTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BurnTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BurnTransactionData& from) {
    BurnTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BurnTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.BurnTransactionData";
  }
  protected:
  explicit BurnTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetAmountFieldNumber = 1,
  };
  // .vrp.Amount asset_amount = 1;
  bool has_asset_amount() const;
  private:
  bool _internal_has_asset_amount() const;
  public:
  void clear_asset_amount();
  const ::vrp::Amount& asset_amount() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_asset_amount();
  ::vrp::Amount* mutable_asset_amount();
  void set_allocated_asset_amount(::vrp::Amount* asset_amount);
  private:
  const ::vrp::Amount& _internal_asset_amount() const;
  ::vrp::Amount* _internal_mutable_asset_amount();
  public:
  void unsafe_arena_set_allocated_asset_amount(
      ::vrp::Amount* asset_amount);
  ::vrp::Amount* unsafe_arena_release_asset_amount();

  // @@protoc_insertion_point(class_scope:vrp.BurnTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vrp::Amount* asset_amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class IssueTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.IssueTransactionData) */ {
 public:
  inline IssueTransactionData() : IssueTransactionData(nullptr) {}
  ~IssueTransactionData() override;
  explicit PROTOBUF_CONSTEXPR IssueTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IssueTransactionData(const IssueTransactionData& from);
  IssueTransactionData(IssueTransactionData&& from) noexcept
    : IssueTransactionData() {
    *this = ::std::move(from);
  }

  inline IssueTransactionData& operator=(const IssueTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IssueTransactionData& operator=(IssueTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IssueTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IssueTransactionData* internal_default_instance() {
    return reinterpret_cast<const IssueTransactionData*>(
               &_IssueTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IssueTransactionData& a, IssueTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(IssueTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IssueTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IssueTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IssueTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IssueTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IssueTransactionData& from) {
    IssueTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IssueTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.IssueTransactionData";
  }
  protected:
  explicit IssueTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kScriptFieldNumber = 6,
    kAmountFieldNumber = 3,
    kDecimalsFieldNumber = 4,
    kReissuableFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bytes script = 6;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_NODISCARD std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // int64 amount = 3;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // int32 decimals = 4;
  void clear_decimals();
  int32_t decimals() const;
  void set_decimals(int32_t value);
  private:
  int32_t _internal_decimals() const;
  void _internal_set_decimals(int32_t value);
  public:

  // bool reissuable = 5;
  void clear_reissuable();
  bool reissuable() const;
  void set_reissuable(bool value);
  private:
  bool _internal_reissuable() const;
  void _internal_set_reissuable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.IssueTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
    int64_t amount_;
    int32_t decimals_;
    bool reissuable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class ReissueTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.ReissueTransactionData) */ {
 public:
  inline ReissueTransactionData() : ReissueTransactionData(nullptr) {}
  ~ReissueTransactionData() override;
  explicit PROTOBUF_CONSTEXPR ReissueTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReissueTransactionData(const ReissueTransactionData& from);
  ReissueTransactionData(ReissueTransactionData&& from) noexcept
    : ReissueTransactionData() {
    *this = ::std::move(from);
  }

  inline ReissueTransactionData& operator=(const ReissueTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReissueTransactionData& operator=(ReissueTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReissueTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReissueTransactionData* internal_default_instance() {
    return reinterpret_cast<const ReissueTransactionData*>(
               &_ReissueTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReissueTransactionData& a, ReissueTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(ReissueTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReissueTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReissueTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReissueTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReissueTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReissueTransactionData& from) {
    ReissueTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReissueTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.ReissueTransactionData";
  }
  protected:
  explicit ReissueTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetAmountFieldNumber = 1,
    kReissuableFieldNumber = 2,
  };
  // .vrp.Amount asset_amount = 1;
  bool has_asset_amount() const;
  private:
  bool _internal_has_asset_amount() const;
  public:
  void clear_asset_amount();
  const ::vrp::Amount& asset_amount() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_asset_amount();
  ::vrp::Amount* mutable_asset_amount();
  void set_allocated_asset_amount(::vrp::Amount* asset_amount);
  private:
  const ::vrp::Amount& _internal_asset_amount() const;
  ::vrp::Amount* _internal_mutable_asset_amount();
  public:
  void unsafe_arena_set_allocated_asset_amount(
      ::vrp::Amount* asset_amount);
  ::vrp::Amount* unsafe_arena_release_asset_amount();

  // bool reissuable = 2;
  void clear_reissuable();
  bool reissuable() const;
  void set_reissuable(bool value);
  private:
  bool _internal_reissuable() const;
  void _internal_set_reissuable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.ReissueTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vrp::Amount* asset_amount_;
    bool reissuable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class SetAssetScriptTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.SetAssetScriptTransactionData) */ {
 public:
  inline SetAssetScriptTransactionData() : SetAssetScriptTransactionData(nullptr) {}
  ~SetAssetScriptTransactionData() override;
  explicit PROTOBUF_CONSTEXPR SetAssetScriptTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAssetScriptTransactionData(const SetAssetScriptTransactionData& from);
  SetAssetScriptTransactionData(SetAssetScriptTransactionData&& from) noexcept
    : SetAssetScriptTransactionData() {
    *this = ::std::move(from);
  }

  inline SetAssetScriptTransactionData& operator=(const SetAssetScriptTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAssetScriptTransactionData& operator=(SetAssetScriptTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAssetScriptTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAssetScriptTransactionData* internal_default_instance() {
    return reinterpret_cast<const SetAssetScriptTransactionData*>(
               &_SetAssetScriptTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetAssetScriptTransactionData& a, SetAssetScriptTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAssetScriptTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAssetScriptTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAssetScriptTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAssetScriptTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAssetScriptTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAssetScriptTransactionData& from) {
    SetAssetScriptTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAssetScriptTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.SetAssetScriptTransactionData";
  }
  protected:
  explicit SetAssetScriptTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kScriptFieldNumber = 2,
  };
  // bytes asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // bytes script = 2;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_NODISCARD std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:vrp.SetAssetScriptTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class SetScriptTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.SetScriptTransactionData) */ {
 public:
  inline SetScriptTransactionData() : SetScriptTransactionData(nullptr) {}
  ~SetScriptTransactionData() override;
  explicit PROTOBUF_CONSTEXPR SetScriptTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetScriptTransactionData(const SetScriptTransactionData& from);
  SetScriptTransactionData(SetScriptTransactionData&& from) noexcept
    : SetScriptTransactionData() {
    *this = ::std::move(from);
  }

  inline SetScriptTransactionData& operator=(const SetScriptTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetScriptTransactionData& operator=(SetScriptTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetScriptTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetScriptTransactionData* internal_default_instance() {
    return reinterpret_cast<const SetScriptTransactionData*>(
               &_SetScriptTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SetScriptTransactionData& a, SetScriptTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(SetScriptTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetScriptTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetScriptTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetScriptTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetScriptTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetScriptTransactionData& from) {
    SetScriptTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetScriptTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.SetScriptTransactionData";
  }
  protected:
  explicit SetScriptTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptFieldNumber = 1,
  };
  // bytes script = 1;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_NODISCARD std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:vrp.SetScriptTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class ExchangeTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.ExchangeTransactionData) */ {
 public:
  inline ExchangeTransactionData() : ExchangeTransactionData(nullptr) {}
  ~ExchangeTransactionData() override;
  explicit PROTOBUF_CONSTEXPR ExchangeTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeTransactionData(const ExchangeTransactionData& from);
  ExchangeTransactionData(ExchangeTransactionData&& from) noexcept
    : ExchangeTransactionData() {
    *this = ::std::move(from);
  }

  inline ExchangeTransactionData& operator=(const ExchangeTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeTransactionData& operator=(ExchangeTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeTransactionData* internal_default_instance() {
    return reinterpret_cast<const ExchangeTransactionData*>(
               &_ExchangeTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ExchangeTransactionData& a, ExchangeTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExchangeTransactionData& from) {
    ExchangeTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.ExchangeTransactionData";
  }
  protected:
  explicit ExchangeTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 5,
    kAmountFieldNumber = 1,
    kPriceFieldNumber = 2,
    kBuyMatcherFeeFieldNumber = 3,
    kSellMatcherFeeFieldNumber = 4,
  };
  // repeated .vrp.Order orders = 5;
  int orders_size() const;
  private:
  int _internal_orders_size() const;
  public:
  void clear_orders();
  ::vrp::Order* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Order >*
      mutable_orders();
  private:
  const ::vrp::Order& _internal_orders(int index) const;
  ::vrp::Order* _internal_add_orders();
  public:
  const ::vrp::Order& orders(int index) const;
  ::vrp::Order* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Order >&
      orders() const;

  // int64 amount = 1;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // int64 price = 2;
  void clear_price();
  int64_t price() const;
  void set_price(int64_t value);
  private:
  int64_t _internal_price() const;
  void _internal_set_price(int64_t value);
  public:

  // int64 buy_matcher_fee = 3;
  void clear_buy_matcher_fee();
  int64_t buy_matcher_fee() const;
  void set_buy_matcher_fee(int64_t value);
  private:
  int64_t _internal_buy_matcher_fee() const;
  void _internal_set_buy_matcher_fee(int64_t value);
  public:

  // int64 sell_matcher_fee = 4;
  void clear_sell_matcher_fee();
  int64_t sell_matcher_fee() const;
  void set_sell_matcher_fee(int64_t value);
  private:
  int64_t _internal_sell_matcher_fee() const;
  void _internal_set_sell_matcher_fee(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.ExchangeTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Order > orders_;
    int64_t amount_;
    int64_t price_;
    int64_t buy_matcher_fee_;
    int64_t sell_matcher_fee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class SponsorFeeTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.SponsorFeeTransactionData) */ {
 public:
  inline SponsorFeeTransactionData() : SponsorFeeTransactionData(nullptr) {}
  ~SponsorFeeTransactionData() override;
  explicit PROTOBUF_CONSTEXPR SponsorFeeTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SponsorFeeTransactionData(const SponsorFeeTransactionData& from);
  SponsorFeeTransactionData(SponsorFeeTransactionData&& from) noexcept
    : SponsorFeeTransactionData() {
    *this = ::std::move(from);
  }

  inline SponsorFeeTransactionData& operator=(const SponsorFeeTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SponsorFeeTransactionData& operator=(SponsorFeeTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SponsorFeeTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SponsorFeeTransactionData* internal_default_instance() {
    return reinterpret_cast<const SponsorFeeTransactionData*>(
               &_SponsorFeeTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SponsorFeeTransactionData& a, SponsorFeeTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(SponsorFeeTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SponsorFeeTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SponsorFeeTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SponsorFeeTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SponsorFeeTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SponsorFeeTransactionData& from) {
    SponsorFeeTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SponsorFeeTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.SponsorFeeTransactionData";
  }
  protected:
  explicit SponsorFeeTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFeeFieldNumber = 1,
  };
  // .vrp.Amount min_fee = 1;
  bool has_min_fee() const;
  private:
  bool _internal_has_min_fee() const;
  public:
  void clear_min_fee();
  const ::vrp::Amount& min_fee() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_min_fee();
  ::vrp::Amount* mutable_min_fee();
  void set_allocated_min_fee(::vrp::Amount* min_fee);
  private:
  const ::vrp::Amount& _internal_min_fee() const;
  ::vrp::Amount* _internal_mutable_min_fee();
  public:
  void unsafe_arena_set_allocated_min_fee(
      ::vrp::Amount* min_fee);
  ::vrp::Amount* unsafe_arena_release_min_fee();

  // @@protoc_insertion_point(class_scope:vrp.SponsorFeeTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vrp::Amount* min_fee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptTransactionData) */ {
 public:
  inline InvokeScriptTransactionData() : InvokeScriptTransactionData(nullptr) {}
  ~InvokeScriptTransactionData() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptTransactionData(const InvokeScriptTransactionData& from);
  InvokeScriptTransactionData(InvokeScriptTransactionData&& from) noexcept
    : InvokeScriptTransactionData() {
    *this = ::std::move(from);
  }

  inline InvokeScriptTransactionData& operator=(const InvokeScriptTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptTransactionData& operator=(InvokeScriptTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptTransactionData* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptTransactionData*>(
               &_InvokeScriptTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(InvokeScriptTransactionData& a, InvokeScriptTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptTransactionData& from) {
    InvokeScriptTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptTransactionData";
  }
  protected:
  explicit InvokeScriptTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaymentsFieldNumber = 3,
    kFunctionCallFieldNumber = 2,
    kDAppFieldNumber = 1,
  };
  // repeated .vrp.Amount payments = 3;
  int payments_size() const;
  private:
  int _internal_payments_size() const;
  public:
  void clear_payments();
  ::vrp::Amount* mutable_payments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >*
      mutable_payments();
  private:
  const ::vrp::Amount& _internal_payments(int index) const;
  ::vrp::Amount* _internal_add_payments();
  public:
  const ::vrp::Amount& payments(int index) const;
  ::vrp::Amount* add_payments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >&
      payments() const;

  // bytes function_call = 2;
  void clear_function_call();
  const std::string& function_call() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_call(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_call();
  PROTOBUF_NODISCARD std::string* release_function_call();
  void set_allocated_function_call(std::string* function_call);
  private:
  const std::string& _internal_function_call() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_call(const std::string& value);
  std::string* _internal_mutable_function_call();
  public:

  // .vrp.Recipient d_app = 1;
  bool has_d_app() const;
  private:
  bool _internal_has_d_app() const;
  public:
  void clear_d_app();
  const ::vrp::Recipient& d_app() const;
  PROTOBUF_NODISCARD ::vrp::Recipient* release_d_app();
  ::vrp::Recipient* mutable_d_app();
  void set_allocated_d_app(::vrp::Recipient* d_app);
  private:
  const ::vrp::Recipient& _internal_d_app() const;
  ::vrp::Recipient* _internal_mutable_d_app();
  public:
  void unsafe_arena_set_allocated_d_app(
      ::vrp::Recipient* d_app);
  ::vrp::Recipient* unsafe_arena_release_d_app();

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount > payments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_call_;
    ::vrp::Recipient* d_app_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class UpdateAssetInfoTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.UpdateAssetInfoTransactionData) */ {
 public:
  inline UpdateAssetInfoTransactionData() : UpdateAssetInfoTransactionData(nullptr) {}
  ~UpdateAssetInfoTransactionData() override;
  explicit PROTOBUF_CONSTEXPR UpdateAssetInfoTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateAssetInfoTransactionData(const UpdateAssetInfoTransactionData& from);
  UpdateAssetInfoTransactionData(UpdateAssetInfoTransactionData&& from) noexcept
    : UpdateAssetInfoTransactionData() {
    *this = ::std::move(from);
  }

  inline UpdateAssetInfoTransactionData& operator=(const UpdateAssetInfoTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAssetInfoTransactionData& operator=(UpdateAssetInfoTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAssetInfoTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAssetInfoTransactionData* internal_default_instance() {
    return reinterpret_cast<const UpdateAssetInfoTransactionData*>(
               &_UpdateAssetInfoTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateAssetInfoTransactionData& a, UpdateAssetInfoTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAssetInfoTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAssetInfoTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAssetInfoTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAssetInfoTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateAssetInfoTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateAssetInfoTransactionData& from) {
    UpdateAssetInfoTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAssetInfoTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.UpdateAssetInfoTransactionData";
  }
  protected:
  explicit UpdateAssetInfoTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kImageFieldNumber = 4,
  };
  // bytes asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string image = 4;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // @@protoc_insertion_point(class_scope:vrp.UpdateAssetInfoTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class InvokeExpressionTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeExpressionTransactionData) */ {
 public:
  inline InvokeExpressionTransactionData() : InvokeExpressionTransactionData(nullptr) {}
  ~InvokeExpressionTransactionData() override;
  explicit PROTOBUF_CONSTEXPR InvokeExpressionTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeExpressionTransactionData(const InvokeExpressionTransactionData& from);
  InvokeExpressionTransactionData(InvokeExpressionTransactionData&& from) noexcept
    : InvokeExpressionTransactionData() {
    *this = ::std::move(from);
  }

  inline InvokeExpressionTransactionData& operator=(const InvokeExpressionTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeExpressionTransactionData& operator=(InvokeExpressionTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeExpressionTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeExpressionTransactionData* internal_default_instance() {
    return reinterpret_cast<const InvokeExpressionTransactionData*>(
               &_InvokeExpressionTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(InvokeExpressionTransactionData& a, InvokeExpressionTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeExpressionTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeExpressionTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeExpressionTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeExpressionTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeExpressionTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeExpressionTransactionData& from) {
    InvokeExpressionTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeExpressionTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeExpressionTransactionData";
  }
  protected:
  explicit InvokeExpressionTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionFieldNumber = 1,
  };
  // bytes expression = 1;
  void clear_expression();
  const std::string& expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expression();
  PROTOBUF_NODISCARD std::string* release_expression();
  void set_allocated_expression(std::string* expression);
  private:
  const std::string& _internal_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeExpressionTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class PrivatePaymentTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.PrivatePaymentTransactionData) */ {
 public:
  inline PrivatePaymentTransactionData() : PrivatePaymentTransactionData(nullptr) {}
  ~PrivatePaymentTransactionData() override;
  explicit PROTOBUF_CONSTEXPR PrivatePaymentTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivatePaymentTransactionData(const PrivatePaymentTransactionData& from);
  PrivatePaymentTransactionData(PrivatePaymentTransactionData&& from) noexcept
    : PrivatePaymentTransactionData() {
    *this = ::std::move(from);
  }

  inline PrivatePaymentTransactionData& operator=(const PrivatePaymentTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivatePaymentTransactionData& operator=(PrivatePaymentTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivatePaymentTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivatePaymentTransactionData* internal_default_instance() {
    return reinterpret_cast<const PrivatePaymentTransactionData*>(
               &_PrivatePaymentTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PrivatePaymentTransactionData& a, PrivatePaymentTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivatePaymentTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivatePaymentTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivatePaymentTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivatePaymentTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivatePaymentTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrivatePaymentTransactionData& from) {
    PrivatePaymentTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivatePaymentTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.PrivatePaymentTransactionData";
  }
  protected:
  explicit PrivatePaymentTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipientAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes recipient_address = 1;
  void clear_recipient_address();
  const std::string& recipient_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_address();
  PROTOBUF_NODISCARD std::string* release_recipient_address();
  void set_allocated_recipient_address(std::string* recipient_address);
  private:
  const std::string& _internal_recipient_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_address(const std::string& value);
  std::string* _internal_mutable_recipient_address();
  public:

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.PrivatePaymentTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_address_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2ftransaction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SignedTransaction

// .vrp.Transaction vrp_transaction = 1;
inline bool SignedTransaction::_internal_has_vrp_transaction() const {
  return transaction_case() == kVrpTransaction;
}
inline bool SignedTransaction::has_vrp_transaction() const {
  return _internal_has_vrp_transaction();
}
inline void SignedTransaction::set_has_vrp_transaction() {
  _impl_._oneof_case_[0] = kVrpTransaction;
}
inline void SignedTransaction::clear_vrp_transaction() {
  if (_internal_has_vrp_transaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.transaction_.vrp_transaction_;
    }
    clear_has_transaction();
  }
}
inline ::vrp::Transaction* SignedTransaction::release_vrp_transaction() {
  // @@protoc_insertion_point(field_release:vrp.SignedTransaction.vrp_transaction)
  if (_internal_has_vrp_transaction()) {
    clear_has_transaction();
    ::vrp::Transaction* temp = _impl_.transaction_.vrp_transaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.transaction_.vrp_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::Transaction& SignedTransaction::_internal_vrp_transaction() const {
  return _internal_has_vrp_transaction()
      ? *_impl_.transaction_.vrp_transaction_
      : reinterpret_cast< ::vrp::Transaction&>(::vrp::_Transaction_default_instance_);
}
inline const ::vrp::Transaction& SignedTransaction::vrp_transaction() const {
  // @@protoc_insertion_point(field_get:vrp.SignedTransaction.vrp_transaction)
  return _internal_vrp_transaction();
}
inline ::vrp::Transaction* SignedTransaction::unsafe_arena_release_vrp_transaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.SignedTransaction.vrp_transaction)
  if (_internal_has_vrp_transaction()) {
    clear_has_transaction();
    ::vrp::Transaction* temp = _impl_.transaction_.vrp_transaction_;
    _impl_.transaction_.vrp_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignedTransaction::unsafe_arena_set_allocated_vrp_transaction(::vrp::Transaction* vrp_transaction) {
  clear_transaction();
  if (vrp_transaction) {
    set_has_vrp_transaction();
    _impl_.transaction_.vrp_transaction_ = vrp_transaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.SignedTransaction.vrp_transaction)
}
inline ::vrp::Transaction* SignedTransaction::_internal_mutable_vrp_transaction() {
  if (!_internal_has_vrp_transaction()) {
    clear_transaction();
    set_has_vrp_transaction();
    _impl_.transaction_.vrp_transaction_ = CreateMaybeMessage< ::vrp::Transaction >(GetArenaForAllocation());
  }
  return _impl_.transaction_.vrp_transaction_;
}
inline ::vrp::Transaction* SignedTransaction::mutable_vrp_transaction() {
  ::vrp::Transaction* _msg = _internal_mutable_vrp_transaction();
  // @@protoc_insertion_point(field_mutable:vrp.SignedTransaction.vrp_transaction)
  return _msg;
}

// bytes ethereum_transaction = 3;
inline bool SignedTransaction::_internal_has_ethereum_transaction() const {
  return transaction_case() == kEthereumTransaction;
}
inline bool SignedTransaction::has_ethereum_transaction() const {
  return _internal_has_ethereum_transaction();
}
inline void SignedTransaction::set_has_ethereum_transaction() {
  _impl_._oneof_case_[0] = kEthereumTransaction;
}
inline void SignedTransaction::clear_ethereum_transaction() {
  if (_internal_has_ethereum_transaction()) {
    _impl_.transaction_.ethereum_transaction_.Destroy();
    clear_has_transaction();
  }
}
inline const std::string& SignedTransaction::ethereum_transaction() const {
  // @@protoc_insertion_point(field_get:vrp.SignedTransaction.ethereum_transaction)
  return _internal_ethereum_transaction();
}
template <typename ArgT0, typename... ArgT>
inline void SignedTransaction::set_ethereum_transaction(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ethereum_transaction()) {
    clear_transaction();
    set_has_ethereum_transaction();
    _impl_.transaction_.ethereum_transaction_.InitDefault();
  }
  _impl_.transaction_.ethereum_transaction_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.SignedTransaction.ethereum_transaction)
}
inline std::string* SignedTransaction::mutable_ethereum_transaction() {
  std::string* _s = _internal_mutable_ethereum_transaction();
  // @@protoc_insertion_point(field_mutable:vrp.SignedTransaction.ethereum_transaction)
  return _s;
}
inline const std::string& SignedTransaction::_internal_ethereum_transaction() const {
  if (_internal_has_ethereum_transaction()) {
    return _impl_.transaction_.ethereum_transaction_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignedTransaction::_internal_set_ethereum_transaction(const std::string& value) {
  if (!_internal_has_ethereum_transaction()) {
    clear_transaction();
    set_has_ethereum_transaction();
    _impl_.transaction_.ethereum_transaction_.InitDefault();
  }
  _impl_.transaction_.ethereum_transaction_.Set(value, GetArenaForAllocation());
}
inline std::string* SignedTransaction::_internal_mutable_ethereum_transaction() {
  if (!_internal_has_ethereum_transaction()) {
    clear_transaction();
    set_has_ethereum_transaction();
    _impl_.transaction_.ethereum_transaction_.InitDefault();
  }
  return _impl_.transaction_.ethereum_transaction_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignedTransaction::release_ethereum_transaction() {
  // @@protoc_insertion_point(field_release:vrp.SignedTransaction.ethereum_transaction)
  if (_internal_has_ethereum_transaction()) {
    clear_has_transaction();
    return _impl_.transaction_.ethereum_transaction_.Release();
  } else {
    return nullptr;
  }
}
inline void SignedTransaction::set_allocated_ethereum_transaction(std::string* ethereum_transaction) {
  if (has_transaction()) {
    clear_transaction();
  }
  if (ethereum_transaction != nullptr) {
    set_has_ethereum_transaction();
    _impl_.transaction_.ethereum_transaction_.InitAllocated(ethereum_transaction, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.SignedTransaction.ethereum_transaction)
}

// repeated bytes proofs = 2;
inline int SignedTransaction::_internal_proofs_size() const {
  return _impl_.proofs_.size();
}
inline int SignedTransaction::proofs_size() const {
  return _internal_proofs_size();
}
inline void SignedTransaction::clear_proofs() {
  _impl_.proofs_.Clear();
}
inline std::string* SignedTransaction::add_proofs() {
  std::string* _s = _internal_add_proofs();
  // @@protoc_insertion_point(field_add_mutable:vrp.SignedTransaction.proofs)
  return _s;
}
inline const std::string& SignedTransaction::_internal_proofs(int index) const {
  return _impl_.proofs_.Get(index);
}
inline const std::string& SignedTransaction::proofs(int index) const {
  // @@protoc_insertion_point(field_get:vrp.SignedTransaction.proofs)
  return _internal_proofs(index);
}
inline std::string* SignedTransaction::mutable_proofs(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.SignedTransaction.proofs)
  return _impl_.proofs_.Mutable(index);
}
inline void SignedTransaction::set_proofs(int index, const std::string& value) {
  _impl_.proofs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vrp.SignedTransaction.proofs)
}
inline void SignedTransaction::set_proofs(int index, std::string&& value) {
  _impl_.proofs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vrp.SignedTransaction.proofs)
}
inline void SignedTransaction::set_proofs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proofs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vrp.SignedTransaction.proofs)
}
inline void SignedTransaction::set_proofs(int index, const void* value, size_t size) {
  _impl_.proofs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vrp.SignedTransaction.proofs)
}
inline std::string* SignedTransaction::_internal_add_proofs() {
  return _impl_.proofs_.Add();
}
inline void SignedTransaction::add_proofs(const std::string& value) {
  _impl_.proofs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vrp.SignedTransaction.proofs)
}
inline void SignedTransaction::add_proofs(std::string&& value) {
  _impl_.proofs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vrp.SignedTransaction.proofs)
}
inline void SignedTransaction::add_proofs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.proofs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vrp.SignedTransaction.proofs)
}
inline void SignedTransaction::add_proofs(const void* value, size_t size) {
  _impl_.proofs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vrp.SignedTransaction.proofs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SignedTransaction::proofs() const {
  // @@protoc_insertion_point(field_list:vrp.SignedTransaction.proofs)
  return _impl_.proofs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SignedTransaction::mutable_proofs() {
  // @@protoc_insertion_point(field_mutable_list:vrp.SignedTransaction.proofs)
  return &_impl_.proofs_;
}

inline bool SignedTransaction::has_transaction() const {
  return transaction_case() != TRANSACTION_NOT_SET;
}
inline void SignedTransaction::clear_has_transaction() {
  _impl_._oneof_case_[0] = TRANSACTION_NOT_SET;
}
inline SignedTransaction::TransactionCase SignedTransaction::transaction_case() const {
  return SignedTransaction::TransactionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Transaction

// int32 chain_id = 1;
inline void Transaction::clear_chain_id() {
  _impl_.chain_id_ = 0;
}
inline int32_t Transaction::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline int32_t Transaction::chain_id() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.chain_id)
  return _internal_chain_id();
}
inline void Transaction::_internal_set_chain_id(int32_t value) {
  
  _impl_.chain_id_ = value;
}
inline void Transaction::set_chain_id(int32_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:vrp.Transaction.chain_id)
}

// bytes sender_public_key = 2;
inline void Transaction::clear_sender_public_key() {
  _impl_.sender_public_key_.ClearToEmpty();
}
inline const std::string& Transaction::sender_public_key() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.sender_public_key)
  return _internal_sender_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction::set_sender_public_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.Transaction.sender_public_key)
}
inline std::string* Transaction::mutable_sender_public_key() {
  std::string* _s = _internal_mutable_sender_public_key();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.sender_public_key)
  return _s;
}
inline const std::string& Transaction::_internal_sender_public_key() const {
  return _impl_.sender_public_key_.Get();
}
inline void Transaction::_internal_set_sender_public_key(const std::string& value) {
  
  _impl_.sender_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Transaction::_internal_mutable_sender_public_key() {
  
  return _impl_.sender_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Transaction::release_sender_public_key() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.sender_public_key)
  return _impl_.sender_public_key_.Release();
}
inline void Transaction::set_allocated_sender_public_key(std::string* sender_public_key) {
  if (sender_public_key != nullptr) {
    
  } else {
    
  }
  _impl_.sender_public_key_.SetAllocated(sender_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_public_key_.IsDefault()) {
    _impl_.sender_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.sender_public_key)
}

// .vrp.Amount fee = 3;
inline bool Transaction::_internal_has_fee() const {
  return this != internal_default_instance() && _impl_.fee_ != nullptr;
}
inline bool Transaction::has_fee() const {
  return _internal_has_fee();
}
inline const ::vrp::Amount& Transaction::_internal_fee() const {
  const ::vrp::Amount* p = _impl_.fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& Transaction::fee() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.fee)
  return _internal_fee();
}
inline void Transaction::unsafe_arena_set_allocated_fee(
    ::vrp::Amount* fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_);
  }
  _impl_.fee_ = fee;
  if (fee) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.fee)
}
inline ::vrp::Amount* Transaction::release_fee() {
  
  ::vrp::Amount* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* Transaction::unsafe_arena_release_fee() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.fee)
  
  ::vrp::Amount* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
  return temp;
}
inline ::vrp::Amount* Transaction::_internal_mutable_fee() {
  
  if (_impl_.fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.fee_ = p;
  }
  return _impl_.fee_;
}
inline ::vrp::Amount* Transaction::mutable_fee() {
  ::vrp::Amount* _msg = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.fee)
  return _msg;
}
inline void Transaction::set_allocated_fee(::vrp::Amount* fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_);
  }
  if (fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fee));
    if (message_arena != submessage_arena) {
      fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.fee)
}

// int64 timestamp = 4;
inline void Transaction::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Transaction::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Transaction::timestamp() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.timestamp)
  return _internal_timestamp();
}
inline void Transaction::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Transaction::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vrp.Transaction.timestamp)
}

// int32 version = 5;
inline void Transaction::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t Transaction::_internal_version() const {
  return _impl_.version_;
}
inline int32_t Transaction::version() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.version)
  return _internal_version();
}
inline void Transaction::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void Transaction::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:vrp.Transaction.version)
}

// .vrp.GenesisTransactionData genesis = 101;
inline bool Transaction::_internal_has_genesis() const {
  return data_case() == kGenesis;
}
inline bool Transaction::has_genesis() const {
  return _internal_has_genesis();
}
inline void Transaction::set_has_genesis() {
  _impl_._oneof_case_[0] = kGenesis;
}
inline void Transaction::clear_genesis() {
  if (_internal_has_genesis()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.genesis_;
    }
    clear_has_data();
  }
}
inline ::vrp::GenesisTransactionData* Transaction::release_genesis() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.genesis)
  if (_internal_has_genesis()) {
    clear_has_data();
    ::vrp::GenesisTransactionData* temp = _impl_.data_.genesis_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.genesis_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::GenesisTransactionData& Transaction::_internal_genesis() const {
  return _internal_has_genesis()
      ? *_impl_.data_.genesis_
      : reinterpret_cast< ::vrp::GenesisTransactionData&>(::vrp::_GenesisTransactionData_default_instance_);
}
inline const ::vrp::GenesisTransactionData& Transaction::genesis() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.genesis)
  return _internal_genesis();
}
inline ::vrp::GenesisTransactionData* Transaction::unsafe_arena_release_genesis() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.genesis)
  if (_internal_has_genesis()) {
    clear_has_data();
    ::vrp::GenesisTransactionData* temp = _impl_.data_.genesis_;
    _impl_.data_.genesis_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_genesis(::vrp::GenesisTransactionData* genesis) {
  clear_data();
  if (genesis) {
    set_has_genesis();
    _impl_.data_.genesis_ = genesis;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.genesis)
}
inline ::vrp::GenesisTransactionData* Transaction::_internal_mutable_genesis() {
  if (!_internal_has_genesis()) {
    clear_data();
    set_has_genesis();
    _impl_.data_.genesis_ = CreateMaybeMessage< ::vrp::GenesisTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.genesis_;
}
inline ::vrp::GenesisTransactionData* Transaction::mutable_genesis() {
  ::vrp::GenesisTransactionData* _msg = _internal_mutable_genesis();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.genesis)
  return _msg;
}

// .vrp.PaymentTransactionData payment = 102;
inline bool Transaction::_internal_has_payment() const {
  return data_case() == kPayment;
}
inline bool Transaction::has_payment() const {
  return _internal_has_payment();
}
inline void Transaction::set_has_payment() {
  _impl_._oneof_case_[0] = kPayment;
}
inline void Transaction::clear_payment() {
  if (_internal_has_payment()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.payment_;
    }
    clear_has_data();
  }
}
inline ::vrp::PaymentTransactionData* Transaction::release_payment() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.payment)
  if (_internal_has_payment()) {
    clear_has_data();
    ::vrp::PaymentTransactionData* temp = _impl_.data_.payment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.payment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::PaymentTransactionData& Transaction::_internal_payment() const {
  return _internal_has_payment()
      ? *_impl_.data_.payment_
      : reinterpret_cast< ::vrp::PaymentTransactionData&>(::vrp::_PaymentTransactionData_default_instance_);
}
inline const ::vrp::PaymentTransactionData& Transaction::payment() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.payment)
  return _internal_payment();
}
inline ::vrp::PaymentTransactionData* Transaction::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.payment)
  if (_internal_has_payment()) {
    clear_has_data();
    ::vrp::PaymentTransactionData* temp = _impl_.data_.payment_;
    _impl_.data_.payment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_payment(::vrp::PaymentTransactionData* payment) {
  clear_data();
  if (payment) {
    set_has_payment();
    _impl_.data_.payment_ = payment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.payment)
}
inline ::vrp::PaymentTransactionData* Transaction::_internal_mutable_payment() {
  if (!_internal_has_payment()) {
    clear_data();
    set_has_payment();
    _impl_.data_.payment_ = CreateMaybeMessage< ::vrp::PaymentTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.payment_;
}
inline ::vrp::PaymentTransactionData* Transaction::mutable_payment() {
  ::vrp::PaymentTransactionData* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.payment)
  return _msg;
}

// .vrp.IssueTransactionData issue = 103;
inline bool Transaction::_internal_has_issue() const {
  return data_case() == kIssue;
}
inline bool Transaction::has_issue() const {
  return _internal_has_issue();
}
inline void Transaction::set_has_issue() {
  _impl_._oneof_case_[0] = kIssue;
}
inline void Transaction::clear_issue() {
  if (_internal_has_issue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.issue_;
    }
    clear_has_data();
  }
}
inline ::vrp::IssueTransactionData* Transaction::release_issue() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.issue)
  if (_internal_has_issue()) {
    clear_has_data();
    ::vrp::IssueTransactionData* temp = _impl_.data_.issue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.issue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::IssueTransactionData& Transaction::_internal_issue() const {
  return _internal_has_issue()
      ? *_impl_.data_.issue_
      : reinterpret_cast< ::vrp::IssueTransactionData&>(::vrp::_IssueTransactionData_default_instance_);
}
inline const ::vrp::IssueTransactionData& Transaction::issue() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.issue)
  return _internal_issue();
}
inline ::vrp::IssueTransactionData* Transaction::unsafe_arena_release_issue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.issue)
  if (_internal_has_issue()) {
    clear_has_data();
    ::vrp::IssueTransactionData* temp = _impl_.data_.issue_;
    _impl_.data_.issue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_issue(::vrp::IssueTransactionData* issue) {
  clear_data();
  if (issue) {
    set_has_issue();
    _impl_.data_.issue_ = issue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.issue)
}
inline ::vrp::IssueTransactionData* Transaction::_internal_mutable_issue() {
  if (!_internal_has_issue()) {
    clear_data();
    set_has_issue();
    _impl_.data_.issue_ = CreateMaybeMessage< ::vrp::IssueTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.issue_;
}
inline ::vrp::IssueTransactionData* Transaction::mutable_issue() {
  ::vrp::IssueTransactionData* _msg = _internal_mutable_issue();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.issue)
  return _msg;
}

// .vrp.TransferTransactionData transfer = 104;
inline bool Transaction::_internal_has_transfer() const {
  return data_case() == kTransfer;
}
inline bool Transaction::has_transfer() const {
  return _internal_has_transfer();
}
inline void Transaction::set_has_transfer() {
  _impl_._oneof_case_[0] = kTransfer;
}
inline void Transaction::clear_transfer() {
  if (_internal_has_transfer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.transfer_;
    }
    clear_has_data();
  }
}
inline ::vrp::TransferTransactionData* Transaction::release_transfer() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.transfer)
  if (_internal_has_transfer()) {
    clear_has_data();
    ::vrp::TransferTransactionData* temp = _impl_.data_.transfer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::TransferTransactionData& Transaction::_internal_transfer() const {
  return _internal_has_transfer()
      ? *_impl_.data_.transfer_
      : reinterpret_cast< ::vrp::TransferTransactionData&>(::vrp::_TransferTransactionData_default_instance_);
}
inline const ::vrp::TransferTransactionData& Transaction::transfer() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.transfer)
  return _internal_transfer();
}
inline ::vrp::TransferTransactionData* Transaction::unsafe_arena_release_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.transfer)
  if (_internal_has_transfer()) {
    clear_has_data();
    ::vrp::TransferTransactionData* temp = _impl_.data_.transfer_;
    _impl_.data_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_transfer(::vrp::TransferTransactionData* transfer) {
  clear_data();
  if (transfer) {
    set_has_transfer();
    _impl_.data_.transfer_ = transfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.transfer)
}
inline ::vrp::TransferTransactionData* Transaction::_internal_mutable_transfer() {
  if (!_internal_has_transfer()) {
    clear_data();
    set_has_transfer();
    _impl_.data_.transfer_ = CreateMaybeMessage< ::vrp::TransferTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.transfer_;
}
inline ::vrp::TransferTransactionData* Transaction::mutable_transfer() {
  ::vrp::TransferTransactionData* _msg = _internal_mutable_transfer();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.transfer)
  return _msg;
}

// .vrp.ReissueTransactionData reissue = 105;
inline bool Transaction::_internal_has_reissue() const {
  return data_case() == kReissue;
}
inline bool Transaction::has_reissue() const {
  return _internal_has_reissue();
}
inline void Transaction::set_has_reissue() {
  _impl_._oneof_case_[0] = kReissue;
}
inline void Transaction::clear_reissue() {
  if (_internal_has_reissue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.reissue_;
    }
    clear_has_data();
  }
}
inline ::vrp::ReissueTransactionData* Transaction::release_reissue() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.reissue)
  if (_internal_has_reissue()) {
    clear_has_data();
    ::vrp::ReissueTransactionData* temp = _impl_.data_.reissue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.reissue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::ReissueTransactionData& Transaction::_internal_reissue() const {
  return _internal_has_reissue()
      ? *_impl_.data_.reissue_
      : reinterpret_cast< ::vrp::ReissueTransactionData&>(::vrp::_ReissueTransactionData_default_instance_);
}
inline const ::vrp::ReissueTransactionData& Transaction::reissue() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.reissue)
  return _internal_reissue();
}
inline ::vrp::ReissueTransactionData* Transaction::unsafe_arena_release_reissue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.reissue)
  if (_internal_has_reissue()) {
    clear_has_data();
    ::vrp::ReissueTransactionData* temp = _impl_.data_.reissue_;
    _impl_.data_.reissue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_reissue(::vrp::ReissueTransactionData* reissue) {
  clear_data();
  if (reissue) {
    set_has_reissue();
    _impl_.data_.reissue_ = reissue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.reissue)
}
inline ::vrp::ReissueTransactionData* Transaction::_internal_mutable_reissue() {
  if (!_internal_has_reissue()) {
    clear_data();
    set_has_reissue();
    _impl_.data_.reissue_ = CreateMaybeMessage< ::vrp::ReissueTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.reissue_;
}
inline ::vrp::ReissueTransactionData* Transaction::mutable_reissue() {
  ::vrp::ReissueTransactionData* _msg = _internal_mutable_reissue();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.reissue)
  return _msg;
}

// .vrp.BurnTransactionData burn = 106;
inline bool Transaction::_internal_has_burn() const {
  return data_case() == kBurn;
}
inline bool Transaction::has_burn() const {
  return _internal_has_burn();
}
inline void Transaction::set_has_burn() {
  _impl_._oneof_case_[0] = kBurn;
}
inline void Transaction::clear_burn() {
  if (_internal_has_burn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.burn_;
    }
    clear_has_data();
  }
}
inline ::vrp::BurnTransactionData* Transaction::release_burn() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.burn)
  if (_internal_has_burn()) {
    clear_has_data();
    ::vrp::BurnTransactionData* temp = _impl_.data_.burn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.burn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::BurnTransactionData& Transaction::_internal_burn() const {
  return _internal_has_burn()
      ? *_impl_.data_.burn_
      : reinterpret_cast< ::vrp::BurnTransactionData&>(::vrp::_BurnTransactionData_default_instance_);
}
inline const ::vrp::BurnTransactionData& Transaction::burn() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.burn)
  return _internal_burn();
}
inline ::vrp::BurnTransactionData* Transaction::unsafe_arena_release_burn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.burn)
  if (_internal_has_burn()) {
    clear_has_data();
    ::vrp::BurnTransactionData* temp = _impl_.data_.burn_;
    _impl_.data_.burn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_burn(::vrp::BurnTransactionData* burn) {
  clear_data();
  if (burn) {
    set_has_burn();
    _impl_.data_.burn_ = burn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.burn)
}
inline ::vrp::BurnTransactionData* Transaction::_internal_mutable_burn() {
  if (!_internal_has_burn()) {
    clear_data();
    set_has_burn();
    _impl_.data_.burn_ = CreateMaybeMessage< ::vrp::BurnTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.burn_;
}
inline ::vrp::BurnTransactionData* Transaction::mutable_burn() {
  ::vrp::BurnTransactionData* _msg = _internal_mutable_burn();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.burn)
  return _msg;
}

// .vrp.ExchangeTransactionData exchange = 107;
inline bool Transaction::_internal_has_exchange() const {
  return data_case() == kExchange;
}
inline bool Transaction::has_exchange() const {
  return _internal_has_exchange();
}
inline void Transaction::set_has_exchange() {
  _impl_._oneof_case_[0] = kExchange;
}
inline void Transaction::clear_exchange() {
  if (_internal_has_exchange()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.exchange_;
    }
    clear_has_data();
  }
}
inline ::vrp::ExchangeTransactionData* Transaction::release_exchange() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.exchange)
  if (_internal_has_exchange()) {
    clear_has_data();
    ::vrp::ExchangeTransactionData* temp = _impl_.data_.exchange_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.exchange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::ExchangeTransactionData& Transaction::_internal_exchange() const {
  return _internal_has_exchange()
      ? *_impl_.data_.exchange_
      : reinterpret_cast< ::vrp::ExchangeTransactionData&>(::vrp::_ExchangeTransactionData_default_instance_);
}
inline const ::vrp::ExchangeTransactionData& Transaction::exchange() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.exchange)
  return _internal_exchange();
}
inline ::vrp::ExchangeTransactionData* Transaction::unsafe_arena_release_exchange() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.exchange)
  if (_internal_has_exchange()) {
    clear_has_data();
    ::vrp::ExchangeTransactionData* temp = _impl_.data_.exchange_;
    _impl_.data_.exchange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_exchange(::vrp::ExchangeTransactionData* exchange) {
  clear_data();
  if (exchange) {
    set_has_exchange();
    _impl_.data_.exchange_ = exchange;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.exchange)
}
inline ::vrp::ExchangeTransactionData* Transaction::_internal_mutable_exchange() {
  if (!_internal_has_exchange()) {
    clear_data();
    set_has_exchange();
    _impl_.data_.exchange_ = CreateMaybeMessage< ::vrp::ExchangeTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.exchange_;
}
inline ::vrp::ExchangeTransactionData* Transaction::mutable_exchange() {
  ::vrp::ExchangeTransactionData* _msg = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.exchange)
  return _msg;
}

// .vrp.LeaseTransactionData lease = 108;
inline bool Transaction::_internal_has_lease() const {
  return data_case() == kLease;
}
inline bool Transaction::has_lease() const {
  return _internal_has_lease();
}
inline void Transaction::set_has_lease() {
  _impl_._oneof_case_[0] = kLease;
}
inline void Transaction::clear_lease() {
  if (_internal_has_lease()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.lease_;
    }
    clear_has_data();
  }
}
inline ::vrp::LeaseTransactionData* Transaction::release_lease() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.lease)
  if (_internal_has_lease()) {
    clear_has_data();
    ::vrp::LeaseTransactionData* temp = _impl_.data_.lease_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.lease_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::LeaseTransactionData& Transaction::_internal_lease() const {
  return _internal_has_lease()
      ? *_impl_.data_.lease_
      : reinterpret_cast< ::vrp::LeaseTransactionData&>(::vrp::_LeaseTransactionData_default_instance_);
}
inline const ::vrp::LeaseTransactionData& Transaction::lease() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.lease)
  return _internal_lease();
}
inline ::vrp::LeaseTransactionData* Transaction::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.lease)
  if (_internal_has_lease()) {
    clear_has_data();
    ::vrp::LeaseTransactionData* temp = _impl_.data_.lease_;
    _impl_.data_.lease_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_lease(::vrp::LeaseTransactionData* lease) {
  clear_data();
  if (lease) {
    set_has_lease();
    _impl_.data_.lease_ = lease;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.lease)
}
inline ::vrp::LeaseTransactionData* Transaction::_internal_mutable_lease() {
  if (!_internal_has_lease()) {
    clear_data();
    set_has_lease();
    _impl_.data_.lease_ = CreateMaybeMessage< ::vrp::LeaseTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.lease_;
}
inline ::vrp::LeaseTransactionData* Transaction::mutable_lease() {
  ::vrp::LeaseTransactionData* _msg = _internal_mutable_lease();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.lease)
  return _msg;
}

// .vrp.LeaseCancelTransactionData lease_cancel = 109;
inline bool Transaction::_internal_has_lease_cancel() const {
  return data_case() == kLeaseCancel;
}
inline bool Transaction::has_lease_cancel() const {
  return _internal_has_lease_cancel();
}
inline void Transaction::set_has_lease_cancel() {
  _impl_._oneof_case_[0] = kLeaseCancel;
}
inline void Transaction::clear_lease_cancel() {
  if (_internal_has_lease_cancel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.lease_cancel_;
    }
    clear_has_data();
  }
}
inline ::vrp::LeaseCancelTransactionData* Transaction::release_lease_cancel() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.lease_cancel)
  if (_internal_has_lease_cancel()) {
    clear_has_data();
    ::vrp::LeaseCancelTransactionData* temp = _impl_.data_.lease_cancel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.lease_cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::LeaseCancelTransactionData& Transaction::_internal_lease_cancel() const {
  return _internal_has_lease_cancel()
      ? *_impl_.data_.lease_cancel_
      : reinterpret_cast< ::vrp::LeaseCancelTransactionData&>(::vrp::_LeaseCancelTransactionData_default_instance_);
}
inline const ::vrp::LeaseCancelTransactionData& Transaction::lease_cancel() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.lease_cancel)
  return _internal_lease_cancel();
}
inline ::vrp::LeaseCancelTransactionData* Transaction::unsafe_arena_release_lease_cancel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.lease_cancel)
  if (_internal_has_lease_cancel()) {
    clear_has_data();
    ::vrp::LeaseCancelTransactionData* temp = _impl_.data_.lease_cancel_;
    _impl_.data_.lease_cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_lease_cancel(::vrp::LeaseCancelTransactionData* lease_cancel) {
  clear_data();
  if (lease_cancel) {
    set_has_lease_cancel();
    _impl_.data_.lease_cancel_ = lease_cancel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.lease_cancel)
}
inline ::vrp::LeaseCancelTransactionData* Transaction::_internal_mutable_lease_cancel() {
  if (!_internal_has_lease_cancel()) {
    clear_data();
    set_has_lease_cancel();
    _impl_.data_.lease_cancel_ = CreateMaybeMessage< ::vrp::LeaseCancelTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.lease_cancel_;
}
inline ::vrp::LeaseCancelTransactionData* Transaction::mutable_lease_cancel() {
  ::vrp::LeaseCancelTransactionData* _msg = _internal_mutable_lease_cancel();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.lease_cancel)
  return _msg;
}

// .vrp.CreateAliasTransactionData create_alias = 110;
inline bool Transaction::_internal_has_create_alias() const {
  return data_case() == kCreateAlias;
}
inline bool Transaction::has_create_alias() const {
  return _internal_has_create_alias();
}
inline void Transaction::set_has_create_alias() {
  _impl_._oneof_case_[0] = kCreateAlias;
}
inline void Transaction::clear_create_alias() {
  if (_internal_has_create_alias()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.create_alias_;
    }
    clear_has_data();
  }
}
inline ::vrp::CreateAliasTransactionData* Transaction::release_create_alias() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.create_alias)
  if (_internal_has_create_alias()) {
    clear_has_data();
    ::vrp::CreateAliasTransactionData* temp = _impl_.data_.create_alias_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.create_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::CreateAliasTransactionData& Transaction::_internal_create_alias() const {
  return _internal_has_create_alias()
      ? *_impl_.data_.create_alias_
      : reinterpret_cast< ::vrp::CreateAliasTransactionData&>(::vrp::_CreateAliasTransactionData_default_instance_);
}
inline const ::vrp::CreateAliasTransactionData& Transaction::create_alias() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.create_alias)
  return _internal_create_alias();
}
inline ::vrp::CreateAliasTransactionData* Transaction::unsafe_arena_release_create_alias() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.create_alias)
  if (_internal_has_create_alias()) {
    clear_has_data();
    ::vrp::CreateAliasTransactionData* temp = _impl_.data_.create_alias_;
    _impl_.data_.create_alias_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_create_alias(::vrp::CreateAliasTransactionData* create_alias) {
  clear_data();
  if (create_alias) {
    set_has_create_alias();
    _impl_.data_.create_alias_ = create_alias;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.create_alias)
}
inline ::vrp::CreateAliasTransactionData* Transaction::_internal_mutable_create_alias() {
  if (!_internal_has_create_alias()) {
    clear_data();
    set_has_create_alias();
    _impl_.data_.create_alias_ = CreateMaybeMessage< ::vrp::CreateAliasTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.create_alias_;
}
inline ::vrp::CreateAliasTransactionData* Transaction::mutable_create_alias() {
  ::vrp::CreateAliasTransactionData* _msg = _internal_mutable_create_alias();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.create_alias)
  return _msg;
}

// .vrp.MassTransferTransactionData mass_transfer = 111;
inline bool Transaction::_internal_has_mass_transfer() const {
  return data_case() == kMassTransfer;
}
inline bool Transaction::has_mass_transfer() const {
  return _internal_has_mass_transfer();
}
inline void Transaction::set_has_mass_transfer() {
  _impl_._oneof_case_[0] = kMassTransfer;
}
inline void Transaction::clear_mass_transfer() {
  if (_internal_has_mass_transfer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.mass_transfer_;
    }
    clear_has_data();
  }
}
inline ::vrp::MassTransferTransactionData* Transaction::release_mass_transfer() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.mass_transfer)
  if (_internal_has_mass_transfer()) {
    clear_has_data();
    ::vrp::MassTransferTransactionData* temp = _impl_.data_.mass_transfer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.mass_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::MassTransferTransactionData& Transaction::_internal_mass_transfer() const {
  return _internal_has_mass_transfer()
      ? *_impl_.data_.mass_transfer_
      : reinterpret_cast< ::vrp::MassTransferTransactionData&>(::vrp::_MassTransferTransactionData_default_instance_);
}
inline const ::vrp::MassTransferTransactionData& Transaction::mass_transfer() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.mass_transfer)
  return _internal_mass_transfer();
}
inline ::vrp::MassTransferTransactionData* Transaction::unsafe_arena_release_mass_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.mass_transfer)
  if (_internal_has_mass_transfer()) {
    clear_has_data();
    ::vrp::MassTransferTransactionData* temp = _impl_.data_.mass_transfer_;
    _impl_.data_.mass_transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_mass_transfer(::vrp::MassTransferTransactionData* mass_transfer) {
  clear_data();
  if (mass_transfer) {
    set_has_mass_transfer();
    _impl_.data_.mass_transfer_ = mass_transfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.mass_transfer)
}
inline ::vrp::MassTransferTransactionData* Transaction::_internal_mutable_mass_transfer() {
  if (!_internal_has_mass_transfer()) {
    clear_data();
    set_has_mass_transfer();
    _impl_.data_.mass_transfer_ = CreateMaybeMessage< ::vrp::MassTransferTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.mass_transfer_;
}
inline ::vrp::MassTransferTransactionData* Transaction::mutable_mass_transfer() {
  ::vrp::MassTransferTransactionData* _msg = _internal_mutable_mass_transfer();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.mass_transfer)
  return _msg;
}

// .vrp.DataTransactionData data_transaction = 112;
inline bool Transaction::_internal_has_data_transaction() const {
  return data_case() == kDataTransaction;
}
inline bool Transaction::has_data_transaction() const {
  return _internal_has_data_transaction();
}
inline void Transaction::set_has_data_transaction() {
  _impl_._oneof_case_[0] = kDataTransaction;
}
inline void Transaction::clear_data_transaction() {
  if (_internal_has_data_transaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.data_transaction_;
    }
    clear_has_data();
  }
}
inline ::vrp::DataTransactionData* Transaction::release_data_transaction() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.data_transaction)
  if (_internal_has_data_transaction()) {
    clear_has_data();
    ::vrp::DataTransactionData* temp = _impl_.data_.data_transaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.data_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::DataTransactionData& Transaction::_internal_data_transaction() const {
  return _internal_has_data_transaction()
      ? *_impl_.data_.data_transaction_
      : reinterpret_cast< ::vrp::DataTransactionData&>(::vrp::_DataTransactionData_default_instance_);
}
inline const ::vrp::DataTransactionData& Transaction::data_transaction() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.data_transaction)
  return _internal_data_transaction();
}
inline ::vrp::DataTransactionData* Transaction::unsafe_arena_release_data_transaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.data_transaction)
  if (_internal_has_data_transaction()) {
    clear_has_data();
    ::vrp::DataTransactionData* temp = _impl_.data_.data_transaction_;
    _impl_.data_.data_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_data_transaction(::vrp::DataTransactionData* data_transaction) {
  clear_data();
  if (data_transaction) {
    set_has_data_transaction();
    _impl_.data_.data_transaction_ = data_transaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.data_transaction)
}
inline ::vrp::DataTransactionData* Transaction::_internal_mutable_data_transaction() {
  if (!_internal_has_data_transaction()) {
    clear_data();
    set_has_data_transaction();
    _impl_.data_.data_transaction_ = CreateMaybeMessage< ::vrp::DataTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.data_transaction_;
}
inline ::vrp::DataTransactionData* Transaction::mutable_data_transaction() {
  ::vrp::DataTransactionData* _msg = _internal_mutable_data_transaction();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.data_transaction)
  return _msg;
}

// .vrp.SetScriptTransactionData set_script = 113;
inline bool Transaction::_internal_has_set_script() const {
  return data_case() == kSetScript;
}
inline bool Transaction::has_set_script() const {
  return _internal_has_set_script();
}
inline void Transaction::set_has_set_script() {
  _impl_._oneof_case_[0] = kSetScript;
}
inline void Transaction::clear_set_script() {
  if (_internal_has_set_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.set_script_;
    }
    clear_has_data();
  }
}
inline ::vrp::SetScriptTransactionData* Transaction::release_set_script() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.set_script)
  if (_internal_has_set_script()) {
    clear_has_data();
    ::vrp::SetScriptTransactionData* temp = _impl_.data_.set_script_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.set_script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::SetScriptTransactionData& Transaction::_internal_set_script() const {
  return _internal_has_set_script()
      ? *_impl_.data_.set_script_
      : reinterpret_cast< ::vrp::SetScriptTransactionData&>(::vrp::_SetScriptTransactionData_default_instance_);
}
inline const ::vrp::SetScriptTransactionData& Transaction::set_script() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.set_script)
  return _internal_set_script();
}
inline ::vrp::SetScriptTransactionData* Transaction::unsafe_arena_release_set_script() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.set_script)
  if (_internal_has_set_script()) {
    clear_has_data();
    ::vrp::SetScriptTransactionData* temp = _impl_.data_.set_script_;
    _impl_.data_.set_script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_set_script(::vrp::SetScriptTransactionData* set_script) {
  clear_data();
  if (set_script) {
    set_has_set_script();
    _impl_.data_.set_script_ = set_script;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.set_script)
}
inline ::vrp::SetScriptTransactionData* Transaction::_internal_mutable_set_script() {
  if (!_internal_has_set_script()) {
    clear_data();
    set_has_set_script();
    _impl_.data_.set_script_ = CreateMaybeMessage< ::vrp::SetScriptTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.set_script_;
}
inline ::vrp::SetScriptTransactionData* Transaction::mutable_set_script() {
  ::vrp::SetScriptTransactionData* _msg = _internal_mutable_set_script();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.set_script)
  return _msg;
}

// .vrp.SponsorFeeTransactionData sponsor_fee = 114;
inline bool Transaction::_internal_has_sponsor_fee() const {
  return data_case() == kSponsorFee;
}
inline bool Transaction::has_sponsor_fee() const {
  return _internal_has_sponsor_fee();
}
inline void Transaction::set_has_sponsor_fee() {
  _impl_._oneof_case_[0] = kSponsorFee;
}
inline void Transaction::clear_sponsor_fee() {
  if (_internal_has_sponsor_fee()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.sponsor_fee_;
    }
    clear_has_data();
  }
}
inline ::vrp::SponsorFeeTransactionData* Transaction::release_sponsor_fee() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.sponsor_fee)
  if (_internal_has_sponsor_fee()) {
    clear_has_data();
    ::vrp::SponsorFeeTransactionData* temp = _impl_.data_.sponsor_fee_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.sponsor_fee_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::SponsorFeeTransactionData& Transaction::_internal_sponsor_fee() const {
  return _internal_has_sponsor_fee()
      ? *_impl_.data_.sponsor_fee_
      : reinterpret_cast< ::vrp::SponsorFeeTransactionData&>(::vrp::_SponsorFeeTransactionData_default_instance_);
}
inline const ::vrp::SponsorFeeTransactionData& Transaction::sponsor_fee() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.sponsor_fee)
  return _internal_sponsor_fee();
}
inline ::vrp::SponsorFeeTransactionData* Transaction::unsafe_arena_release_sponsor_fee() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.sponsor_fee)
  if (_internal_has_sponsor_fee()) {
    clear_has_data();
    ::vrp::SponsorFeeTransactionData* temp = _impl_.data_.sponsor_fee_;
    _impl_.data_.sponsor_fee_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_sponsor_fee(::vrp::SponsorFeeTransactionData* sponsor_fee) {
  clear_data();
  if (sponsor_fee) {
    set_has_sponsor_fee();
    _impl_.data_.sponsor_fee_ = sponsor_fee;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.sponsor_fee)
}
inline ::vrp::SponsorFeeTransactionData* Transaction::_internal_mutable_sponsor_fee() {
  if (!_internal_has_sponsor_fee()) {
    clear_data();
    set_has_sponsor_fee();
    _impl_.data_.sponsor_fee_ = CreateMaybeMessage< ::vrp::SponsorFeeTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.sponsor_fee_;
}
inline ::vrp::SponsorFeeTransactionData* Transaction::mutable_sponsor_fee() {
  ::vrp::SponsorFeeTransactionData* _msg = _internal_mutable_sponsor_fee();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.sponsor_fee)
  return _msg;
}

// .vrp.SetAssetScriptTransactionData set_asset_script = 115;
inline bool Transaction::_internal_has_set_asset_script() const {
  return data_case() == kSetAssetScript;
}
inline bool Transaction::has_set_asset_script() const {
  return _internal_has_set_asset_script();
}
inline void Transaction::set_has_set_asset_script() {
  _impl_._oneof_case_[0] = kSetAssetScript;
}
inline void Transaction::clear_set_asset_script() {
  if (_internal_has_set_asset_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.set_asset_script_;
    }
    clear_has_data();
  }
}
inline ::vrp::SetAssetScriptTransactionData* Transaction::release_set_asset_script() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.set_asset_script)
  if (_internal_has_set_asset_script()) {
    clear_has_data();
    ::vrp::SetAssetScriptTransactionData* temp = _impl_.data_.set_asset_script_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.set_asset_script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::SetAssetScriptTransactionData& Transaction::_internal_set_asset_script() const {
  return _internal_has_set_asset_script()
      ? *_impl_.data_.set_asset_script_
      : reinterpret_cast< ::vrp::SetAssetScriptTransactionData&>(::vrp::_SetAssetScriptTransactionData_default_instance_);
}
inline const ::vrp::SetAssetScriptTransactionData& Transaction::set_asset_script() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.set_asset_script)
  return _internal_set_asset_script();
}
inline ::vrp::SetAssetScriptTransactionData* Transaction::unsafe_arena_release_set_asset_script() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.set_asset_script)
  if (_internal_has_set_asset_script()) {
    clear_has_data();
    ::vrp::SetAssetScriptTransactionData* temp = _impl_.data_.set_asset_script_;
    _impl_.data_.set_asset_script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_set_asset_script(::vrp::SetAssetScriptTransactionData* set_asset_script) {
  clear_data();
  if (set_asset_script) {
    set_has_set_asset_script();
    _impl_.data_.set_asset_script_ = set_asset_script;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.set_asset_script)
}
inline ::vrp::SetAssetScriptTransactionData* Transaction::_internal_mutable_set_asset_script() {
  if (!_internal_has_set_asset_script()) {
    clear_data();
    set_has_set_asset_script();
    _impl_.data_.set_asset_script_ = CreateMaybeMessage< ::vrp::SetAssetScriptTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.set_asset_script_;
}
inline ::vrp::SetAssetScriptTransactionData* Transaction::mutable_set_asset_script() {
  ::vrp::SetAssetScriptTransactionData* _msg = _internal_mutable_set_asset_script();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.set_asset_script)
  return _msg;
}

// .vrp.InvokeScriptTransactionData invoke_script = 116;
inline bool Transaction::_internal_has_invoke_script() const {
  return data_case() == kInvokeScript;
}
inline bool Transaction::has_invoke_script() const {
  return _internal_has_invoke_script();
}
inline void Transaction::set_has_invoke_script() {
  _impl_._oneof_case_[0] = kInvokeScript;
}
inline void Transaction::clear_invoke_script() {
  if (_internal_has_invoke_script()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.invoke_script_;
    }
    clear_has_data();
  }
}
inline ::vrp::InvokeScriptTransactionData* Transaction::release_invoke_script() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.invoke_script)
  if (_internal_has_invoke_script()) {
    clear_has_data();
    ::vrp::InvokeScriptTransactionData* temp = _impl_.data_.invoke_script_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.invoke_script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::InvokeScriptTransactionData& Transaction::_internal_invoke_script() const {
  return _internal_has_invoke_script()
      ? *_impl_.data_.invoke_script_
      : reinterpret_cast< ::vrp::InvokeScriptTransactionData&>(::vrp::_InvokeScriptTransactionData_default_instance_);
}
inline const ::vrp::InvokeScriptTransactionData& Transaction::invoke_script() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.invoke_script)
  return _internal_invoke_script();
}
inline ::vrp::InvokeScriptTransactionData* Transaction::unsafe_arena_release_invoke_script() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.invoke_script)
  if (_internal_has_invoke_script()) {
    clear_has_data();
    ::vrp::InvokeScriptTransactionData* temp = _impl_.data_.invoke_script_;
    _impl_.data_.invoke_script_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_invoke_script(::vrp::InvokeScriptTransactionData* invoke_script) {
  clear_data();
  if (invoke_script) {
    set_has_invoke_script();
    _impl_.data_.invoke_script_ = invoke_script;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.invoke_script)
}
inline ::vrp::InvokeScriptTransactionData* Transaction::_internal_mutable_invoke_script() {
  if (!_internal_has_invoke_script()) {
    clear_data();
    set_has_invoke_script();
    _impl_.data_.invoke_script_ = CreateMaybeMessage< ::vrp::InvokeScriptTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.invoke_script_;
}
inline ::vrp::InvokeScriptTransactionData* Transaction::mutable_invoke_script() {
  ::vrp::InvokeScriptTransactionData* _msg = _internal_mutable_invoke_script();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.invoke_script)
  return _msg;
}

// .vrp.UpdateAssetInfoTransactionData update_asset_info = 117;
inline bool Transaction::_internal_has_update_asset_info() const {
  return data_case() == kUpdateAssetInfo;
}
inline bool Transaction::has_update_asset_info() const {
  return _internal_has_update_asset_info();
}
inline void Transaction::set_has_update_asset_info() {
  _impl_._oneof_case_[0] = kUpdateAssetInfo;
}
inline void Transaction::clear_update_asset_info() {
  if (_internal_has_update_asset_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.update_asset_info_;
    }
    clear_has_data();
  }
}
inline ::vrp::UpdateAssetInfoTransactionData* Transaction::release_update_asset_info() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.update_asset_info)
  if (_internal_has_update_asset_info()) {
    clear_has_data();
    ::vrp::UpdateAssetInfoTransactionData* temp = _impl_.data_.update_asset_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.update_asset_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::UpdateAssetInfoTransactionData& Transaction::_internal_update_asset_info() const {
  return _internal_has_update_asset_info()
      ? *_impl_.data_.update_asset_info_
      : reinterpret_cast< ::vrp::UpdateAssetInfoTransactionData&>(::vrp::_UpdateAssetInfoTransactionData_default_instance_);
}
inline const ::vrp::UpdateAssetInfoTransactionData& Transaction::update_asset_info() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.update_asset_info)
  return _internal_update_asset_info();
}
inline ::vrp::UpdateAssetInfoTransactionData* Transaction::unsafe_arena_release_update_asset_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.update_asset_info)
  if (_internal_has_update_asset_info()) {
    clear_has_data();
    ::vrp::UpdateAssetInfoTransactionData* temp = _impl_.data_.update_asset_info_;
    _impl_.data_.update_asset_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_update_asset_info(::vrp::UpdateAssetInfoTransactionData* update_asset_info) {
  clear_data();
  if (update_asset_info) {
    set_has_update_asset_info();
    _impl_.data_.update_asset_info_ = update_asset_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.update_asset_info)
}
inline ::vrp::UpdateAssetInfoTransactionData* Transaction::_internal_mutable_update_asset_info() {
  if (!_internal_has_update_asset_info()) {
    clear_data();
    set_has_update_asset_info();
    _impl_.data_.update_asset_info_ = CreateMaybeMessage< ::vrp::UpdateAssetInfoTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.update_asset_info_;
}
inline ::vrp::UpdateAssetInfoTransactionData* Transaction::mutable_update_asset_info() {
  ::vrp::UpdateAssetInfoTransactionData* _msg = _internal_mutable_update_asset_info();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.update_asset_info)
  return _msg;
}

// .vrp.PrivatePaymentTransactionData anonymous_tx = 118;
inline bool Transaction::_internal_has_anonymous_tx() const {
  return data_case() == kAnonymousTx;
}
inline bool Transaction::has_anonymous_tx() const {
  return _internal_has_anonymous_tx();
}
inline void Transaction::set_has_anonymous_tx() {
  _impl_._oneof_case_[0] = kAnonymousTx;
}
inline void Transaction::clear_anonymous_tx() {
  if (_internal_has_anonymous_tx()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.anonymous_tx_;
    }
    clear_has_data();
  }
}
inline ::vrp::PrivatePaymentTransactionData* Transaction::release_anonymous_tx() {
  // @@protoc_insertion_point(field_release:vrp.Transaction.anonymous_tx)
  if (_internal_has_anonymous_tx()) {
    clear_has_data();
    ::vrp::PrivatePaymentTransactionData* temp = _impl_.data_.anonymous_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.anonymous_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::PrivatePaymentTransactionData& Transaction::_internal_anonymous_tx() const {
  return _internal_has_anonymous_tx()
      ? *_impl_.data_.anonymous_tx_
      : reinterpret_cast< ::vrp::PrivatePaymentTransactionData&>(::vrp::_PrivatePaymentTransactionData_default_instance_);
}
inline const ::vrp::PrivatePaymentTransactionData& Transaction::anonymous_tx() const {
  // @@protoc_insertion_point(field_get:vrp.Transaction.anonymous_tx)
  return _internal_anonymous_tx();
}
inline ::vrp::PrivatePaymentTransactionData* Transaction::unsafe_arena_release_anonymous_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.Transaction.anonymous_tx)
  if (_internal_has_anonymous_tx()) {
    clear_has_data();
    ::vrp::PrivatePaymentTransactionData* temp = _impl_.data_.anonymous_tx_;
    _impl_.data_.anonymous_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_anonymous_tx(::vrp::PrivatePaymentTransactionData* anonymous_tx) {
  clear_data();
  if (anonymous_tx) {
    set_has_anonymous_tx();
    _impl_.data_.anonymous_tx_ = anonymous_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.Transaction.anonymous_tx)
}
inline ::vrp::PrivatePaymentTransactionData* Transaction::_internal_mutable_anonymous_tx() {
  if (!_internal_has_anonymous_tx()) {
    clear_data();
    set_has_anonymous_tx();
    _impl_.data_.anonymous_tx_ = CreateMaybeMessage< ::vrp::PrivatePaymentTransactionData >(GetArenaForAllocation());
  }
  return _impl_.data_.anonymous_tx_;
}
inline ::vrp::PrivatePaymentTransactionData* Transaction::mutable_anonymous_tx() {
  ::vrp::PrivatePaymentTransactionData* _msg = _internal_mutable_anonymous_tx();
  // @@protoc_insertion_point(field_mutable:vrp.Transaction.anonymous_tx)
  return _msg;
}

inline bool Transaction::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Transaction::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline Transaction::DataCase Transaction::data_case() const {
  return Transaction::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GenesisTransactionData

// bytes recipient_address = 1;
inline void GenesisTransactionData::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& GenesisTransactionData::recipient_address() const {
  // @@protoc_insertion_point(field_get:vrp.GenesisTransactionData.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenesisTransactionData::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.GenesisTransactionData.recipient_address)
}
inline std::string* GenesisTransactionData::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:vrp.GenesisTransactionData.recipient_address)
  return _s;
}
inline const std::string& GenesisTransactionData::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void GenesisTransactionData::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* GenesisTransactionData::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* GenesisTransactionData::release_recipient_address() {
  // @@protoc_insertion_point(field_release:vrp.GenesisTransactionData.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void GenesisTransactionData::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.GenesisTransactionData.recipient_address)
}

// int64 amount = 2;
inline void GenesisTransactionData::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t GenesisTransactionData::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t GenesisTransactionData::amount() const {
  // @@protoc_insertion_point(field_get:vrp.GenesisTransactionData.amount)
  return _internal_amount();
}
inline void GenesisTransactionData::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void GenesisTransactionData::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.GenesisTransactionData.amount)
}

// -------------------------------------------------------------------

// PaymentTransactionData

// bytes recipient_address = 1;
inline void PaymentTransactionData::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& PaymentTransactionData::recipient_address() const {
  // @@protoc_insertion_point(field_get:vrp.PaymentTransactionData.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentTransactionData::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.PaymentTransactionData.recipient_address)
}
inline std::string* PaymentTransactionData::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:vrp.PaymentTransactionData.recipient_address)
  return _s;
}
inline const std::string& PaymentTransactionData::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void PaymentTransactionData::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentTransactionData::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentTransactionData::release_recipient_address() {
  // @@protoc_insertion_point(field_release:vrp.PaymentTransactionData.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void PaymentTransactionData::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.PaymentTransactionData.recipient_address)
}

// int64 amount = 2;
inline void PaymentTransactionData::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t PaymentTransactionData::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t PaymentTransactionData::amount() const {
  // @@protoc_insertion_point(field_get:vrp.PaymentTransactionData.amount)
  return _internal_amount();
}
inline void PaymentTransactionData::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void PaymentTransactionData::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.PaymentTransactionData.amount)
}

// -------------------------------------------------------------------

// TransferTransactionData

// .vrp.Recipient recipient = 1;
inline bool TransferTransactionData::_internal_has_recipient() const {
  return this != internal_default_instance() && _impl_.recipient_ != nullptr;
}
inline bool TransferTransactionData::has_recipient() const {
  return _internal_has_recipient();
}
inline const ::vrp::Recipient& TransferTransactionData::_internal_recipient() const {
  const ::vrp::Recipient* p = _impl_.recipient_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Recipient&>(
      ::vrp::_Recipient_default_instance_);
}
inline const ::vrp::Recipient& TransferTransactionData::recipient() const {
  // @@protoc_insertion_point(field_get:vrp.TransferTransactionData.recipient)
  return _internal_recipient();
}
inline void TransferTransactionData::unsafe_arena_set_allocated_recipient(
    ::vrp::Recipient* recipient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  _impl_.recipient_ = recipient;
  if (recipient) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.TransferTransactionData.recipient)
}
inline ::vrp::Recipient* TransferTransactionData::release_recipient() {
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Recipient* TransferTransactionData::unsafe_arena_release_recipient() {
  // @@protoc_insertion_point(field_release:vrp.TransferTransactionData.recipient)
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
  return temp;
}
inline ::vrp::Recipient* TransferTransactionData::_internal_mutable_recipient() {
  
  if (_impl_.recipient_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Recipient>(GetArenaForAllocation());
    _impl_.recipient_ = p;
  }
  return _impl_.recipient_;
}
inline ::vrp::Recipient* TransferTransactionData::mutable_recipient() {
  ::vrp::Recipient* _msg = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:vrp.TransferTransactionData.recipient)
  return _msg;
}
inline void TransferTransactionData::set_allocated_recipient(::vrp::Recipient* recipient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  if (recipient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recipient));
    if (message_arena != submessage_arena) {
      recipient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recipient, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recipient_ = recipient;
  // @@protoc_insertion_point(field_set_allocated:vrp.TransferTransactionData.recipient)
}

// .vrp.Amount amount = 2;
inline bool TransferTransactionData::_internal_has_amount() const {
  return this != internal_default_instance() && _impl_.amount_ != nullptr;
}
inline bool TransferTransactionData::has_amount() const {
  return _internal_has_amount();
}
inline const ::vrp::Amount& TransferTransactionData::_internal_amount() const {
  const ::vrp::Amount* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& TransferTransactionData::amount() const {
  // @@protoc_insertion_point(field_get:vrp.TransferTransactionData.amount)
  return _internal_amount();
}
inline void TransferTransactionData::unsafe_arena_set_allocated_amount(
    ::vrp::Amount* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.TransferTransactionData.amount)
}
inline ::vrp::Amount* TransferTransactionData::release_amount() {
  
  ::vrp::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* TransferTransactionData::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:vrp.TransferTransactionData.amount)
  
  ::vrp::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::vrp::Amount* TransferTransactionData::_internal_mutable_amount() {
  
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::vrp::Amount* TransferTransactionData::mutable_amount() {
  ::vrp::Amount* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:vrp.TransferTransactionData.amount)
  return _msg;
}
inline void TransferTransactionData::set_allocated_amount(::vrp::Amount* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:vrp.TransferTransactionData.amount)
}

// bytes attachment = 3;
inline void TransferTransactionData::clear_attachment() {
  _impl_.attachment_.ClearToEmpty();
}
inline const std::string& TransferTransactionData::attachment() const {
  // @@protoc_insertion_point(field_get:vrp.TransferTransactionData.attachment)
  return _internal_attachment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferTransactionData::set_attachment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attachment_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.TransferTransactionData.attachment)
}
inline std::string* TransferTransactionData::mutable_attachment() {
  std::string* _s = _internal_mutable_attachment();
  // @@protoc_insertion_point(field_mutable:vrp.TransferTransactionData.attachment)
  return _s;
}
inline const std::string& TransferTransactionData::_internal_attachment() const {
  return _impl_.attachment_.Get();
}
inline void TransferTransactionData::_internal_set_attachment(const std::string& value) {
  
  _impl_.attachment_.Set(value, GetArenaForAllocation());
}
inline std::string* TransferTransactionData::_internal_mutable_attachment() {
  
  return _impl_.attachment_.Mutable(GetArenaForAllocation());
}
inline std::string* TransferTransactionData::release_attachment() {
  // @@protoc_insertion_point(field_release:vrp.TransferTransactionData.attachment)
  return _impl_.attachment_.Release();
}
inline void TransferTransactionData::set_allocated_attachment(std::string* attachment) {
  if (attachment != nullptr) {
    
  } else {
    
  }
  _impl_.attachment_.SetAllocated(attachment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachment_.IsDefault()) {
    _impl_.attachment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.TransferTransactionData.attachment)
}

// -------------------------------------------------------------------

// CreateAliasTransactionData

// string alias = 1;
inline void CreateAliasTransactionData::clear_alias() {
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& CreateAliasTransactionData::alias() const {
  // @@protoc_insertion_point(field_get:vrp.CreateAliasTransactionData.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAliasTransactionData::set_alias(ArgT0&& arg0, ArgT... args) {
 
 _impl_.alias_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.CreateAliasTransactionData.alias)
}
inline std::string* CreateAliasTransactionData::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:vrp.CreateAliasTransactionData.alias)
  return _s;
}
inline const std::string& CreateAliasTransactionData::_internal_alias() const {
  return _impl_.alias_.Get();
}
inline void CreateAliasTransactionData::_internal_set_alias(const std::string& value) {
  
  _impl_.alias_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAliasTransactionData::_internal_mutable_alias() {
  
  return _impl_.alias_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAliasTransactionData::release_alias() {
  // @@protoc_insertion_point(field_release:vrp.CreateAliasTransactionData.alias)
  return _impl_.alias_.Release();
}
inline void CreateAliasTransactionData::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    
  } else {
    
  }
  _impl_.alias_.SetAllocated(alias, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.CreateAliasTransactionData.alias)
}

// -------------------------------------------------------------------

// DataTransactionData_DataEntry

// string key = 1;
inline void DataTransactionData_DataEntry::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DataTransactionData_DataEntry::key() const {
  // @@protoc_insertion_point(field_get:vrp.DataTransactionData.DataEntry.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataTransactionData_DataEntry::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.DataTransactionData.DataEntry.key)
}
inline std::string* DataTransactionData_DataEntry::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:vrp.DataTransactionData.DataEntry.key)
  return _s;
}
inline const std::string& DataTransactionData_DataEntry::_internal_key() const {
  return _impl_.key_.Get();
}
inline void DataTransactionData_DataEntry::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* DataTransactionData_DataEntry::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* DataTransactionData_DataEntry::release_key() {
  // @@protoc_insertion_point(field_release:vrp.DataTransactionData.DataEntry.key)
  return _impl_.key_.Release();
}
inline void DataTransactionData_DataEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.DataTransactionData.DataEntry.key)
}

// int64 int_value = 10;
inline bool DataTransactionData_DataEntry::_internal_has_int_value() const {
  return value_case() == kIntValue;
}
inline bool DataTransactionData_DataEntry::has_int_value() const {
  return _internal_has_int_value();
}
inline void DataTransactionData_DataEntry::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void DataTransactionData_DataEntry::clear_int_value() {
  if (_internal_has_int_value()) {
    _impl_.value_.int_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t DataTransactionData_DataEntry::_internal_int_value() const {
  if (_internal_has_int_value()) {
    return _impl_.value_.int_value_;
  }
  return int64_t{0};
}
inline void DataTransactionData_DataEntry::_internal_set_int_value(int64_t value) {
  if (!_internal_has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  _impl_.value_.int_value_ = value;
}
inline int64_t DataTransactionData_DataEntry::int_value() const {
  // @@protoc_insertion_point(field_get:vrp.DataTransactionData.DataEntry.int_value)
  return _internal_int_value();
}
inline void DataTransactionData_DataEntry::set_int_value(int64_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:vrp.DataTransactionData.DataEntry.int_value)
}

// bool bool_value = 11;
inline bool DataTransactionData_DataEntry::_internal_has_bool_value() const {
  return value_case() == kBoolValue;
}
inline bool DataTransactionData_DataEntry::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void DataTransactionData_DataEntry::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void DataTransactionData_DataEntry::clear_bool_value() {
  if (_internal_has_bool_value()) {
    _impl_.value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool DataTransactionData_DataEntry::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return _impl_.value_.bool_value_;
  }
  return false;
}
inline void DataTransactionData_DataEntry::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  _impl_.value_.bool_value_ = value;
}
inline bool DataTransactionData_DataEntry::bool_value() const {
  // @@protoc_insertion_point(field_get:vrp.DataTransactionData.DataEntry.bool_value)
  return _internal_bool_value();
}
inline void DataTransactionData_DataEntry::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:vrp.DataTransactionData.DataEntry.bool_value)
}

// bytes binary_value = 12;
inline bool DataTransactionData_DataEntry::_internal_has_binary_value() const {
  return value_case() == kBinaryValue;
}
inline bool DataTransactionData_DataEntry::has_binary_value() const {
  return _internal_has_binary_value();
}
inline void DataTransactionData_DataEntry::set_has_binary_value() {
  _impl_._oneof_case_[0] = kBinaryValue;
}
inline void DataTransactionData_DataEntry::clear_binary_value() {
  if (_internal_has_binary_value()) {
    _impl_.value_.binary_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& DataTransactionData_DataEntry::binary_value() const {
  // @@protoc_insertion_point(field_get:vrp.DataTransactionData.DataEntry.binary_value)
  return _internal_binary_value();
}
template <typename ArgT0, typename... ArgT>
inline void DataTransactionData_DataEntry::set_binary_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary_value()) {
    clear_value();
    set_has_binary_value();
    _impl_.value_.binary_value_.InitDefault();
  }
  _impl_.value_.binary_value_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.DataTransactionData.DataEntry.binary_value)
}
inline std::string* DataTransactionData_DataEntry::mutable_binary_value() {
  std::string* _s = _internal_mutable_binary_value();
  // @@protoc_insertion_point(field_mutable:vrp.DataTransactionData.DataEntry.binary_value)
  return _s;
}
inline const std::string& DataTransactionData_DataEntry::_internal_binary_value() const {
  if (_internal_has_binary_value()) {
    return _impl_.value_.binary_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataTransactionData_DataEntry::_internal_set_binary_value(const std::string& value) {
  if (!_internal_has_binary_value()) {
    clear_value();
    set_has_binary_value();
    _impl_.value_.binary_value_.InitDefault();
  }
  _impl_.value_.binary_value_.Set(value, GetArenaForAllocation());
}
inline std::string* DataTransactionData_DataEntry::_internal_mutable_binary_value() {
  if (!_internal_has_binary_value()) {
    clear_value();
    set_has_binary_value();
    _impl_.value_.binary_value_.InitDefault();
  }
  return _impl_.value_.binary_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataTransactionData_DataEntry::release_binary_value() {
  // @@protoc_insertion_point(field_release:vrp.DataTransactionData.DataEntry.binary_value)
  if (_internal_has_binary_value()) {
    clear_has_value();
    return _impl_.value_.binary_value_.Release();
  } else {
    return nullptr;
  }
}
inline void DataTransactionData_DataEntry::set_allocated_binary_value(std::string* binary_value) {
  if (has_value()) {
    clear_value();
  }
  if (binary_value != nullptr) {
    set_has_binary_value();
    _impl_.value_.binary_value_.InitAllocated(binary_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.DataTransactionData.DataEntry.binary_value)
}

// string string_value = 13;
inline bool DataTransactionData_DataEntry::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool DataTransactionData_DataEntry::has_string_value() const {
  return _internal_has_string_value();
}
inline void DataTransactionData_DataEntry::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void DataTransactionData_DataEntry::clear_string_value() {
  if (_internal_has_string_value()) {
    _impl_.value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& DataTransactionData_DataEntry::string_value() const {
  // @@protoc_insertion_point(field_get:vrp.DataTransactionData.DataEntry.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void DataTransactionData_DataEntry::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.DataTransactionData.DataEntry.string_value)
}
inline std::string* DataTransactionData_DataEntry::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:vrp.DataTransactionData.DataEntry.string_value)
  return _s;
}
inline const std::string& DataTransactionData_DataEntry::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return _impl_.value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataTransactionData_DataEntry::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* DataTransactionData_DataEntry::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  return _impl_.value_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataTransactionData_DataEntry::release_string_value() {
  // @@protoc_insertion_point(field_release:vrp.DataTransactionData.DataEntry.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return _impl_.value_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void DataTransactionData_DataEntry::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    _impl_.value_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.DataTransactionData.DataEntry.string_value)
}

inline bool DataTransactionData_DataEntry::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataTransactionData_DataEntry::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline DataTransactionData_DataEntry::ValueCase DataTransactionData_DataEntry::value_case() const {
  return DataTransactionData_DataEntry::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataTransactionData

// repeated .vrp.DataTransactionData.DataEntry data = 1;
inline int DataTransactionData::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int DataTransactionData::data_size() const {
  return _internal_data_size();
}
inline void DataTransactionData::clear_data() {
  _impl_.data_.Clear();
}
inline ::vrp::DataTransactionData_DataEntry* DataTransactionData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.DataTransactionData.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >*
DataTransactionData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vrp.DataTransactionData.data)
  return &_impl_.data_;
}
inline const ::vrp::DataTransactionData_DataEntry& DataTransactionData::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::vrp::DataTransactionData_DataEntry& DataTransactionData::data(int index) const {
  // @@protoc_insertion_point(field_get:vrp.DataTransactionData.data)
  return _internal_data(index);
}
inline ::vrp::DataTransactionData_DataEntry* DataTransactionData::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::vrp::DataTransactionData_DataEntry* DataTransactionData::add_data() {
  ::vrp::DataTransactionData_DataEntry* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:vrp.DataTransactionData.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >&
DataTransactionData::data() const {
  // @@protoc_insertion_point(field_list:vrp.DataTransactionData.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// MassTransferTransactionData_Transfer

// .vrp.Recipient recipient = 1;
inline bool MassTransferTransactionData_Transfer::_internal_has_recipient() const {
  return this != internal_default_instance() && _impl_.recipient_ != nullptr;
}
inline bool MassTransferTransactionData_Transfer::has_recipient() const {
  return _internal_has_recipient();
}
inline const ::vrp::Recipient& MassTransferTransactionData_Transfer::_internal_recipient() const {
  const ::vrp::Recipient* p = _impl_.recipient_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Recipient&>(
      ::vrp::_Recipient_default_instance_);
}
inline const ::vrp::Recipient& MassTransferTransactionData_Transfer::recipient() const {
  // @@protoc_insertion_point(field_get:vrp.MassTransferTransactionData.Transfer.recipient)
  return _internal_recipient();
}
inline void MassTransferTransactionData_Transfer::unsafe_arena_set_allocated_recipient(
    ::vrp::Recipient* recipient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  _impl_.recipient_ = recipient;
  if (recipient) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.MassTransferTransactionData.Transfer.recipient)
}
inline ::vrp::Recipient* MassTransferTransactionData_Transfer::release_recipient() {
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Recipient* MassTransferTransactionData_Transfer::unsafe_arena_release_recipient() {
  // @@protoc_insertion_point(field_release:vrp.MassTransferTransactionData.Transfer.recipient)
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
  return temp;
}
inline ::vrp::Recipient* MassTransferTransactionData_Transfer::_internal_mutable_recipient() {
  
  if (_impl_.recipient_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Recipient>(GetArenaForAllocation());
    _impl_.recipient_ = p;
  }
  return _impl_.recipient_;
}
inline ::vrp::Recipient* MassTransferTransactionData_Transfer::mutable_recipient() {
  ::vrp::Recipient* _msg = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:vrp.MassTransferTransactionData.Transfer.recipient)
  return _msg;
}
inline void MassTransferTransactionData_Transfer::set_allocated_recipient(::vrp::Recipient* recipient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  if (recipient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recipient));
    if (message_arena != submessage_arena) {
      recipient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recipient, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recipient_ = recipient;
  // @@protoc_insertion_point(field_set_allocated:vrp.MassTransferTransactionData.Transfer.recipient)
}

// int64 amount = 2;
inline void MassTransferTransactionData_Transfer::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t MassTransferTransactionData_Transfer::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t MassTransferTransactionData_Transfer::amount() const {
  // @@protoc_insertion_point(field_get:vrp.MassTransferTransactionData.Transfer.amount)
  return _internal_amount();
}
inline void MassTransferTransactionData_Transfer::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void MassTransferTransactionData_Transfer::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.MassTransferTransactionData.Transfer.amount)
}

// -------------------------------------------------------------------

// MassTransferTransactionData

// bytes asset_id = 1;
inline void MassTransferTransactionData::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& MassTransferTransactionData::asset_id() const {
  // @@protoc_insertion_point(field_get:vrp.MassTransferTransactionData.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MassTransferTransactionData::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.MassTransferTransactionData.asset_id)
}
inline std::string* MassTransferTransactionData::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:vrp.MassTransferTransactionData.asset_id)
  return _s;
}
inline const std::string& MassTransferTransactionData::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void MassTransferTransactionData::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MassTransferTransactionData::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MassTransferTransactionData::release_asset_id() {
  // @@protoc_insertion_point(field_release:vrp.MassTransferTransactionData.asset_id)
  return _impl_.asset_id_.Release();
}
inline void MassTransferTransactionData::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.MassTransferTransactionData.asset_id)
}

// repeated .vrp.MassTransferTransactionData.Transfer transfers = 2;
inline int MassTransferTransactionData::_internal_transfers_size() const {
  return _impl_.transfers_.size();
}
inline int MassTransferTransactionData::transfers_size() const {
  return _internal_transfers_size();
}
inline void MassTransferTransactionData::clear_transfers() {
  _impl_.transfers_.Clear();
}
inline ::vrp::MassTransferTransactionData_Transfer* MassTransferTransactionData::mutable_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.MassTransferTransactionData.transfers)
  return _impl_.transfers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::MassTransferTransactionData_Transfer >*
MassTransferTransactionData::mutable_transfers() {
  // @@protoc_insertion_point(field_mutable_list:vrp.MassTransferTransactionData.transfers)
  return &_impl_.transfers_;
}
inline const ::vrp::MassTransferTransactionData_Transfer& MassTransferTransactionData::_internal_transfers(int index) const {
  return _impl_.transfers_.Get(index);
}
inline const ::vrp::MassTransferTransactionData_Transfer& MassTransferTransactionData::transfers(int index) const {
  // @@protoc_insertion_point(field_get:vrp.MassTransferTransactionData.transfers)
  return _internal_transfers(index);
}
inline ::vrp::MassTransferTransactionData_Transfer* MassTransferTransactionData::_internal_add_transfers() {
  return _impl_.transfers_.Add();
}
inline ::vrp::MassTransferTransactionData_Transfer* MassTransferTransactionData::add_transfers() {
  ::vrp::MassTransferTransactionData_Transfer* _add = _internal_add_transfers();
  // @@protoc_insertion_point(field_add:vrp.MassTransferTransactionData.transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::MassTransferTransactionData_Transfer >&
MassTransferTransactionData::transfers() const {
  // @@protoc_insertion_point(field_list:vrp.MassTransferTransactionData.transfers)
  return _impl_.transfers_;
}

// bytes attachment = 3;
inline void MassTransferTransactionData::clear_attachment() {
  _impl_.attachment_.ClearToEmpty();
}
inline const std::string& MassTransferTransactionData::attachment() const {
  // @@protoc_insertion_point(field_get:vrp.MassTransferTransactionData.attachment)
  return _internal_attachment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MassTransferTransactionData::set_attachment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attachment_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.MassTransferTransactionData.attachment)
}
inline std::string* MassTransferTransactionData::mutable_attachment() {
  std::string* _s = _internal_mutable_attachment();
  // @@protoc_insertion_point(field_mutable:vrp.MassTransferTransactionData.attachment)
  return _s;
}
inline const std::string& MassTransferTransactionData::_internal_attachment() const {
  return _impl_.attachment_.Get();
}
inline void MassTransferTransactionData::_internal_set_attachment(const std::string& value) {
  
  _impl_.attachment_.Set(value, GetArenaForAllocation());
}
inline std::string* MassTransferTransactionData::_internal_mutable_attachment() {
  
  return _impl_.attachment_.Mutable(GetArenaForAllocation());
}
inline std::string* MassTransferTransactionData::release_attachment() {
  // @@protoc_insertion_point(field_release:vrp.MassTransferTransactionData.attachment)
  return _impl_.attachment_.Release();
}
inline void MassTransferTransactionData::set_allocated_attachment(std::string* attachment) {
  if (attachment != nullptr) {
    
  } else {
    
  }
  _impl_.attachment_.SetAllocated(attachment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachment_.IsDefault()) {
    _impl_.attachment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.MassTransferTransactionData.attachment)
}

// -------------------------------------------------------------------

// LeaseTransactionData

// .vrp.Recipient recipient = 1;
inline bool LeaseTransactionData::_internal_has_recipient() const {
  return this != internal_default_instance() && _impl_.recipient_ != nullptr;
}
inline bool LeaseTransactionData::has_recipient() const {
  return _internal_has_recipient();
}
inline const ::vrp::Recipient& LeaseTransactionData::_internal_recipient() const {
  const ::vrp::Recipient* p = _impl_.recipient_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Recipient&>(
      ::vrp::_Recipient_default_instance_);
}
inline const ::vrp::Recipient& LeaseTransactionData::recipient() const {
  // @@protoc_insertion_point(field_get:vrp.LeaseTransactionData.recipient)
  return _internal_recipient();
}
inline void LeaseTransactionData::unsafe_arena_set_allocated_recipient(
    ::vrp::Recipient* recipient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  _impl_.recipient_ = recipient;
  if (recipient) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.LeaseTransactionData.recipient)
}
inline ::vrp::Recipient* LeaseTransactionData::release_recipient() {
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Recipient* LeaseTransactionData::unsafe_arena_release_recipient() {
  // @@protoc_insertion_point(field_release:vrp.LeaseTransactionData.recipient)
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
  return temp;
}
inline ::vrp::Recipient* LeaseTransactionData::_internal_mutable_recipient() {
  
  if (_impl_.recipient_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Recipient>(GetArenaForAllocation());
    _impl_.recipient_ = p;
  }
  return _impl_.recipient_;
}
inline ::vrp::Recipient* LeaseTransactionData::mutable_recipient() {
  ::vrp::Recipient* _msg = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:vrp.LeaseTransactionData.recipient)
  return _msg;
}
inline void LeaseTransactionData::set_allocated_recipient(::vrp::Recipient* recipient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  if (recipient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recipient));
    if (message_arena != submessage_arena) {
      recipient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recipient, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recipient_ = recipient;
  // @@protoc_insertion_point(field_set_allocated:vrp.LeaseTransactionData.recipient)
}

// int64 amount = 2;
inline void LeaseTransactionData::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t LeaseTransactionData::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t LeaseTransactionData::amount() const {
  // @@protoc_insertion_point(field_get:vrp.LeaseTransactionData.amount)
  return _internal_amount();
}
inline void LeaseTransactionData::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void LeaseTransactionData::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.LeaseTransactionData.amount)
}

// -------------------------------------------------------------------

// LeaseCancelTransactionData

// bytes lease_id = 1;
inline void LeaseCancelTransactionData::clear_lease_id() {
  _impl_.lease_id_.ClearToEmpty();
}
inline const std::string& LeaseCancelTransactionData::lease_id() const {
  // @@protoc_insertion_point(field_get:vrp.LeaseCancelTransactionData.lease_id)
  return _internal_lease_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaseCancelTransactionData::set_lease_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lease_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.LeaseCancelTransactionData.lease_id)
}
inline std::string* LeaseCancelTransactionData::mutable_lease_id() {
  std::string* _s = _internal_mutable_lease_id();
  // @@protoc_insertion_point(field_mutable:vrp.LeaseCancelTransactionData.lease_id)
  return _s;
}
inline const std::string& LeaseCancelTransactionData::_internal_lease_id() const {
  return _impl_.lease_id_.Get();
}
inline void LeaseCancelTransactionData::_internal_set_lease_id(const std::string& value) {
  
  _impl_.lease_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaseCancelTransactionData::_internal_mutable_lease_id() {
  
  return _impl_.lease_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LeaseCancelTransactionData::release_lease_id() {
  // @@protoc_insertion_point(field_release:vrp.LeaseCancelTransactionData.lease_id)
  return _impl_.lease_id_.Release();
}
inline void LeaseCancelTransactionData::set_allocated_lease_id(std::string* lease_id) {
  if (lease_id != nullptr) {
    
  } else {
    
  }
  _impl_.lease_id_.SetAllocated(lease_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lease_id_.IsDefault()) {
    _impl_.lease_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.LeaseCancelTransactionData.lease_id)
}

// -------------------------------------------------------------------

// BurnTransactionData

// .vrp.Amount asset_amount = 1;
inline bool BurnTransactionData::_internal_has_asset_amount() const {
  return this != internal_default_instance() && _impl_.asset_amount_ != nullptr;
}
inline bool BurnTransactionData::has_asset_amount() const {
  return _internal_has_asset_amount();
}
inline const ::vrp::Amount& BurnTransactionData::_internal_asset_amount() const {
  const ::vrp::Amount* p = _impl_.asset_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& BurnTransactionData::asset_amount() const {
  // @@protoc_insertion_point(field_get:vrp.BurnTransactionData.asset_amount)
  return _internal_asset_amount();
}
inline void BurnTransactionData::unsafe_arena_set_allocated_asset_amount(
    ::vrp::Amount* asset_amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.asset_amount_);
  }
  _impl_.asset_amount_ = asset_amount;
  if (asset_amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.BurnTransactionData.asset_amount)
}
inline ::vrp::Amount* BurnTransactionData::release_asset_amount() {
  
  ::vrp::Amount* temp = _impl_.asset_amount_;
  _impl_.asset_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* BurnTransactionData::unsafe_arena_release_asset_amount() {
  // @@protoc_insertion_point(field_release:vrp.BurnTransactionData.asset_amount)
  
  ::vrp::Amount* temp = _impl_.asset_amount_;
  _impl_.asset_amount_ = nullptr;
  return temp;
}
inline ::vrp::Amount* BurnTransactionData::_internal_mutable_asset_amount() {
  
  if (_impl_.asset_amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.asset_amount_ = p;
  }
  return _impl_.asset_amount_;
}
inline ::vrp::Amount* BurnTransactionData::mutable_asset_amount() {
  ::vrp::Amount* _msg = _internal_mutable_asset_amount();
  // @@protoc_insertion_point(field_mutable:vrp.BurnTransactionData.asset_amount)
  return _msg;
}
inline void BurnTransactionData::set_allocated_asset_amount(::vrp::Amount* asset_amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.asset_amount_);
  }
  if (asset_amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asset_amount));
    if (message_arena != submessage_arena) {
      asset_amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset_amount, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.asset_amount_ = asset_amount;
  // @@protoc_insertion_point(field_set_allocated:vrp.BurnTransactionData.asset_amount)
}

// -------------------------------------------------------------------

// IssueTransactionData

// string name = 1;
inline void IssueTransactionData::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& IssueTransactionData::name() const {
  // @@protoc_insertion_point(field_get:vrp.IssueTransactionData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IssueTransactionData::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.IssueTransactionData.name)
}
inline std::string* IssueTransactionData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vrp.IssueTransactionData.name)
  return _s;
}
inline const std::string& IssueTransactionData::_internal_name() const {
  return _impl_.name_.Get();
}
inline void IssueTransactionData::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* IssueTransactionData::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* IssueTransactionData::release_name() {
  // @@protoc_insertion_point(field_release:vrp.IssueTransactionData.name)
  return _impl_.name_.Release();
}
inline void IssueTransactionData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.IssueTransactionData.name)
}

// string description = 2;
inline void IssueTransactionData::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& IssueTransactionData::description() const {
  // @@protoc_insertion_point(field_get:vrp.IssueTransactionData.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IssueTransactionData::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.IssueTransactionData.description)
}
inline std::string* IssueTransactionData::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:vrp.IssueTransactionData.description)
  return _s;
}
inline const std::string& IssueTransactionData::_internal_description() const {
  return _impl_.description_.Get();
}
inline void IssueTransactionData::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* IssueTransactionData::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* IssueTransactionData::release_description() {
  // @@protoc_insertion_point(field_release:vrp.IssueTransactionData.description)
  return _impl_.description_.Release();
}
inline void IssueTransactionData::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.IssueTransactionData.description)
}

// int64 amount = 3;
inline void IssueTransactionData::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t IssueTransactionData::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t IssueTransactionData::amount() const {
  // @@protoc_insertion_point(field_get:vrp.IssueTransactionData.amount)
  return _internal_amount();
}
inline void IssueTransactionData::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void IssueTransactionData::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.IssueTransactionData.amount)
}

// int32 decimals = 4;
inline void IssueTransactionData::clear_decimals() {
  _impl_.decimals_ = 0;
}
inline int32_t IssueTransactionData::_internal_decimals() const {
  return _impl_.decimals_;
}
inline int32_t IssueTransactionData::decimals() const {
  // @@protoc_insertion_point(field_get:vrp.IssueTransactionData.decimals)
  return _internal_decimals();
}
inline void IssueTransactionData::_internal_set_decimals(int32_t value) {
  
  _impl_.decimals_ = value;
}
inline void IssueTransactionData::set_decimals(int32_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:vrp.IssueTransactionData.decimals)
}

// bool reissuable = 5;
inline void IssueTransactionData::clear_reissuable() {
  _impl_.reissuable_ = false;
}
inline bool IssueTransactionData::_internal_reissuable() const {
  return _impl_.reissuable_;
}
inline bool IssueTransactionData::reissuable() const {
  // @@protoc_insertion_point(field_get:vrp.IssueTransactionData.reissuable)
  return _internal_reissuable();
}
inline void IssueTransactionData::_internal_set_reissuable(bool value) {
  
  _impl_.reissuable_ = value;
}
inline void IssueTransactionData::set_reissuable(bool value) {
  _internal_set_reissuable(value);
  // @@protoc_insertion_point(field_set:vrp.IssueTransactionData.reissuable)
}

// bytes script = 6;
inline void IssueTransactionData::clear_script() {
  _impl_.script_.ClearToEmpty();
}
inline const std::string& IssueTransactionData::script() const {
  // @@protoc_insertion_point(field_get:vrp.IssueTransactionData.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IssueTransactionData::set_script(ArgT0&& arg0, ArgT... args) {
 
 _impl_.script_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.IssueTransactionData.script)
}
inline std::string* IssueTransactionData::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:vrp.IssueTransactionData.script)
  return _s;
}
inline const std::string& IssueTransactionData::_internal_script() const {
  return _impl_.script_.Get();
}
inline void IssueTransactionData::_internal_set_script(const std::string& value) {
  
  _impl_.script_.Set(value, GetArenaForAllocation());
}
inline std::string* IssueTransactionData::_internal_mutable_script() {
  
  return _impl_.script_.Mutable(GetArenaForAllocation());
}
inline std::string* IssueTransactionData::release_script() {
  // @@protoc_insertion_point(field_release:vrp.IssueTransactionData.script)
  return _impl_.script_.Release();
}
inline void IssueTransactionData::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  _impl_.script_.SetAllocated(script, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.script_.IsDefault()) {
    _impl_.script_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.IssueTransactionData.script)
}

// -------------------------------------------------------------------

// ReissueTransactionData

// .vrp.Amount asset_amount = 1;
inline bool ReissueTransactionData::_internal_has_asset_amount() const {
  return this != internal_default_instance() && _impl_.asset_amount_ != nullptr;
}
inline bool ReissueTransactionData::has_asset_amount() const {
  return _internal_has_asset_amount();
}
inline const ::vrp::Amount& ReissueTransactionData::_internal_asset_amount() const {
  const ::vrp::Amount* p = _impl_.asset_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& ReissueTransactionData::asset_amount() const {
  // @@protoc_insertion_point(field_get:vrp.ReissueTransactionData.asset_amount)
  return _internal_asset_amount();
}
inline void ReissueTransactionData::unsafe_arena_set_allocated_asset_amount(
    ::vrp::Amount* asset_amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.asset_amount_);
  }
  _impl_.asset_amount_ = asset_amount;
  if (asset_amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.ReissueTransactionData.asset_amount)
}
inline ::vrp::Amount* ReissueTransactionData::release_asset_amount() {
  
  ::vrp::Amount* temp = _impl_.asset_amount_;
  _impl_.asset_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* ReissueTransactionData::unsafe_arena_release_asset_amount() {
  // @@protoc_insertion_point(field_release:vrp.ReissueTransactionData.asset_amount)
  
  ::vrp::Amount* temp = _impl_.asset_amount_;
  _impl_.asset_amount_ = nullptr;
  return temp;
}
inline ::vrp::Amount* ReissueTransactionData::_internal_mutable_asset_amount() {
  
  if (_impl_.asset_amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.asset_amount_ = p;
  }
  return _impl_.asset_amount_;
}
inline ::vrp::Amount* ReissueTransactionData::mutable_asset_amount() {
  ::vrp::Amount* _msg = _internal_mutable_asset_amount();
  // @@protoc_insertion_point(field_mutable:vrp.ReissueTransactionData.asset_amount)
  return _msg;
}
inline void ReissueTransactionData::set_allocated_asset_amount(::vrp::Amount* asset_amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.asset_amount_);
  }
  if (asset_amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asset_amount));
    if (message_arena != submessage_arena) {
      asset_amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset_amount, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.asset_amount_ = asset_amount;
  // @@protoc_insertion_point(field_set_allocated:vrp.ReissueTransactionData.asset_amount)
}

// bool reissuable = 2;
inline void ReissueTransactionData::clear_reissuable() {
  _impl_.reissuable_ = false;
}
inline bool ReissueTransactionData::_internal_reissuable() const {
  return _impl_.reissuable_;
}
inline bool ReissueTransactionData::reissuable() const {
  // @@protoc_insertion_point(field_get:vrp.ReissueTransactionData.reissuable)
  return _internal_reissuable();
}
inline void ReissueTransactionData::_internal_set_reissuable(bool value) {
  
  _impl_.reissuable_ = value;
}
inline void ReissueTransactionData::set_reissuable(bool value) {
  _internal_set_reissuable(value);
  // @@protoc_insertion_point(field_set:vrp.ReissueTransactionData.reissuable)
}

// -------------------------------------------------------------------

// SetAssetScriptTransactionData

// bytes asset_id = 1;
inline void SetAssetScriptTransactionData::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& SetAssetScriptTransactionData::asset_id() const {
  // @@protoc_insertion_point(field_get:vrp.SetAssetScriptTransactionData.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAssetScriptTransactionData::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.SetAssetScriptTransactionData.asset_id)
}
inline std::string* SetAssetScriptTransactionData::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:vrp.SetAssetScriptTransactionData.asset_id)
  return _s;
}
inline const std::string& SetAssetScriptTransactionData::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void SetAssetScriptTransactionData::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAssetScriptTransactionData::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAssetScriptTransactionData::release_asset_id() {
  // @@protoc_insertion_point(field_release:vrp.SetAssetScriptTransactionData.asset_id)
  return _impl_.asset_id_.Release();
}
inline void SetAssetScriptTransactionData::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.SetAssetScriptTransactionData.asset_id)
}

// bytes script = 2;
inline void SetAssetScriptTransactionData::clear_script() {
  _impl_.script_.ClearToEmpty();
}
inline const std::string& SetAssetScriptTransactionData::script() const {
  // @@protoc_insertion_point(field_get:vrp.SetAssetScriptTransactionData.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAssetScriptTransactionData::set_script(ArgT0&& arg0, ArgT... args) {
 
 _impl_.script_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.SetAssetScriptTransactionData.script)
}
inline std::string* SetAssetScriptTransactionData::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:vrp.SetAssetScriptTransactionData.script)
  return _s;
}
inline const std::string& SetAssetScriptTransactionData::_internal_script() const {
  return _impl_.script_.Get();
}
inline void SetAssetScriptTransactionData::_internal_set_script(const std::string& value) {
  
  _impl_.script_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAssetScriptTransactionData::_internal_mutable_script() {
  
  return _impl_.script_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAssetScriptTransactionData::release_script() {
  // @@protoc_insertion_point(field_release:vrp.SetAssetScriptTransactionData.script)
  return _impl_.script_.Release();
}
inline void SetAssetScriptTransactionData::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  _impl_.script_.SetAllocated(script, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.script_.IsDefault()) {
    _impl_.script_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.SetAssetScriptTransactionData.script)
}

// -------------------------------------------------------------------

// SetScriptTransactionData

// bytes script = 1;
inline void SetScriptTransactionData::clear_script() {
  _impl_.script_.ClearToEmpty();
}
inline const std::string& SetScriptTransactionData::script() const {
  // @@protoc_insertion_point(field_get:vrp.SetScriptTransactionData.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetScriptTransactionData::set_script(ArgT0&& arg0, ArgT... args) {
 
 _impl_.script_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.SetScriptTransactionData.script)
}
inline std::string* SetScriptTransactionData::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:vrp.SetScriptTransactionData.script)
  return _s;
}
inline const std::string& SetScriptTransactionData::_internal_script() const {
  return _impl_.script_.Get();
}
inline void SetScriptTransactionData::_internal_set_script(const std::string& value) {
  
  _impl_.script_.Set(value, GetArenaForAllocation());
}
inline std::string* SetScriptTransactionData::_internal_mutable_script() {
  
  return _impl_.script_.Mutable(GetArenaForAllocation());
}
inline std::string* SetScriptTransactionData::release_script() {
  // @@protoc_insertion_point(field_release:vrp.SetScriptTransactionData.script)
  return _impl_.script_.Release();
}
inline void SetScriptTransactionData::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  _impl_.script_.SetAllocated(script, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.script_.IsDefault()) {
    _impl_.script_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.SetScriptTransactionData.script)
}

// -------------------------------------------------------------------

// ExchangeTransactionData

// int64 amount = 1;
inline void ExchangeTransactionData::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t ExchangeTransactionData::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t ExchangeTransactionData::amount() const {
  // @@protoc_insertion_point(field_get:vrp.ExchangeTransactionData.amount)
  return _internal_amount();
}
inline void ExchangeTransactionData::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void ExchangeTransactionData::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.ExchangeTransactionData.amount)
}

// int64 price = 2;
inline void ExchangeTransactionData::clear_price() {
  _impl_.price_ = int64_t{0};
}
inline int64_t ExchangeTransactionData::_internal_price() const {
  return _impl_.price_;
}
inline int64_t ExchangeTransactionData::price() const {
  // @@protoc_insertion_point(field_get:vrp.ExchangeTransactionData.price)
  return _internal_price();
}
inline void ExchangeTransactionData::_internal_set_price(int64_t value) {
  
  _impl_.price_ = value;
}
inline void ExchangeTransactionData::set_price(int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:vrp.ExchangeTransactionData.price)
}

// int64 buy_matcher_fee = 3;
inline void ExchangeTransactionData::clear_buy_matcher_fee() {
  _impl_.buy_matcher_fee_ = int64_t{0};
}
inline int64_t ExchangeTransactionData::_internal_buy_matcher_fee() const {
  return _impl_.buy_matcher_fee_;
}
inline int64_t ExchangeTransactionData::buy_matcher_fee() const {
  // @@protoc_insertion_point(field_get:vrp.ExchangeTransactionData.buy_matcher_fee)
  return _internal_buy_matcher_fee();
}
inline void ExchangeTransactionData::_internal_set_buy_matcher_fee(int64_t value) {
  
  _impl_.buy_matcher_fee_ = value;
}
inline void ExchangeTransactionData::set_buy_matcher_fee(int64_t value) {
  _internal_set_buy_matcher_fee(value);
  // @@protoc_insertion_point(field_set:vrp.ExchangeTransactionData.buy_matcher_fee)
}

// int64 sell_matcher_fee = 4;
inline void ExchangeTransactionData::clear_sell_matcher_fee() {
  _impl_.sell_matcher_fee_ = int64_t{0};
}
inline int64_t ExchangeTransactionData::_internal_sell_matcher_fee() const {
  return _impl_.sell_matcher_fee_;
}
inline int64_t ExchangeTransactionData::sell_matcher_fee() const {
  // @@protoc_insertion_point(field_get:vrp.ExchangeTransactionData.sell_matcher_fee)
  return _internal_sell_matcher_fee();
}
inline void ExchangeTransactionData::_internal_set_sell_matcher_fee(int64_t value) {
  
  _impl_.sell_matcher_fee_ = value;
}
inline void ExchangeTransactionData::set_sell_matcher_fee(int64_t value) {
  _internal_set_sell_matcher_fee(value);
  // @@protoc_insertion_point(field_set:vrp.ExchangeTransactionData.sell_matcher_fee)
}

// repeated .vrp.Order orders = 5;
inline int ExchangeTransactionData::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int ExchangeTransactionData::orders_size() const {
  return _internal_orders_size();
}
inline ::vrp::Order* ExchangeTransactionData::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.ExchangeTransactionData.orders)
  return _impl_.orders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Order >*
ExchangeTransactionData::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:vrp.ExchangeTransactionData.orders)
  return &_impl_.orders_;
}
inline const ::vrp::Order& ExchangeTransactionData::_internal_orders(int index) const {
  return _impl_.orders_.Get(index);
}
inline const ::vrp::Order& ExchangeTransactionData::orders(int index) const {
  // @@protoc_insertion_point(field_get:vrp.ExchangeTransactionData.orders)
  return _internal_orders(index);
}
inline ::vrp::Order* ExchangeTransactionData::_internal_add_orders() {
  return _impl_.orders_.Add();
}
inline ::vrp::Order* ExchangeTransactionData::add_orders() {
  ::vrp::Order* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:vrp.ExchangeTransactionData.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Order >&
ExchangeTransactionData::orders() const {
  // @@protoc_insertion_point(field_list:vrp.ExchangeTransactionData.orders)
  return _impl_.orders_;
}

// -------------------------------------------------------------------

// SponsorFeeTransactionData

// .vrp.Amount min_fee = 1;
inline bool SponsorFeeTransactionData::_internal_has_min_fee() const {
  return this != internal_default_instance() && _impl_.min_fee_ != nullptr;
}
inline bool SponsorFeeTransactionData::has_min_fee() const {
  return _internal_has_min_fee();
}
inline const ::vrp::Amount& SponsorFeeTransactionData::_internal_min_fee() const {
  const ::vrp::Amount* p = _impl_.min_fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& SponsorFeeTransactionData::min_fee() const {
  // @@protoc_insertion_point(field_get:vrp.SponsorFeeTransactionData.min_fee)
  return _internal_min_fee();
}
inline void SponsorFeeTransactionData::unsafe_arena_set_allocated_min_fee(
    ::vrp::Amount* min_fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_fee_);
  }
  _impl_.min_fee_ = min_fee;
  if (min_fee) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.SponsorFeeTransactionData.min_fee)
}
inline ::vrp::Amount* SponsorFeeTransactionData::release_min_fee() {
  
  ::vrp::Amount* temp = _impl_.min_fee_;
  _impl_.min_fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* SponsorFeeTransactionData::unsafe_arena_release_min_fee() {
  // @@protoc_insertion_point(field_release:vrp.SponsorFeeTransactionData.min_fee)
  
  ::vrp::Amount* temp = _impl_.min_fee_;
  _impl_.min_fee_ = nullptr;
  return temp;
}
inline ::vrp::Amount* SponsorFeeTransactionData::_internal_mutable_min_fee() {
  
  if (_impl_.min_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.min_fee_ = p;
  }
  return _impl_.min_fee_;
}
inline ::vrp::Amount* SponsorFeeTransactionData::mutable_min_fee() {
  ::vrp::Amount* _msg = _internal_mutable_min_fee();
  // @@protoc_insertion_point(field_mutable:vrp.SponsorFeeTransactionData.min_fee)
  return _msg;
}
inline void SponsorFeeTransactionData::set_allocated_min_fee(::vrp::Amount* min_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_fee_);
  }
  if (min_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_fee));
    if (message_arena != submessage_arena) {
      min_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_fee, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_fee_ = min_fee;
  // @@protoc_insertion_point(field_set_allocated:vrp.SponsorFeeTransactionData.min_fee)
}

// -------------------------------------------------------------------

// InvokeScriptTransactionData

// .vrp.Recipient d_app = 1;
inline bool InvokeScriptTransactionData::_internal_has_d_app() const {
  return this != internal_default_instance() && _impl_.d_app_ != nullptr;
}
inline bool InvokeScriptTransactionData::has_d_app() const {
  return _internal_has_d_app();
}
inline const ::vrp::Recipient& InvokeScriptTransactionData::_internal_d_app() const {
  const ::vrp::Recipient* p = _impl_.d_app_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Recipient&>(
      ::vrp::_Recipient_default_instance_);
}
inline const ::vrp::Recipient& InvokeScriptTransactionData::d_app() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptTransactionData.d_app)
  return _internal_d_app();
}
inline void InvokeScriptTransactionData::unsafe_arena_set_allocated_d_app(
    ::vrp::Recipient* d_app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.d_app_);
  }
  _impl_.d_app_ = d_app;
  if (d_app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptTransactionData.d_app)
}
inline ::vrp::Recipient* InvokeScriptTransactionData::release_d_app() {
  
  ::vrp::Recipient* temp = _impl_.d_app_;
  _impl_.d_app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Recipient* InvokeScriptTransactionData::unsafe_arena_release_d_app() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptTransactionData.d_app)
  
  ::vrp::Recipient* temp = _impl_.d_app_;
  _impl_.d_app_ = nullptr;
  return temp;
}
inline ::vrp::Recipient* InvokeScriptTransactionData::_internal_mutable_d_app() {
  
  if (_impl_.d_app_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Recipient>(GetArenaForAllocation());
    _impl_.d_app_ = p;
  }
  return _impl_.d_app_;
}
inline ::vrp::Recipient* InvokeScriptTransactionData::mutable_d_app() {
  ::vrp::Recipient* _msg = _internal_mutable_d_app();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptTransactionData.d_app)
  return _msg;
}
inline void InvokeScriptTransactionData::set_allocated_d_app(::vrp::Recipient* d_app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.d_app_);
  }
  if (d_app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(d_app));
    if (message_arena != submessage_arena) {
      d_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, d_app, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.d_app_ = d_app;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptTransactionData.d_app)
}

// bytes function_call = 2;
inline void InvokeScriptTransactionData::clear_function_call() {
  _impl_.function_call_.ClearToEmpty();
}
inline const std::string& InvokeScriptTransactionData::function_call() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptTransactionData.function_call)
  return _internal_function_call();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptTransactionData::set_function_call(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_call_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptTransactionData.function_call)
}
inline std::string* InvokeScriptTransactionData::mutable_function_call() {
  std::string* _s = _internal_mutable_function_call();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptTransactionData.function_call)
  return _s;
}
inline const std::string& InvokeScriptTransactionData::_internal_function_call() const {
  return _impl_.function_call_.Get();
}
inline void InvokeScriptTransactionData::_internal_set_function_call(const std::string& value) {
  
  _impl_.function_call_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptTransactionData::_internal_mutable_function_call() {
  
  return _impl_.function_call_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptTransactionData::release_function_call() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptTransactionData.function_call)
  return _impl_.function_call_.Release();
}
inline void InvokeScriptTransactionData::set_allocated_function_call(std::string* function_call) {
  if (function_call != nullptr) {
    
  } else {
    
  }
  _impl_.function_call_.SetAllocated(function_call, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_call_.IsDefault()) {
    _impl_.function_call_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptTransactionData.function_call)
}

// repeated .vrp.Amount payments = 3;
inline int InvokeScriptTransactionData::_internal_payments_size() const {
  return _impl_.payments_.size();
}
inline int InvokeScriptTransactionData::payments_size() const {
  return _internal_payments_size();
}
inline ::vrp::Amount* InvokeScriptTransactionData::mutable_payments(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptTransactionData.payments)
  return _impl_.payments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >*
InvokeScriptTransactionData::mutable_payments() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptTransactionData.payments)
  return &_impl_.payments_;
}
inline const ::vrp::Amount& InvokeScriptTransactionData::_internal_payments(int index) const {
  return _impl_.payments_.Get(index);
}
inline const ::vrp::Amount& InvokeScriptTransactionData::payments(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptTransactionData.payments)
  return _internal_payments(index);
}
inline ::vrp::Amount* InvokeScriptTransactionData::_internal_add_payments() {
  return _impl_.payments_.Add();
}
inline ::vrp::Amount* InvokeScriptTransactionData::add_payments() {
  ::vrp::Amount* _add = _internal_add_payments();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptTransactionData.payments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >&
InvokeScriptTransactionData::payments() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptTransactionData.payments)
  return _impl_.payments_;
}

// -------------------------------------------------------------------

// UpdateAssetInfoTransactionData

// bytes asset_id = 1;
inline void UpdateAssetInfoTransactionData::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& UpdateAssetInfoTransactionData::asset_id() const {
  // @@protoc_insertion_point(field_get:vrp.UpdateAssetInfoTransactionData.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAssetInfoTransactionData::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.UpdateAssetInfoTransactionData.asset_id)
}
inline std::string* UpdateAssetInfoTransactionData::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:vrp.UpdateAssetInfoTransactionData.asset_id)
  return _s;
}
inline const std::string& UpdateAssetInfoTransactionData::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void UpdateAssetInfoTransactionData::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::release_asset_id() {
  // @@protoc_insertion_point(field_release:vrp.UpdateAssetInfoTransactionData.asset_id)
  return _impl_.asset_id_.Release();
}
inline void UpdateAssetInfoTransactionData::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.UpdateAssetInfoTransactionData.asset_id)
}

// string name = 2;
inline void UpdateAssetInfoTransactionData::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateAssetInfoTransactionData::name() const {
  // @@protoc_insertion_point(field_get:vrp.UpdateAssetInfoTransactionData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAssetInfoTransactionData::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.UpdateAssetInfoTransactionData.name)
}
inline std::string* UpdateAssetInfoTransactionData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vrp.UpdateAssetInfoTransactionData.name)
  return _s;
}
inline const std::string& UpdateAssetInfoTransactionData::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateAssetInfoTransactionData::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::release_name() {
  // @@protoc_insertion_point(field_release:vrp.UpdateAssetInfoTransactionData.name)
  return _impl_.name_.Release();
}
inline void UpdateAssetInfoTransactionData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.UpdateAssetInfoTransactionData.name)
}

// string description = 3;
inline void UpdateAssetInfoTransactionData::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UpdateAssetInfoTransactionData::description() const {
  // @@protoc_insertion_point(field_get:vrp.UpdateAssetInfoTransactionData.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAssetInfoTransactionData::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.UpdateAssetInfoTransactionData.description)
}
inline std::string* UpdateAssetInfoTransactionData::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:vrp.UpdateAssetInfoTransactionData.description)
  return _s;
}
inline const std::string& UpdateAssetInfoTransactionData::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UpdateAssetInfoTransactionData::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::release_description() {
  // @@protoc_insertion_point(field_release:vrp.UpdateAssetInfoTransactionData.description)
  return _impl_.description_.Release();
}
inline void UpdateAssetInfoTransactionData::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.UpdateAssetInfoTransactionData.description)
}

// string image = 4;
inline void UpdateAssetInfoTransactionData::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& UpdateAssetInfoTransactionData::image() const {
  // @@protoc_insertion_point(field_get:vrp.UpdateAssetInfoTransactionData.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAssetInfoTransactionData::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.UpdateAssetInfoTransactionData.image)
}
inline std::string* UpdateAssetInfoTransactionData::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:vrp.UpdateAssetInfoTransactionData.image)
  return _s;
}
inline const std::string& UpdateAssetInfoTransactionData::_internal_image() const {
  return _impl_.image_.Get();
}
inline void UpdateAssetInfoTransactionData::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAssetInfoTransactionData::release_image() {
  // @@protoc_insertion_point(field_release:vrp.UpdateAssetInfoTransactionData.image)
  return _impl_.image_.Release();
}
inline void UpdateAssetInfoTransactionData::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.UpdateAssetInfoTransactionData.image)
}

// -------------------------------------------------------------------

// InvokeExpressionTransactionData

// bytes expression = 1;
inline void InvokeExpressionTransactionData::clear_expression() {
  _impl_.expression_.ClearToEmpty();
}
inline const std::string& InvokeExpressionTransactionData::expression() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeExpressionTransactionData.expression)
  return _internal_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeExpressionTransactionData::set_expression(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expression_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeExpressionTransactionData.expression)
}
inline std::string* InvokeExpressionTransactionData::mutable_expression() {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeExpressionTransactionData.expression)
  return _s;
}
inline const std::string& InvokeExpressionTransactionData::_internal_expression() const {
  return _impl_.expression_.Get();
}
inline void InvokeExpressionTransactionData::_internal_set_expression(const std::string& value) {
  
  _impl_.expression_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeExpressionTransactionData::_internal_mutable_expression() {
  
  return _impl_.expression_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeExpressionTransactionData::release_expression() {
  // @@protoc_insertion_point(field_release:vrp.InvokeExpressionTransactionData.expression)
  return _impl_.expression_.Release();
}
inline void InvokeExpressionTransactionData::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    
  } else {
    
  }
  _impl_.expression_.SetAllocated(expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expression_.IsDefault()) {
    _impl_.expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeExpressionTransactionData.expression)
}

// -------------------------------------------------------------------

// PrivatePaymentTransactionData

// bytes recipient_address = 1;
inline void PrivatePaymentTransactionData::clear_recipient_address() {
  _impl_.recipient_address_.ClearToEmpty();
}
inline const std::string& PrivatePaymentTransactionData::recipient_address() const {
  // @@protoc_insertion_point(field_get:vrp.PrivatePaymentTransactionData.recipient_address)
  return _internal_recipient_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivatePaymentTransactionData::set_recipient_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.PrivatePaymentTransactionData.recipient_address)
}
inline std::string* PrivatePaymentTransactionData::mutable_recipient_address() {
  std::string* _s = _internal_mutable_recipient_address();
  // @@protoc_insertion_point(field_mutable:vrp.PrivatePaymentTransactionData.recipient_address)
  return _s;
}
inline const std::string& PrivatePaymentTransactionData::_internal_recipient_address() const {
  return _impl_.recipient_address_.Get();
}
inline void PrivatePaymentTransactionData::_internal_set_recipient_address(const std::string& value) {
  
  _impl_.recipient_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivatePaymentTransactionData::_internal_mutable_recipient_address() {
  
  return _impl_.recipient_address_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivatePaymentTransactionData::release_recipient_address() {
  // @@protoc_insertion_point(field_release:vrp.PrivatePaymentTransactionData.recipient_address)
  return _impl_.recipient_address_.Release();
}
inline void PrivatePaymentTransactionData::set_allocated_recipient_address(std::string* recipient_address) {
  if (recipient_address != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_address_.SetAllocated(recipient_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_address_.IsDefault()) {
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.PrivatePaymentTransactionData.recipient_address)
}

// int64 amount = 2;
inline void PrivatePaymentTransactionData::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t PrivatePaymentTransactionData::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t PrivatePaymentTransactionData::amount() const {
  // @@protoc_insertion_point(field_get:vrp.PrivatePaymentTransactionData.amount)
  return _internal_amount();
}
inline void PrivatePaymentTransactionData::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void PrivatePaymentTransactionData::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.PrivatePaymentTransactionData.amount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vrp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vrp_2ftransaction_2eproto
