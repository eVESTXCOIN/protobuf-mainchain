// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vrp/invoke_script_result.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vrp_2finvoke_5fscript_5fresult_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vrp_2finvoke_5fscript_5fresult_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "vrp/transaction.pb.h"
#include "vrp/amount.pb.h"
#include "vrp/recipient.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vrp_2finvoke_5fscript_5fresult_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vrp_2finvoke_5fscript_5fresult_2eproto;
namespace vrp {
class InvokeScriptResult;
struct InvokeScriptResultDefaultTypeInternal;
extern InvokeScriptResultDefaultTypeInternal _InvokeScriptResult_default_instance_;
class InvokeScriptResult_Burn;
struct InvokeScriptResult_BurnDefaultTypeInternal;
extern InvokeScriptResult_BurnDefaultTypeInternal _InvokeScriptResult_Burn_default_instance_;
class InvokeScriptResult_Call;
struct InvokeScriptResult_CallDefaultTypeInternal;
extern InvokeScriptResult_CallDefaultTypeInternal _InvokeScriptResult_Call_default_instance_;
class InvokeScriptResult_Call_Argument;
struct InvokeScriptResult_Call_ArgumentDefaultTypeInternal;
extern InvokeScriptResult_Call_ArgumentDefaultTypeInternal _InvokeScriptResult_Call_Argument_default_instance_;
class InvokeScriptResult_Call_Argument_List;
struct InvokeScriptResult_Call_Argument_ListDefaultTypeInternal;
extern InvokeScriptResult_Call_Argument_ListDefaultTypeInternal _InvokeScriptResult_Call_Argument_List_default_instance_;
class InvokeScriptResult_ErrorMessage;
struct InvokeScriptResult_ErrorMessageDefaultTypeInternal;
extern InvokeScriptResult_ErrorMessageDefaultTypeInternal _InvokeScriptResult_ErrorMessage_default_instance_;
class InvokeScriptResult_Invocation;
struct InvokeScriptResult_InvocationDefaultTypeInternal;
extern InvokeScriptResult_InvocationDefaultTypeInternal _InvokeScriptResult_Invocation_default_instance_;
class InvokeScriptResult_Issue;
struct InvokeScriptResult_IssueDefaultTypeInternal;
extern InvokeScriptResult_IssueDefaultTypeInternal _InvokeScriptResult_Issue_default_instance_;
class InvokeScriptResult_Lease;
struct InvokeScriptResult_LeaseDefaultTypeInternal;
extern InvokeScriptResult_LeaseDefaultTypeInternal _InvokeScriptResult_Lease_default_instance_;
class InvokeScriptResult_LeaseCancel;
struct InvokeScriptResult_LeaseCancelDefaultTypeInternal;
extern InvokeScriptResult_LeaseCancelDefaultTypeInternal _InvokeScriptResult_LeaseCancel_default_instance_;
class InvokeScriptResult_Payment;
struct InvokeScriptResult_PaymentDefaultTypeInternal;
extern InvokeScriptResult_PaymentDefaultTypeInternal _InvokeScriptResult_Payment_default_instance_;
class InvokeScriptResult_PrivatePayment;
struct InvokeScriptResult_PrivatePaymentDefaultTypeInternal;
extern InvokeScriptResult_PrivatePaymentDefaultTypeInternal _InvokeScriptResult_PrivatePayment_default_instance_;
class InvokeScriptResult_Reissue;
struct InvokeScriptResult_ReissueDefaultTypeInternal;
extern InvokeScriptResult_ReissueDefaultTypeInternal _InvokeScriptResult_Reissue_default_instance_;
class InvokeScriptResult_SponsorFee;
struct InvokeScriptResult_SponsorFeeDefaultTypeInternal;
extern InvokeScriptResult_SponsorFeeDefaultTypeInternal _InvokeScriptResult_SponsorFee_default_instance_;
}  // namespace vrp
PROTOBUF_NAMESPACE_OPEN
template<> ::vrp::InvokeScriptResult* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult>(Arena*);
template<> ::vrp::InvokeScriptResult_Burn* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Burn>(Arena*);
template<> ::vrp::InvokeScriptResult_Call* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Call>(Arena*);
template<> ::vrp::InvokeScriptResult_Call_Argument* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Call_Argument>(Arena*);
template<> ::vrp::InvokeScriptResult_Call_Argument_List* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Call_Argument_List>(Arena*);
template<> ::vrp::InvokeScriptResult_ErrorMessage* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_ErrorMessage>(Arena*);
template<> ::vrp::InvokeScriptResult_Invocation* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Invocation>(Arena*);
template<> ::vrp::InvokeScriptResult_Issue* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Issue>(Arena*);
template<> ::vrp::InvokeScriptResult_Lease* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Lease>(Arena*);
template<> ::vrp::InvokeScriptResult_LeaseCancel* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_LeaseCancel>(Arena*);
template<> ::vrp::InvokeScriptResult_Payment* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Payment>(Arena*);
template<> ::vrp::InvokeScriptResult_PrivatePayment* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_PrivatePayment>(Arena*);
template<> ::vrp::InvokeScriptResult_Reissue* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_Reissue>(Arena*);
template<> ::vrp::InvokeScriptResult_SponsorFee* Arena::CreateMaybeMessage<::vrp::InvokeScriptResult_SponsorFee>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vrp {

// ===================================================================

class InvokeScriptResult_Payment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Payment) */ {
 public:
  inline InvokeScriptResult_Payment() : InvokeScriptResult_Payment(nullptr) {}
  ~InvokeScriptResult_Payment() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Payment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Payment(const InvokeScriptResult_Payment& from);
  InvokeScriptResult_Payment(InvokeScriptResult_Payment&& from) noexcept
    : InvokeScriptResult_Payment() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Payment& operator=(const InvokeScriptResult_Payment& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Payment& operator=(InvokeScriptResult_Payment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Payment& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Payment* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Payment*>(
               &_InvokeScriptResult_Payment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InvokeScriptResult_Payment& a, InvokeScriptResult_Payment& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Payment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Payment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Payment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Payment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Payment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Payment& from) {
    InvokeScriptResult_Payment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Payment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Payment";
  }
  protected:
  explicit InvokeScriptResult_Payment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .vrp.Amount amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::vrp::Amount& amount() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_amount();
  ::vrp::Amount* mutable_amount();
  void set_allocated_amount(::vrp::Amount* amount);
  private:
  const ::vrp::Amount& _internal_amount() const;
  ::vrp::Amount* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::vrp::Amount* amount);
  ::vrp::Amount* unsafe_arena_release_amount();

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Payment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::vrp::Amount* amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_PrivatePayment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.PrivatePayment) */ {
 public:
  inline InvokeScriptResult_PrivatePayment() : InvokeScriptResult_PrivatePayment(nullptr) {}
  ~InvokeScriptResult_PrivatePayment() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_PrivatePayment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_PrivatePayment(const InvokeScriptResult_PrivatePayment& from);
  InvokeScriptResult_PrivatePayment(InvokeScriptResult_PrivatePayment&& from) noexcept
    : InvokeScriptResult_PrivatePayment() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_PrivatePayment& operator=(const InvokeScriptResult_PrivatePayment& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_PrivatePayment& operator=(InvokeScriptResult_PrivatePayment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_PrivatePayment& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_PrivatePayment* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_PrivatePayment*>(
               &_InvokeScriptResult_PrivatePayment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InvokeScriptResult_PrivatePayment& a, InvokeScriptResult_PrivatePayment& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_PrivatePayment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_PrivatePayment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_PrivatePayment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_PrivatePayment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_PrivatePayment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_PrivatePayment& from) {
    InvokeScriptResult_PrivatePayment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_PrivatePayment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.PrivatePayment";
  }
  protected:
  explicit InvokeScriptResult_PrivatePayment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .vrp.Amount amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::vrp::Amount& amount() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_amount();
  ::vrp::Amount* mutable_amount();
  void set_allocated_amount(::vrp::Amount* amount);
  private:
  const ::vrp::Amount& _internal_amount() const;
  ::vrp::Amount* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::vrp::Amount* amount);
  ::vrp::Amount* unsafe_arena_release_amount();

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.PrivatePayment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::vrp::Amount* amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Issue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Issue) */ {
 public:
  inline InvokeScriptResult_Issue() : InvokeScriptResult_Issue(nullptr) {}
  ~InvokeScriptResult_Issue() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Issue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Issue(const InvokeScriptResult_Issue& from);
  InvokeScriptResult_Issue(InvokeScriptResult_Issue&& from) noexcept
    : InvokeScriptResult_Issue() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Issue& operator=(const InvokeScriptResult_Issue& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Issue& operator=(InvokeScriptResult_Issue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Issue& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Issue* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Issue*>(
               &_InvokeScriptResult_Issue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InvokeScriptResult_Issue& a, InvokeScriptResult_Issue& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Issue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Issue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Issue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Issue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Issue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Issue& from) {
    InvokeScriptResult_Issue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Issue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Issue";
  }
  protected:
  explicit InvokeScriptResult_Issue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kImageFieldNumber = 4,
    kScriptFieldNumber = 8,
    kAmountFieldNumber = 5,
    kDecimalsFieldNumber = 6,
    kReissuableFieldNumber = 7,
    kNonceFieldNumber = 9,
  };
  // bytes asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string image = 4;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // bytes script = 8;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_NODISCARD std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // int64 amount = 5;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // int32 decimals = 6;
  void clear_decimals();
  int32_t decimals() const;
  void set_decimals(int32_t value);
  private:
  int32_t _internal_decimals() const;
  void _internal_set_decimals(int32_t value);
  public:

  // bool reissuable = 7;
  void clear_reissuable();
  bool reissuable() const;
  void set_reissuable(bool value);
  private:
  bool _internal_reissuable() const;
  void _internal_set_reissuable(bool value);
  public:

  // int64 nonce = 9;
  void clear_nonce();
  int64_t nonce() const;
  void set_nonce(int64_t value);
  private:
  int64_t _internal_nonce() const;
  void _internal_set_nonce(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Issue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
    int64_t amount_;
    int32_t decimals_;
    bool reissuable_;
    int64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Reissue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Reissue) */ {
 public:
  inline InvokeScriptResult_Reissue() : InvokeScriptResult_Reissue(nullptr) {}
  ~InvokeScriptResult_Reissue() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Reissue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Reissue(const InvokeScriptResult_Reissue& from);
  InvokeScriptResult_Reissue(InvokeScriptResult_Reissue&& from) noexcept
    : InvokeScriptResult_Reissue() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Reissue& operator=(const InvokeScriptResult_Reissue& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Reissue& operator=(InvokeScriptResult_Reissue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Reissue& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Reissue* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Reissue*>(
               &_InvokeScriptResult_Reissue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InvokeScriptResult_Reissue& a, InvokeScriptResult_Reissue& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Reissue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Reissue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Reissue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Reissue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Reissue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Reissue& from) {
    InvokeScriptResult_Reissue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Reissue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Reissue";
  }
  protected:
  explicit InvokeScriptResult_Reissue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kAmountFieldNumber = 2,
    kIsReissuableFieldNumber = 3,
  };
  // bytes asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // bool is_reissuable = 3;
  void clear_is_reissuable();
  bool is_reissuable() const;
  void set_is_reissuable(bool value);
  private:
  bool _internal_is_reissuable() const;
  void _internal_set_is_reissuable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Reissue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    int64_t amount_;
    bool is_reissuable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Burn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Burn) */ {
 public:
  inline InvokeScriptResult_Burn() : InvokeScriptResult_Burn(nullptr) {}
  ~InvokeScriptResult_Burn() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Burn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Burn(const InvokeScriptResult_Burn& from);
  InvokeScriptResult_Burn(InvokeScriptResult_Burn&& from) noexcept
    : InvokeScriptResult_Burn() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Burn& operator=(const InvokeScriptResult_Burn& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Burn& operator=(InvokeScriptResult_Burn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Burn& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Burn* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Burn*>(
               &_InvokeScriptResult_Burn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InvokeScriptResult_Burn& a, InvokeScriptResult_Burn& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Burn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Burn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Burn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Burn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Burn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Burn& from) {
    InvokeScriptResult_Burn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Burn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Burn";
  }
  protected:
  explicit InvokeScriptResult_Burn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // bytes asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Burn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
    int64_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_SponsorFee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.SponsorFee) */ {
 public:
  inline InvokeScriptResult_SponsorFee() : InvokeScriptResult_SponsorFee(nullptr) {}
  ~InvokeScriptResult_SponsorFee() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_SponsorFee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_SponsorFee(const InvokeScriptResult_SponsorFee& from);
  InvokeScriptResult_SponsorFee(InvokeScriptResult_SponsorFee&& from) noexcept
    : InvokeScriptResult_SponsorFee() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_SponsorFee& operator=(const InvokeScriptResult_SponsorFee& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_SponsorFee& operator=(InvokeScriptResult_SponsorFee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_SponsorFee& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_SponsorFee* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_SponsorFee*>(
               &_InvokeScriptResult_SponsorFee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InvokeScriptResult_SponsorFee& a, InvokeScriptResult_SponsorFee& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_SponsorFee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_SponsorFee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_SponsorFee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_SponsorFee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_SponsorFee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_SponsorFee& from) {
    InvokeScriptResult_SponsorFee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_SponsorFee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.SponsorFee";
  }
  protected:
  explicit InvokeScriptResult_SponsorFee(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFeeFieldNumber = 1,
  };
  // .vrp.Amount min_fee = 1;
  bool has_min_fee() const;
  private:
  bool _internal_has_min_fee() const;
  public:
  void clear_min_fee();
  const ::vrp::Amount& min_fee() const;
  PROTOBUF_NODISCARD ::vrp::Amount* release_min_fee();
  ::vrp::Amount* mutable_min_fee();
  void set_allocated_min_fee(::vrp::Amount* min_fee);
  private:
  const ::vrp::Amount& _internal_min_fee() const;
  ::vrp::Amount* _internal_mutable_min_fee();
  public:
  void unsafe_arena_set_allocated_min_fee(
      ::vrp::Amount* min_fee);
  ::vrp::Amount* unsafe_arena_release_min_fee();

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.SponsorFee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vrp::Amount* min_fee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Lease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Lease) */ {
 public:
  inline InvokeScriptResult_Lease() : InvokeScriptResult_Lease(nullptr) {}
  ~InvokeScriptResult_Lease() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Lease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Lease(const InvokeScriptResult_Lease& from);
  InvokeScriptResult_Lease(InvokeScriptResult_Lease&& from) noexcept
    : InvokeScriptResult_Lease() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Lease& operator=(const InvokeScriptResult_Lease& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Lease& operator=(InvokeScriptResult_Lease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Lease& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Lease* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Lease*>(
               &_InvokeScriptResult_Lease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InvokeScriptResult_Lease& a, InvokeScriptResult_Lease& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Lease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Lease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Lease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Lease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Lease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Lease& from) {
    InvokeScriptResult_Lease::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Lease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Lease";
  }
  protected:
  explicit InvokeScriptResult_Lease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseIdFieldNumber = 4,
    kRecipientFieldNumber = 1,
    kAmountFieldNumber = 2,
    kNonceFieldNumber = 3,
  };
  // bytes lease_id = 4;
  void clear_lease_id();
  const std::string& lease_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lease_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lease_id();
  PROTOBUF_NODISCARD std::string* release_lease_id();
  void set_allocated_lease_id(std::string* lease_id);
  private:
  const std::string& _internal_lease_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lease_id(const std::string& value);
  std::string* _internal_mutable_lease_id();
  public:

  // .vrp.Recipient recipient = 1;
  bool has_recipient() const;
  private:
  bool _internal_has_recipient() const;
  public:
  void clear_recipient();
  const ::vrp::Recipient& recipient() const;
  PROTOBUF_NODISCARD ::vrp::Recipient* release_recipient();
  ::vrp::Recipient* mutable_recipient();
  void set_allocated_recipient(::vrp::Recipient* recipient);
  private:
  const ::vrp::Recipient& _internal_recipient() const;
  ::vrp::Recipient* _internal_mutable_recipient();
  public:
  void unsafe_arena_set_allocated_recipient(
      ::vrp::Recipient* recipient);
  ::vrp::Recipient* unsafe_arena_release_recipient();

  // int64 amount = 2;
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // int64 nonce = 3;
  void clear_nonce();
  int64_t nonce() const;
  void set_nonce(int64_t value);
  private:
  int64_t _internal_nonce() const;
  void _internal_set_nonce(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Lease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lease_id_;
    ::vrp::Recipient* recipient_;
    int64_t amount_;
    int64_t nonce_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_LeaseCancel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.LeaseCancel) */ {
 public:
  inline InvokeScriptResult_LeaseCancel() : InvokeScriptResult_LeaseCancel(nullptr) {}
  ~InvokeScriptResult_LeaseCancel() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_LeaseCancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_LeaseCancel(const InvokeScriptResult_LeaseCancel& from);
  InvokeScriptResult_LeaseCancel(InvokeScriptResult_LeaseCancel&& from) noexcept
    : InvokeScriptResult_LeaseCancel() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_LeaseCancel& operator=(const InvokeScriptResult_LeaseCancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_LeaseCancel& operator=(InvokeScriptResult_LeaseCancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_LeaseCancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_LeaseCancel* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_LeaseCancel*>(
               &_InvokeScriptResult_LeaseCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InvokeScriptResult_LeaseCancel& a, InvokeScriptResult_LeaseCancel& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_LeaseCancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_LeaseCancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_LeaseCancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_LeaseCancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_LeaseCancel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_LeaseCancel& from) {
    InvokeScriptResult_LeaseCancel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_LeaseCancel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.LeaseCancel";
  }
  protected:
  explicit InvokeScriptResult_LeaseCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseIdFieldNumber = 1,
  };
  // bytes lease_id = 1;
  void clear_lease_id();
  const std::string& lease_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lease_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lease_id();
  PROTOBUF_NODISCARD std::string* release_lease_id();
  void set_allocated_lease_id(std::string* lease_id);
  private:
  const std::string& _internal_lease_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lease_id(const std::string& value);
  std::string* _internal_mutable_lease_id();
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.LeaseCancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lease_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_ErrorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.ErrorMessage) */ {
 public:
  inline InvokeScriptResult_ErrorMessage() : InvokeScriptResult_ErrorMessage(nullptr) {}
  ~InvokeScriptResult_ErrorMessage() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_ErrorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_ErrorMessage(const InvokeScriptResult_ErrorMessage& from);
  InvokeScriptResult_ErrorMessage(InvokeScriptResult_ErrorMessage&& from) noexcept
    : InvokeScriptResult_ErrorMessage() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_ErrorMessage& operator=(const InvokeScriptResult_ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_ErrorMessage& operator=(InvokeScriptResult_ErrorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_ErrorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_ErrorMessage*>(
               &_InvokeScriptResult_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InvokeScriptResult_ErrorMessage& a, InvokeScriptResult_ErrorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_ErrorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_ErrorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_ErrorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_ErrorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_ErrorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_ErrorMessage& from) {
    InvokeScriptResult_ErrorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_ErrorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.ErrorMessage";
  }
  protected:
  explicit InvokeScriptResult_ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.ErrorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Call_Argument_List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Call.Argument.List) */ {
 public:
  inline InvokeScriptResult_Call_Argument_List() : InvokeScriptResult_Call_Argument_List(nullptr) {}
  ~InvokeScriptResult_Call_Argument_List() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Call_Argument_List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Call_Argument_List(const InvokeScriptResult_Call_Argument_List& from);
  InvokeScriptResult_Call_Argument_List(InvokeScriptResult_Call_Argument_List&& from) noexcept
    : InvokeScriptResult_Call_Argument_List() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Call_Argument_List& operator=(const InvokeScriptResult_Call_Argument_List& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Call_Argument_List& operator=(InvokeScriptResult_Call_Argument_List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Call_Argument_List& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Call_Argument_List* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Call_Argument_List*>(
               &_InvokeScriptResult_Call_Argument_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InvokeScriptResult_Call_Argument_List& a, InvokeScriptResult_Call_Argument_List& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Call_Argument_List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Call_Argument_List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Call_Argument_List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Call_Argument_List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Call_Argument_List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Call_Argument_List& from) {
    InvokeScriptResult_Call_Argument_List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Call_Argument_List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Call.Argument.List";
  }
  protected:
  explicit InvokeScriptResult_Call_Argument_List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .vrp.InvokeScriptResult.Call.Argument items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::vrp::InvokeScriptResult_Call_Argument* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >*
      mutable_items();
  private:
  const ::vrp::InvokeScriptResult_Call_Argument& _internal_items(int index) const;
  ::vrp::InvokeScriptResult_Call_Argument* _internal_add_items();
  public:
  const ::vrp::InvokeScriptResult_Call_Argument& items(int index) const;
  ::vrp::InvokeScriptResult_Call_Argument* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >&
      items() const;

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Call.Argument.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Call_Argument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Call.Argument) */ {
 public:
  inline InvokeScriptResult_Call_Argument() : InvokeScriptResult_Call_Argument(nullptr) {}
  ~InvokeScriptResult_Call_Argument() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Call_Argument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Call_Argument(const InvokeScriptResult_Call_Argument& from);
  InvokeScriptResult_Call_Argument(InvokeScriptResult_Call_Argument&& from) noexcept
    : InvokeScriptResult_Call_Argument() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Call_Argument& operator=(const InvokeScriptResult_Call_Argument& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Call_Argument& operator=(InvokeScriptResult_Call_Argument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Call_Argument& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kIntegerValue = 1,
    kBinaryValue = 2,
    kStringValue = 3,
    kBooleanValue = 4,
    kCaseObj = 5,
    kList = 10,
    VALUE_NOT_SET = 0,
  };

  static inline const InvokeScriptResult_Call_Argument* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Call_Argument*>(
               &_InvokeScriptResult_Call_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InvokeScriptResult_Call_Argument& a, InvokeScriptResult_Call_Argument& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Call_Argument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Call_Argument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Call_Argument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Call_Argument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Call_Argument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Call_Argument& from) {
    InvokeScriptResult_Call_Argument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Call_Argument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Call.Argument";
  }
  protected:
  explicit InvokeScriptResult_Call_Argument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InvokeScriptResult_Call_Argument_List List;

  // accessors -------------------------------------------------------

  enum : int {
    kIntegerValueFieldNumber = 1,
    kBinaryValueFieldNumber = 2,
    kStringValueFieldNumber = 3,
    kBooleanValueFieldNumber = 4,
    kCaseObjFieldNumber = 5,
    kListFieldNumber = 10,
  };
  // int64 integer_value = 1;
  bool has_integer_value() const;
  private:
  bool _internal_has_integer_value() const;
  public:
  void clear_integer_value();
  int64_t integer_value() const;
  void set_integer_value(int64_t value);
  private:
  int64_t _internal_integer_value() const;
  void _internal_set_integer_value(int64_t value);
  public:

  // bytes binary_value = 2;
  bool has_binary_value() const;
  private:
  bool _internal_has_binary_value() const;
  public:
  void clear_binary_value();
  const std::string& binary_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_value();
  PROTOBUF_NODISCARD std::string* release_binary_value();
  void set_allocated_binary_value(std::string* binary_value);
  private:
  const std::string& _internal_binary_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_value(const std::string& value);
  std::string* _internal_mutable_binary_value();
  public:

  // string string_value = 3;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // bool boolean_value = 4;
  bool has_boolean_value() const;
  private:
  bool _internal_has_boolean_value() const;
  public:
  void clear_boolean_value();
  bool boolean_value() const;
  void set_boolean_value(bool value);
  private:
  bool _internal_boolean_value() const;
  void _internal_set_boolean_value(bool value);
  public:

  // bytes case_obj = 5;
  bool has_case_obj() const;
  private:
  bool _internal_has_case_obj() const;
  public:
  void clear_case_obj();
  const std::string& case_obj() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_case_obj(ArgT0&& arg0, ArgT... args);
  std::string* mutable_case_obj();
  PROTOBUF_NODISCARD std::string* release_case_obj();
  void set_allocated_case_obj(std::string* case_obj);
  private:
  const std::string& _internal_case_obj() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_case_obj(const std::string& value);
  std::string* _internal_mutable_case_obj();
  public:

  // .vrp.InvokeScriptResult.Call.Argument.List list = 10;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::vrp::InvokeScriptResult_Call_Argument_List& list() const;
  PROTOBUF_NODISCARD ::vrp::InvokeScriptResult_Call_Argument_List* release_list();
  ::vrp::InvokeScriptResult_Call_Argument_List* mutable_list();
  void set_allocated_list(::vrp::InvokeScriptResult_Call_Argument_List* list);
  private:
  const ::vrp::InvokeScriptResult_Call_Argument_List& _internal_list() const;
  ::vrp::InvokeScriptResult_Call_Argument_List* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::vrp::InvokeScriptResult_Call_Argument_List* list);
  ::vrp::InvokeScriptResult_Call_Argument_List* unsafe_arena_release_list();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Call.Argument)
 private:
  class _Internal;
  void set_has_integer_value();
  void set_has_binary_value();
  void set_has_string_value();
  void set_has_boolean_value();
  void set_has_case_obj();
  void set_has_list();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t integer_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
      bool boolean_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr case_obj_;
      ::vrp::InvokeScriptResult_Call_Argument_List* list_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Call final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Call) */ {
 public:
  inline InvokeScriptResult_Call() : InvokeScriptResult_Call(nullptr) {}
  ~InvokeScriptResult_Call() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Call(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Call(const InvokeScriptResult_Call& from);
  InvokeScriptResult_Call(InvokeScriptResult_Call&& from) noexcept
    : InvokeScriptResult_Call() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Call& operator=(const InvokeScriptResult_Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Call& operator=(InvokeScriptResult_Call&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Call& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Call* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Call*>(
               &_InvokeScriptResult_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InvokeScriptResult_Call& a, InvokeScriptResult_Call& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Call* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Call>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Call& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Call& from) {
    InvokeScriptResult_Call::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Call* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Call";
  }
  protected:
  explicit InvokeScriptResult_Call(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InvokeScriptResult_Call_Argument Argument;

  // accessors -------------------------------------------------------

  enum : int {
    kArgsBytesFieldNumber = 2,
    kArgsFieldNumber = 3,
    kFunctionFieldNumber = 1,
  };
  // repeated bytes args_bytes = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int args_bytes_size() const;
  private:
  int _internal_args_bytes_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_args_bytes();
  PROTOBUF_DEPRECATED const std::string& args_bytes(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_args_bytes(int index);
  PROTOBUF_DEPRECATED void set_args_bytes(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_args_bytes(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_args_bytes(int index, const char* value);
  PROTOBUF_DEPRECATED void set_args_bytes(int index, const void* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_args_bytes();
  PROTOBUF_DEPRECATED void add_args_bytes(const std::string& value);
  PROTOBUF_DEPRECATED void add_args_bytes(std::string&& value);
  PROTOBUF_DEPRECATED void add_args_bytes(const char* value);
  PROTOBUF_DEPRECATED void add_args_bytes(const void* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args_bytes() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args_bytes();
  private:
  const std::string& _internal_args_bytes(int index) const;
  std::string* _internal_add_args_bytes();
  public:

  // repeated .vrp.InvokeScriptResult.Call.Argument args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::vrp::InvokeScriptResult_Call_Argument* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >*
      mutable_args();
  private:
  const ::vrp::InvokeScriptResult_Call_Argument& _internal_args(int index) const;
  ::vrp::InvokeScriptResult_Call_Argument* _internal_add_args();
  public:
  const ::vrp::InvokeScriptResult_Call_Argument& args(int index) const;
  ::vrp::InvokeScriptResult_Call_Argument* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >&
      args() const;

  // string function = 1;
  void clear_function();
  const std::string& function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function();
  PROTOBUF_NODISCARD std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_bytes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult_Invocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult.Invocation) */ {
 public:
  inline InvokeScriptResult_Invocation() : InvokeScriptResult_Invocation(nullptr) {}
  ~InvokeScriptResult_Invocation() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult_Invocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult_Invocation(const InvokeScriptResult_Invocation& from);
  InvokeScriptResult_Invocation(InvokeScriptResult_Invocation&& from) noexcept
    : InvokeScriptResult_Invocation() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult_Invocation& operator=(const InvokeScriptResult_Invocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult_Invocation& operator=(InvokeScriptResult_Invocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult_Invocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult_Invocation* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult_Invocation*>(
               &_InvokeScriptResult_Invocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InvokeScriptResult_Invocation& a, InvokeScriptResult_Invocation& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult_Invocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult_Invocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult_Invocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult_Invocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult_Invocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult_Invocation& from) {
    InvokeScriptResult_Invocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult_Invocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult.Invocation";
  }
  protected:
  explicit InvokeScriptResult_Invocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaymentsFieldNumber = 3,
    kDAppFieldNumber = 1,
    kCallFieldNumber = 2,
    kStateChangesFieldNumber = 4,
  };
  // repeated .vrp.Amount payments = 3;
  int payments_size() const;
  private:
  int _internal_payments_size() const;
  public:
  void clear_payments();
  ::vrp::Amount* mutable_payments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >*
      mutable_payments();
  private:
  const ::vrp::Amount& _internal_payments(int index) const;
  ::vrp::Amount* _internal_add_payments();
  public:
  const ::vrp::Amount& payments(int index) const;
  ::vrp::Amount* add_payments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >&
      payments() const;

  // bytes dApp = 1;
  void clear_dapp();
  const std::string& dapp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dapp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dapp();
  PROTOBUF_NODISCARD std::string* release_dapp();
  void set_allocated_dapp(std::string* dapp);
  private:
  const std::string& _internal_dapp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dapp(const std::string& value);
  std::string* _internal_mutable_dapp();
  public:

  // .vrp.InvokeScriptResult.Call call = 2;
  bool has_call() const;
  private:
  bool _internal_has_call() const;
  public:
  void clear_call();
  const ::vrp::InvokeScriptResult_Call& call() const;
  PROTOBUF_NODISCARD ::vrp::InvokeScriptResult_Call* release_call();
  ::vrp::InvokeScriptResult_Call* mutable_call();
  void set_allocated_call(::vrp::InvokeScriptResult_Call* call);
  private:
  const ::vrp::InvokeScriptResult_Call& _internal_call() const;
  ::vrp::InvokeScriptResult_Call* _internal_mutable_call();
  public:
  void unsafe_arena_set_allocated_call(
      ::vrp::InvokeScriptResult_Call* call);
  ::vrp::InvokeScriptResult_Call* unsafe_arena_release_call();

  // .vrp.InvokeScriptResult stateChanges = 4;
  bool has_statechanges() const;
  private:
  bool _internal_has_statechanges() const;
  public:
  void clear_statechanges();
  const ::vrp::InvokeScriptResult& statechanges() const;
  PROTOBUF_NODISCARD ::vrp::InvokeScriptResult* release_statechanges();
  ::vrp::InvokeScriptResult* mutable_statechanges();
  void set_allocated_statechanges(::vrp::InvokeScriptResult* statechanges);
  private:
  const ::vrp::InvokeScriptResult& _internal_statechanges() const;
  ::vrp::InvokeScriptResult* _internal_mutable_statechanges();
  public:
  void unsafe_arena_set_allocated_statechanges(
      ::vrp::InvokeScriptResult* statechanges);
  ::vrp::InvokeScriptResult* unsafe_arena_release_statechanges();

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult.Invocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount > payments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dapp_;
    ::vrp::InvokeScriptResult_Call* call_;
    ::vrp::InvokeScriptResult* statechanges_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// -------------------------------------------------------------------

class InvokeScriptResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vrp.InvokeScriptResult) */ {
 public:
  inline InvokeScriptResult() : InvokeScriptResult(nullptr) {}
  ~InvokeScriptResult() override;
  explicit PROTOBUF_CONSTEXPR InvokeScriptResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeScriptResult(const InvokeScriptResult& from);
  InvokeScriptResult(InvokeScriptResult&& from) noexcept
    : InvokeScriptResult() {
    *this = ::std::move(from);
  }

  inline InvokeScriptResult& operator=(const InvokeScriptResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeScriptResult& operator=(InvokeScriptResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeScriptResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeScriptResult* internal_default_instance() {
    return reinterpret_cast<const InvokeScriptResult*>(
               &_InvokeScriptResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(InvokeScriptResult& a, InvokeScriptResult& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeScriptResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeScriptResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeScriptResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeScriptResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeScriptResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeScriptResult& from) {
    InvokeScriptResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeScriptResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vrp.InvokeScriptResult";
  }
  protected:
  explicit InvokeScriptResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InvokeScriptResult_Payment Payment;
  typedef InvokeScriptResult_PrivatePayment PrivatePayment;
  typedef InvokeScriptResult_Issue Issue;
  typedef InvokeScriptResult_Reissue Reissue;
  typedef InvokeScriptResult_Burn Burn;
  typedef InvokeScriptResult_SponsorFee SponsorFee;
  typedef InvokeScriptResult_Lease Lease;
  typedef InvokeScriptResult_LeaseCancel LeaseCancel;
  typedef InvokeScriptResult_ErrorMessage ErrorMessage;
  typedef InvokeScriptResult_Call Call;
  typedef InvokeScriptResult_Invocation Invocation;

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kTransfersFieldNumber = 2,
    kIssuesFieldNumber = 3,
    kReissuesFieldNumber = 4,
    kBurnsFieldNumber = 5,
    kSponsorFeesFieldNumber = 7,
    kLeasesFieldNumber = 8,
    kLeaseCancelsFieldNumber = 9,
    kInvokesFieldNumber = 10,
    kPrivatePaymentFieldNumber = 11,
    kErrorMessageFieldNumber = 6,
  };
  // repeated .vrp.DataTransactionData.DataEntry data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::vrp::DataTransactionData_DataEntry* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >*
      mutable_data();
  private:
  const ::vrp::DataTransactionData_DataEntry& _internal_data(int index) const;
  ::vrp::DataTransactionData_DataEntry* _internal_add_data();
  public:
  const ::vrp::DataTransactionData_DataEntry& data(int index) const;
  ::vrp::DataTransactionData_DataEntry* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >&
      data() const;

  // repeated .vrp.InvokeScriptResult.Payment transfers = 2;
  int transfers_size() const;
  private:
  int _internal_transfers_size() const;
  public:
  void clear_transfers();
  ::vrp::InvokeScriptResult_Payment* mutable_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Payment >*
      mutable_transfers();
  private:
  const ::vrp::InvokeScriptResult_Payment& _internal_transfers(int index) const;
  ::vrp::InvokeScriptResult_Payment* _internal_add_transfers();
  public:
  const ::vrp::InvokeScriptResult_Payment& transfers(int index) const;
  ::vrp::InvokeScriptResult_Payment* add_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Payment >&
      transfers() const;

  // repeated .vrp.InvokeScriptResult.Issue issues = 3;
  int issues_size() const;
  private:
  int _internal_issues_size() const;
  public:
  void clear_issues();
  ::vrp::InvokeScriptResult_Issue* mutable_issues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Issue >*
      mutable_issues();
  private:
  const ::vrp::InvokeScriptResult_Issue& _internal_issues(int index) const;
  ::vrp::InvokeScriptResult_Issue* _internal_add_issues();
  public:
  const ::vrp::InvokeScriptResult_Issue& issues(int index) const;
  ::vrp::InvokeScriptResult_Issue* add_issues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Issue >&
      issues() const;

  // repeated .vrp.InvokeScriptResult.Reissue reissues = 4;
  int reissues_size() const;
  private:
  int _internal_reissues_size() const;
  public:
  void clear_reissues();
  ::vrp::InvokeScriptResult_Reissue* mutable_reissues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Reissue >*
      mutable_reissues();
  private:
  const ::vrp::InvokeScriptResult_Reissue& _internal_reissues(int index) const;
  ::vrp::InvokeScriptResult_Reissue* _internal_add_reissues();
  public:
  const ::vrp::InvokeScriptResult_Reissue& reissues(int index) const;
  ::vrp::InvokeScriptResult_Reissue* add_reissues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Reissue >&
      reissues() const;

  // repeated .vrp.InvokeScriptResult.Burn burns = 5;
  int burns_size() const;
  private:
  int _internal_burns_size() const;
  public:
  void clear_burns();
  ::vrp::InvokeScriptResult_Burn* mutable_burns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Burn >*
      mutable_burns();
  private:
  const ::vrp::InvokeScriptResult_Burn& _internal_burns(int index) const;
  ::vrp::InvokeScriptResult_Burn* _internal_add_burns();
  public:
  const ::vrp::InvokeScriptResult_Burn& burns(int index) const;
  ::vrp::InvokeScriptResult_Burn* add_burns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Burn >&
      burns() const;

  // repeated .vrp.InvokeScriptResult.SponsorFee sponsor_fees = 7;
  int sponsor_fees_size() const;
  private:
  int _internal_sponsor_fees_size() const;
  public:
  void clear_sponsor_fees();
  ::vrp::InvokeScriptResult_SponsorFee* mutable_sponsor_fees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_SponsorFee >*
      mutable_sponsor_fees();
  private:
  const ::vrp::InvokeScriptResult_SponsorFee& _internal_sponsor_fees(int index) const;
  ::vrp::InvokeScriptResult_SponsorFee* _internal_add_sponsor_fees();
  public:
  const ::vrp::InvokeScriptResult_SponsorFee& sponsor_fees(int index) const;
  ::vrp::InvokeScriptResult_SponsorFee* add_sponsor_fees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_SponsorFee >&
      sponsor_fees() const;

  // repeated .vrp.InvokeScriptResult.Lease leases = 8;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::vrp::InvokeScriptResult_Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Lease >*
      mutable_leases();
  private:
  const ::vrp::InvokeScriptResult_Lease& _internal_leases(int index) const;
  ::vrp::InvokeScriptResult_Lease* _internal_add_leases();
  public:
  const ::vrp::InvokeScriptResult_Lease& leases(int index) const;
  ::vrp::InvokeScriptResult_Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Lease >&
      leases() const;

  // repeated .vrp.InvokeScriptResult.LeaseCancel lease_cancels = 9;
  int lease_cancels_size() const;
  private:
  int _internal_lease_cancels_size() const;
  public:
  void clear_lease_cancels();
  ::vrp::InvokeScriptResult_LeaseCancel* mutable_lease_cancels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_LeaseCancel >*
      mutable_lease_cancels();
  private:
  const ::vrp::InvokeScriptResult_LeaseCancel& _internal_lease_cancels(int index) const;
  ::vrp::InvokeScriptResult_LeaseCancel* _internal_add_lease_cancels();
  public:
  const ::vrp::InvokeScriptResult_LeaseCancel& lease_cancels(int index) const;
  ::vrp::InvokeScriptResult_LeaseCancel* add_lease_cancels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_LeaseCancel >&
      lease_cancels() const;

  // repeated .vrp.InvokeScriptResult.Invocation invokes = 10;
  int invokes_size() const;
  private:
  int _internal_invokes_size() const;
  public:
  void clear_invokes();
  ::vrp::InvokeScriptResult_Invocation* mutable_invokes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Invocation >*
      mutable_invokes();
  private:
  const ::vrp::InvokeScriptResult_Invocation& _internal_invokes(int index) const;
  ::vrp::InvokeScriptResult_Invocation* _internal_add_invokes();
  public:
  const ::vrp::InvokeScriptResult_Invocation& invokes(int index) const;
  ::vrp::InvokeScriptResult_Invocation* add_invokes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Invocation >&
      invokes() const;

  // repeated .vrp.InvokeScriptResult.PrivatePayment private_payment = 11;
  int private_payment_size() const;
  private:
  int _internal_private_payment_size() const;
  public:
  void clear_private_payment();
  ::vrp::InvokeScriptResult_PrivatePayment* mutable_private_payment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_PrivatePayment >*
      mutable_private_payment();
  private:
  const ::vrp::InvokeScriptResult_PrivatePayment& _internal_private_payment(int index) const;
  ::vrp::InvokeScriptResult_PrivatePayment* _internal_add_private_payment();
  public:
  const ::vrp::InvokeScriptResult_PrivatePayment& private_payment(int index) const;
  ::vrp::InvokeScriptResult_PrivatePayment* add_private_payment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_PrivatePayment >&
      private_payment() const;

  // .vrp.InvokeScriptResult.ErrorMessage error_message = 6;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const ::vrp::InvokeScriptResult_ErrorMessage& error_message() const;
  PROTOBUF_NODISCARD ::vrp::InvokeScriptResult_ErrorMessage* release_error_message();
  ::vrp::InvokeScriptResult_ErrorMessage* mutable_error_message();
  void set_allocated_error_message(::vrp::InvokeScriptResult_ErrorMessage* error_message);
  private:
  const ::vrp::InvokeScriptResult_ErrorMessage& _internal_error_message() const;
  ::vrp::InvokeScriptResult_ErrorMessage* _internal_mutable_error_message();
  public:
  void unsafe_arena_set_allocated_error_message(
      ::vrp::InvokeScriptResult_ErrorMessage* error_message);
  ::vrp::InvokeScriptResult_ErrorMessage* unsafe_arena_release_error_message();

  // @@protoc_insertion_point(class_scope:vrp.InvokeScriptResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry > data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Payment > transfers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Issue > issues_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Reissue > reissues_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Burn > burns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_SponsorFee > sponsor_fees_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Lease > leases_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_LeaseCancel > lease_cancels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Invocation > invokes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_PrivatePayment > private_payment_;
    ::vrp::InvokeScriptResult_ErrorMessage* error_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vrp_2finvoke_5fscript_5fresult_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InvokeScriptResult_Payment

// bytes address = 1;
inline void InvokeScriptResult_Payment::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Payment::address() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Payment.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Payment::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Payment.address)
}
inline std::string* InvokeScriptResult_Payment::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Payment.address)
  return _s;
}
inline const std::string& InvokeScriptResult_Payment::_internal_address() const {
  return _impl_.address_.Get();
}
inline void InvokeScriptResult_Payment::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Payment::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Payment::release_address() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Payment.address)
  return _impl_.address_.Release();
}
inline void InvokeScriptResult_Payment::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Payment.address)
}

// .vrp.Amount amount = 2;
inline bool InvokeScriptResult_Payment::_internal_has_amount() const {
  return this != internal_default_instance() && _impl_.amount_ != nullptr;
}
inline bool InvokeScriptResult_Payment::has_amount() const {
  return _internal_has_amount();
}
inline const ::vrp::Amount& InvokeScriptResult_Payment::_internal_amount() const {
  const ::vrp::Amount* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& InvokeScriptResult_Payment::amount() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Payment.amount)
  return _internal_amount();
}
inline void InvokeScriptResult_Payment::unsafe_arena_set_allocated_amount(
    ::vrp::Amount* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.Payment.amount)
}
inline ::vrp::Amount* InvokeScriptResult_Payment::release_amount() {
  
  ::vrp::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* InvokeScriptResult_Payment::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Payment.amount)
  
  ::vrp::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::vrp::Amount* InvokeScriptResult_Payment::_internal_mutable_amount() {
  
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::vrp::Amount* InvokeScriptResult_Payment::mutable_amount() {
  ::vrp::Amount* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Payment.amount)
  return _msg;
}
inline void InvokeScriptResult_Payment::set_allocated_amount(::vrp::Amount* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Payment.amount)
}

// -------------------------------------------------------------------

// InvokeScriptResult_PrivatePayment

// bytes address = 1;
inline void InvokeScriptResult_PrivatePayment::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_PrivatePayment::address() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.PrivatePayment.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_PrivatePayment::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.PrivatePayment.address)
}
inline std::string* InvokeScriptResult_PrivatePayment::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.PrivatePayment.address)
  return _s;
}
inline const std::string& InvokeScriptResult_PrivatePayment::_internal_address() const {
  return _impl_.address_.Get();
}
inline void InvokeScriptResult_PrivatePayment::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_PrivatePayment::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_PrivatePayment::release_address() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.PrivatePayment.address)
  return _impl_.address_.Release();
}
inline void InvokeScriptResult_PrivatePayment::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.PrivatePayment.address)
}

// .vrp.Amount amount = 2;
inline bool InvokeScriptResult_PrivatePayment::_internal_has_amount() const {
  return this != internal_default_instance() && _impl_.amount_ != nullptr;
}
inline bool InvokeScriptResult_PrivatePayment::has_amount() const {
  return _internal_has_amount();
}
inline const ::vrp::Amount& InvokeScriptResult_PrivatePayment::_internal_amount() const {
  const ::vrp::Amount* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& InvokeScriptResult_PrivatePayment::amount() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.PrivatePayment.amount)
  return _internal_amount();
}
inline void InvokeScriptResult_PrivatePayment::unsafe_arena_set_allocated_amount(
    ::vrp::Amount* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.PrivatePayment.amount)
}
inline ::vrp::Amount* InvokeScriptResult_PrivatePayment::release_amount() {
  
  ::vrp::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* InvokeScriptResult_PrivatePayment::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.PrivatePayment.amount)
  
  ::vrp::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::vrp::Amount* InvokeScriptResult_PrivatePayment::_internal_mutable_amount() {
  
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::vrp::Amount* InvokeScriptResult_PrivatePayment::mutable_amount() {
  ::vrp::Amount* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.PrivatePayment.amount)
  return _msg;
}
inline void InvokeScriptResult_PrivatePayment::set_allocated_amount(::vrp::Amount* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount));
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.PrivatePayment.amount)
}

// -------------------------------------------------------------------

// InvokeScriptResult_Issue

// bytes asset_id = 1;
inline void InvokeScriptResult_Issue::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Issue::asset_id() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Issue::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.asset_id)
}
inline std::string* InvokeScriptResult_Issue::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Issue.asset_id)
  return _s;
}
inline const std::string& InvokeScriptResult_Issue::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void InvokeScriptResult_Issue::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::release_asset_id() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Issue.asset_id)
  return _impl_.asset_id_.Release();
}
inline void InvokeScriptResult_Issue::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Issue.asset_id)
}

// string name = 2;
inline void InvokeScriptResult_Issue::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Issue::name() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Issue::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.name)
}
inline std::string* InvokeScriptResult_Issue::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Issue.name)
  return _s;
}
inline const std::string& InvokeScriptResult_Issue::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InvokeScriptResult_Issue::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::release_name() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Issue.name)
  return _impl_.name_.Release();
}
inline void InvokeScriptResult_Issue::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Issue.name)
}

// string description = 3;
inline void InvokeScriptResult_Issue::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Issue::description() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Issue::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.description)
}
inline std::string* InvokeScriptResult_Issue::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Issue.description)
  return _s;
}
inline const std::string& InvokeScriptResult_Issue::_internal_description() const {
  return _impl_.description_.Get();
}
inline void InvokeScriptResult_Issue::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::release_description() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Issue.description)
  return _impl_.description_.Release();
}
inline void InvokeScriptResult_Issue::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Issue.description)
}

// string image = 4;
inline void InvokeScriptResult_Issue::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Issue::image() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Issue::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.image)
}
inline std::string* InvokeScriptResult_Issue::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Issue.image)
  return _s;
}
inline const std::string& InvokeScriptResult_Issue::_internal_image() const {
  return _impl_.image_.Get();
}
inline void InvokeScriptResult_Issue::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::release_image() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Issue.image)
  return _impl_.image_.Release();
}
inline void InvokeScriptResult_Issue::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Issue.image)
}

// int64 amount = 5;
inline void InvokeScriptResult_Issue::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t InvokeScriptResult_Issue::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t InvokeScriptResult_Issue::amount() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.amount)
  return _internal_amount();
}
inline void InvokeScriptResult_Issue::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void InvokeScriptResult_Issue::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.amount)
}

// int32 decimals = 6;
inline void InvokeScriptResult_Issue::clear_decimals() {
  _impl_.decimals_ = 0;
}
inline int32_t InvokeScriptResult_Issue::_internal_decimals() const {
  return _impl_.decimals_;
}
inline int32_t InvokeScriptResult_Issue::decimals() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.decimals)
  return _internal_decimals();
}
inline void InvokeScriptResult_Issue::_internal_set_decimals(int32_t value) {
  
  _impl_.decimals_ = value;
}
inline void InvokeScriptResult_Issue::set_decimals(int32_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.decimals)
}

// bool reissuable = 7;
inline void InvokeScriptResult_Issue::clear_reissuable() {
  _impl_.reissuable_ = false;
}
inline bool InvokeScriptResult_Issue::_internal_reissuable() const {
  return _impl_.reissuable_;
}
inline bool InvokeScriptResult_Issue::reissuable() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.reissuable)
  return _internal_reissuable();
}
inline void InvokeScriptResult_Issue::_internal_set_reissuable(bool value) {
  
  _impl_.reissuable_ = value;
}
inline void InvokeScriptResult_Issue::set_reissuable(bool value) {
  _internal_set_reissuable(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.reissuable)
}

// bytes script = 8;
inline void InvokeScriptResult_Issue::clear_script() {
  _impl_.script_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Issue::script() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Issue::set_script(ArgT0&& arg0, ArgT... args) {
 
 _impl_.script_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.script)
}
inline std::string* InvokeScriptResult_Issue::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Issue.script)
  return _s;
}
inline const std::string& InvokeScriptResult_Issue::_internal_script() const {
  return _impl_.script_.Get();
}
inline void InvokeScriptResult_Issue::_internal_set_script(const std::string& value) {
  
  _impl_.script_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::_internal_mutable_script() {
  
  return _impl_.script_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Issue::release_script() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Issue.script)
  return _impl_.script_.Release();
}
inline void InvokeScriptResult_Issue::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  _impl_.script_.SetAllocated(script, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.script_.IsDefault()) {
    _impl_.script_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Issue.script)
}

// int64 nonce = 9;
inline void InvokeScriptResult_Issue::clear_nonce() {
  _impl_.nonce_ = int64_t{0};
}
inline int64_t InvokeScriptResult_Issue::_internal_nonce() const {
  return _impl_.nonce_;
}
inline int64_t InvokeScriptResult_Issue::nonce() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Issue.nonce)
  return _internal_nonce();
}
inline void InvokeScriptResult_Issue::_internal_set_nonce(int64_t value) {
  
  _impl_.nonce_ = value;
}
inline void InvokeScriptResult_Issue::set_nonce(int64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Issue.nonce)
}

// -------------------------------------------------------------------

// InvokeScriptResult_Reissue

// bytes asset_id = 1;
inline void InvokeScriptResult_Reissue::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Reissue::asset_id() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Reissue.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Reissue::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Reissue.asset_id)
}
inline std::string* InvokeScriptResult_Reissue::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Reissue.asset_id)
  return _s;
}
inline const std::string& InvokeScriptResult_Reissue::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void InvokeScriptResult_Reissue::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Reissue::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Reissue::release_asset_id() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Reissue.asset_id)
  return _impl_.asset_id_.Release();
}
inline void InvokeScriptResult_Reissue::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Reissue.asset_id)
}

// int64 amount = 2;
inline void InvokeScriptResult_Reissue::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t InvokeScriptResult_Reissue::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t InvokeScriptResult_Reissue::amount() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Reissue.amount)
  return _internal_amount();
}
inline void InvokeScriptResult_Reissue::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void InvokeScriptResult_Reissue::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Reissue.amount)
}

// bool is_reissuable = 3;
inline void InvokeScriptResult_Reissue::clear_is_reissuable() {
  _impl_.is_reissuable_ = false;
}
inline bool InvokeScriptResult_Reissue::_internal_is_reissuable() const {
  return _impl_.is_reissuable_;
}
inline bool InvokeScriptResult_Reissue::is_reissuable() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Reissue.is_reissuable)
  return _internal_is_reissuable();
}
inline void InvokeScriptResult_Reissue::_internal_set_is_reissuable(bool value) {
  
  _impl_.is_reissuable_ = value;
}
inline void InvokeScriptResult_Reissue::set_is_reissuable(bool value) {
  _internal_set_is_reissuable(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Reissue.is_reissuable)
}

// -------------------------------------------------------------------

// InvokeScriptResult_Burn

// bytes asset_id = 1;
inline void InvokeScriptResult_Burn::clear_asset_id() {
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Burn::asset_id() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Burn.asset_id)
  return _internal_asset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Burn::set_asset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Burn.asset_id)
}
inline std::string* InvokeScriptResult_Burn::mutable_asset_id() {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Burn.asset_id)
  return _s;
}
inline const std::string& InvokeScriptResult_Burn::_internal_asset_id() const {
  return _impl_.asset_id_.Get();
}
inline void InvokeScriptResult_Burn::_internal_set_asset_id(const std::string& value) {
  
  _impl_.asset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Burn::_internal_mutable_asset_id() {
  
  return _impl_.asset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Burn::release_asset_id() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Burn.asset_id)
  return _impl_.asset_id_.Release();
}
inline void InvokeScriptResult_Burn::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  _impl_.asset_id_.SetAllocated(asset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_id_.IsDefault()) {
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Burn.asset_id)
}

// int64 amount = 2;
inline void InvokeScriptResult_Burn::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t InvokeScriptResult_Burn::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t InvokeScriptResult_Burn::amount() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Burn.amount)
  return _internal_amount();
}
inline void InvokeScriptResult_Burn::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void InvokeScriptResult_Burn::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Burn.amount)
}

// -------------------------------------------------------------------

// InvokeScriptResult_SponsorFee

// .vrp.Amount min_fee = 1;
inline bool InvokeScriptResult_SponsorFee::_internal_has_min_fee() const {
  return this != internal_default_instance() && _impl_.min_fee_ != nullptr;
}
inline bool InvokeScriptResult_SponsorFee::has_min_fee() const {
  return _internal_has_min_fee();
}
inline const ::vrp::Amount& InvokeScriptResult_SponsorFee::_internal_min_fee() const {
  const ::vrp::Amount* p = _impl_.min_fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Amount&>(
      ::vrp::_Amount_default_instance_);
}
inline const ::vrp::Amount& InvokeScriptResult_SponsorFee::min_fee() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.SponsorFee.min_fee)
  return _internal_min_fee();
}
inline void InvokeScriptResult_SponsorFee::unsafe_arena_set_allocated_min_fee(
    ::vrp::Amount* min_fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_fee_);
  }
  _impl_.min_fee_ = min_fee;
  if (min_fee) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.SponsorFee.min_fee)
}
inline ::vrp::Amount* InvokeScriptResult_SponsorFee::release_min_fee() {
  
  ::vrp::Amount* temp = _impl_.min_fee_;
  _impl_.min_fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Amount* InvokeScriptResult_SponsorFee::unsafe_arena_release_min_fee() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.SponsorFee.min_fee)
  
  ::vrp::Amount* temp = _impl_.min_fee_;
  _impl_.min_fee_ = nullptr;
  return temp;
}
inline ::vrp::Amount* InvokeScriptResult_SponsorFee::_internal_mutable_min_fee() {
  
  if (_impl_.min_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Amount>(GetArenaForAllocation());
    _impl_.min_fee_ = p;
  }
  return _impl_.min_fee_;
}
inline ::vrp::Amount* InvokeScriptResult_SponsorFee::mutable_min_fee() {
  ::vrp::Amount* _msg = _internal_mutable_min_fee();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.SponsorFee.min_fee)
  return _msg;
}
inline void InvokeScriptResult_SponsorFee::set_allocated_min_fee(::vrp::Amount* min_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_fee_);
  }
  if (min_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_fee));
    if (message_arena != submessage_arena) {
      min_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_fee, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_fee_ = min_fee;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.SponsorFee.min_fee)
}

// -------------------------------------------------------------------

// InvokeScriptResult_Lease

// .vrp.Recipient recipient = 1;
inline bool InvokeScriptResult_Lease::_internal_has_recipient() const {
  return this != internal_default_instance() && _impl_.recipient_ != nullptr;
}
inline bool InvokeScriptResult_Lease::has_recipient() const {
  return _internal_has_recipient();
}
inline const ::vrp::Recipient& InvokeScriptResult_Lease::_internal_recipient() const {
  const ::vrp::Recipient* p = _impl_.recipient_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::Recipient&>(
      ::vrp::_Recipient_default_instance_);
}
inline const ::vrp::Recipient& InvokeScriptResult_Lease::recipient() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Lease.recipient)
  return _internal_recipient();
}
inline void InvokeScriptResult_Lease::unsafe_arena_set_allocated_recipient(
    ::vrp::Recipient* recipient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  _impl_.recipient_ = recipient;
  if (recipient) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.Lease.recipient)
}
inline ::vrp::Recipient* InvokeScriptResult_Lease::release_recipient() {
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::Recipient* InvokeScriptResult_Lease::unsafe_arena_release_recipient() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Lease.recipient)
  
  ::vrp::Recipient* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
  return temp;
}
inline ::vrp::Recipient* InvokeScriptResult_Lease::_internal_mutable_recipient() {
  
  if (_impl_.recipient_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::Recipient>(GetArenaForAllocation());
    _impl_.recipient_ = p;
  }
  return _impl_.recipient_;
}
inline ::vrp::Recipient* InvokeScriptResult_Lease::mutable_recipient() {
  ::vrp::Recipient* _msg = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Lease.recipient)
  return _msg;
}
inline void InvokeScriptResult_Lease::set_allocated_recipient(::vrp::Recipient* recipient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recipient_);
  }
  if (recipient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recipient));
    if (message_arena != submessage_arena) {
      recipient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recipient, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recipient_ = recipient;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Lease.recipient)
}

// int64 amount = 2;
inline void InvokeScriptResult_Lease::clear_amount() {
  _impl_.amount_ = int64_t{0};
}
inline int64_t InvokeScriptResult_Lease::_internal_amount() const {
  return _impl_.amount_;
}
inline int64_t InvokeScriptResult_Lease::amount() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Lease.amount)
  return _internal_amount();
}
inline void InvokeScriptResult_Lease::_internal_set_amount(int64_t value) {
  
  _impl_.amount_ = value;
}
inline void InvokeScriptResult_Lease::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Lease.amount)
}

// int64 nonce = 3;
inline void InvokeScriptResult_Lease::clear_nonce() {
  _impl_.nonce_ = int64_t{0};
}
inline int64_t InvokeScriptResult_Lease::_internal_nonce() const {
  return _impl_.nonce_;
}
inline int64_t InvokeScriptResult_Lease::nonce() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Lease.nonce)
  return _internal_nonce();
}
inline void InvokeScriptResult_Lease::_internal_set_nonce(int64_t value) {
  
  _impl_.nonce_ = value;
}
inline void InvokeScriptResult_Lease::set_nonce(int64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Lease.nonce)
}

// bytes lease_id = 4;
inline void InvokeScriptResult_Lease::clear_lease_id() {
  _impl_.lease_id_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Lease::lease_id() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Lease.lease_id)
  return _internal_lease_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Lease::set_lease_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lease_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Lease.lease_id)
}
inline std::string* InvokeScriptResult_Lease::mutable_lease_id() {
  std::string* _s = _internal_mutable_lease_id();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Lease.lease_id)
  return _s;
}
inline const std::string& InvokeScriptResult_Lease::_internal_lease_id() const {
  return _impl_.lease_id_.Get();
}
inline void InvokeScriptResult_Lease::_internal_set_lease_id(const std::string& value) {
  
  _impl_.lease_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Lease::_internal_mutable_lease_id() {
  
  return _impl_.lease_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Lease::release_lease_id() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Lease.lease_id)
  return _impl_.lease_id_.Release();
}
inline void InvokeScriptResult_Lease::set_allocated_lease_id(std::string* lease_id) {
  if (lease_id != nullptr) {
    
  } else {
    
  }
  _impl_.lease_id_.SetAllocated(lease_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lease_id_.IsDefault()) {
    _impl_.lease_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Lease.lease_id)
}

// -------------------------------------------------------------------

// InvokeScriptResult_LeaseCancel

// bytes lease_id = 1;
inline void InvokeScriptResult_LeaseCancel::clear_lease_id() {
  _impl_.lease_id_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_LeaseCancel::lease_id() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.LeaseCancel.lease_id)
  return _internal_lease_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_LeaseCancel::set_lease_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lease_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.LeaseCancel.lease_id)
}
inline std::string* InvokeScriptResult_LeaseCancel::mutable_lease_id() {
  std::string* _s = _internal_mutable_lease_id();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.LeaseCancel.lease_id)
  return _s;
}
inline const std::string& InvokeScriptResult_LeaseCancel::_internal_lease_id() const {
  return _impl_.lease_id_.Get();
}
inline void InvokeScriptResult_LeaseCancel::_internal_set_lease_id(const std::string& value) {
  
  _impl_.lease_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_LeaseCancel::_internal_mutable_lease_id() {
  
  return _impl_.lease_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_LeaseCancel::release_lease_id() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.LeaseCancel.lease_id)
  return _impl_.lease_id_.Release();
}
inline void InvokeScriptResult_LeaseCancel::set_allocated_lease_id(std::string* lease_id) {
  if (lease_id != nullptr) {
    
  } else {
    
  }
  _impl_.lease_id_.SetAllocated(lease_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lease_id_.IsDefault()) {
    _impl_.lease_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.LeaseCancel.lease_id)
}

// -------------------------------------------------------------------

// InvokeScriptResult_ErrorMessage

// int32 code = 1;
inline void InvokeScriptResult_ErrorMessage::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t InvokeScriptResult_ErrorMessage::_internal_code() const {
  return _impl_.code_;
}
inline int32_t InvokeScriptResult_ErrorMessage::code() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.ErrorMessage.code)
  return _internal_code();
}
inline void InvokeScriptResult_ErrorMessage::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void InvokeScriptResult_ErrorMessage::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.ErrorMessage.code)
}

// string text = 2;
inline void InvokeScriptResult_ErrorMessage::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_ErrorMessage::text() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.ErrorMessage.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_ErrorMessage::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.ErrorMessage.text)
}
inline std::string* InvokeScriptResult_ErrorMessage::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.ErrorMessage.text)
  return _s;
}
inline const std::string& InvokeScriptResult_ErrorMessage::_internal_text() const {
  return _impl_.text_.Get();
}
inline void InvokeScriptResult_ErrorMessage::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_ErrorMessage::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_ErrorMessage::release_text() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.ErrorMessage.text)
  return _impl_.text_.Release();
}
inline void InvokeScriptResult_ErrorMessage::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.ErrorMessage.text)
}

// -------------------------------------------------------------------

// InvokeScriptResult_Call_Argument_List

// repeated .vrp.InvokeScriptResult.Call.Argument items = 1;
inline int InvokeScriptResult_Call_Argument_List::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int InvokeScriptResult_Call_Argument_List::items_size() const {
  return _internal_items_size();
}
inline void InvokeScriptResult_Call_Argument_List::clear_items() {
  _impl_.items_.Clear();
}
inline ::vrp::InvokeScriptResult_Call_Argument* InvokeScriptResult_Call_Argument_List::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.Argument.List.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >*
InvokeScriptResult_Call_Argument_List::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.Call.Argument.List.items)
  return &_impl_.items_;
}
inline const ::vrp::InvokeScriptResult_Call_Argument& InvokeScriptResult_Call_Argument_List::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Call_Argument& InvokeScriptResult_Call_Argument_List::items(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.Argument.List.items)
  return _internal_items(index);
}
inline ::vrp::InvokeScriptResult_Call_Argument* InvokeScriptResult_Call_Argument_List::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::vrp::InvokeScriptResult_Call_Argument* InvokeScriptResult_Call_Argument_List::add_items() {
  ::vrp::InvokeScriptResult_Call_Argument* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.Call.Argument.List.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >&
InvokeScriptResult_Call_Argument_List::items() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.Call.Argument.List.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// InvokeScriptResult_Call_Argument

// int64 integer_value = 1;
inline bool InvokeScriptResult_Call_Argument::_internal_has_integer_value() const {
  return value_case() == kIntegerValue;
}
inline bool InvokeScriptResult_Call_Argument::has_integer_value() const {
  return _internal_has_integer_value();
}
inline void InvokeScriptResult_Call_Argument::set_has_integer_value() {
  _impl_._oneof_case_[0] = kIntegerValue;
}
inline void InvokeScriptResult_Call_Argument::clear_integer_value() {
  if (_internal_has_integer_value()) {
    _impl_.value_.integer_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t InvokeScriptResult_Call_Argument::_internal_integer_value() const {
  if (_internal_has_integer_value()) {
    return _impl_.value_.integer_value_;
  }
  return int64_t{0};
}
inline void InvokeScriptResult_Call_Argument::_internal_set_integer_value(int64_t value) {
  if (!_internal_has_integer_value()) {
    clear_value();
    set_has_integer_value();
  }
  _impl_.value_.integer_value_ = value;
}
inline int64_t InvokeScriptResult_Call_Argument::integer_value() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.Argument.integer_value)
  return _internal_integer_value();
}
inline void InvokeScriptResult_Call_Argument::set_integer_value(int64_t value) {
  _internal_set_integer_value(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.Argument.integer_value)
}

// bytes binary_value = 2;
inline bool InvokeScriptResult_Call_Argument::_internal_has_binary_value() const {
  return value_case() == kBinaryValue;
}
inline bool InvokeScriptResult_Call_Argument::has_binary_value() const {
  return _internal_has_binary_value();
}
inline void InvokeScriptResult_Call_Argument::set_has_binary_value() {
  _impl_._oneof_case_[0] = kBinaryValue;
}
inline void InvokeScriptResult_Call_Argument::clear_binary_value() {
  if (_internal_has_binary_value()) {
    _impl_.value_.binary_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& InvokeScriptResult_Call_Argument::binary_value() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.Argument.binary_value)
  return _internal_binary_value();
}
template <typename ArgT0, typename... ArgT>
inline void InvokeScriptResult_Call_Argument::set_binary_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary_value()) {
    clear_value();
    set_has_binary_value();
    _impl_.value_.binary_value_.InitDefault();
  }
  _impl_.value_.binary_value_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.Argument.binary_value)
}
inline std::string* InvokeScriptResult_Call_Argument::mutable_binary_value() {
  std::string* _s = _internal_mutable_binary_value();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.Argument.binary_value)
  return _s;
}
inline const std::string& InvokeScriptResult_Call_Argument::_internal_binary_value() const {
  if (_internal_has_binary_value()) {
    return _impl_.value_.binary_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InvokeScriptResult_Call_Argument::_internal_set_binary_value(const std::string& value) {
  if (!_internal_has_binary_value()) {
    clear_value();
    set_has_binary_value();
    _impl_.value_.binary_value_.InitDefault();
  }
  _impl_.value_.binary_value_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call_Argument::_internal_mutable_binary_value() {
  if (!_internal_has_binary_value()) {
    clear_value();
    set_has_binary_value();
    _impl_.value_.binary_value_.InitDefault();
  }
  return _impl_.value_.binary_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call_Argument::release_binary_value() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Call.Argument.binary_value)
  if (_internal_has_binary_value()) {
    clear_has_value();
    return _impl_.value_.binary_value_.Release();
  } else {
    return nullptr;
  }
}
inline void InvokeScriptResult_Call_Argument::set_allocated_binary_value(std::string* binary_value) {
  if (has_value()) {
    clear_value();
  }
  if (binary_value != nullptr) {
    set_has_binary_value();
    _impl_.value_.binary_value_.InitAllocated(binary_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Call.Argument.binary_value)
}

// string string_value = 3;
inline bool InvokeScriptResult_Call_Argument::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool InvokeScriptResult_Call_Argument::has_string_value() const {
  return _internal_has_string_value();
}
inline void InvokeScriptResult_Call_Argument::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void InvokeScriptResult_Call_Argument::clear_string_value() {
  if (_internal_has_string_value()) {
    _impl_.value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& InvokeScriptResult_Call_Argument::string_value() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.Argument.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void InvokeScriptResult_Call_Argument::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.Argument.string_value)
}
inline std::string* InvokeScriptResult_Call_Argument::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.Argument.string_value)
  return _s;
}
inline const std::string& InvokeScriptResult_Call_Argument::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return _impl_.value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InvokeScriptResult_Call_Argument::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call_Argument::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  return _impl_.value_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call_Argument::release_string_value() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Call.Argument.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return _impl_.value_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void InvokeScriptResult_Call_Argument::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    _impl_.value_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Call.Argument.string_value)
}

// bool boolean_value = 4;
inline bool InvokeScriptResult_Call_Argument::_internal_has_boolean_value() const {
  return value_case() == kBooleanValue;
}
inline bool InvokeScriptResult_Call_Argument::has_boolean_value() const {
  return _internal_has_boolean_value();
}
inline void InvokeScriptResult_Call_Argument::set_has_boolean_value() {
  _impl_._oneof_case_[0] = kBooleanValue;
}
inline void InvokeScriptResult_Call_Argument::clear_boolean_value() {
  if (_internal_has_boolean_value()) {
    _impl_.value_.boolean_value_ = false;
    clear_has_value();
  }
}
inline bool InvokeScriptResult_Call_Argument::_internal_boolean_value() const {
  if (_internal_has_boolean_value()) {
    return _impl_.value_.boolean_value_;
  }
  return false;
}
inline void InvokeScriptResult_Call_Argument::_internal_set_boolean_value(bool value) {
  if (!_internal_has_boolean_value()) {
    clear_value();
    set_has_boolean_value();
  }
  _impl_.value_.boolean_value_ = value;
}
inline bool InvokeScriptResult_Call_Argument::boolean_value() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.Argument.boolean_value)
  return _internal_boolean_value();
}
inline void InvokeScriptResult_Call_Argument::set_boolean_value(bool value) {
  _internal_set_boolean_value(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.Argument.boolean_value)
}

// bytes case_obj = 5;
inline bool InvokeScriptResult_Call_Argument::_internal_has_case_obj() const {
  return value_case() == kCaseObj;
}
inline bool InvokeScriptResult_Call_Argument::has_case_obj() const {
  return _internal_has_case_obj();
}
inline void InvokeScriptResult_Call_Argument::set_has_case_obj() {
  _impl_._oneof_case_[0] = kCaseObj;
}
inline void InvokeScriptResult_Call_Argument::clear_case_obj() {
  if (_internal_has_case_obj()) {
    _impl_.value_.case_obj_.Destroy();
    clear_has_value();
  }
}
inline const std::string& InvokeScriptResult_Call_Argument::case_obj() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.Argument.case_obj)
  return _internal_case_obj();
}
template <typename ArgT0, typename... ArgT>
inline void InvokeScriptResult_Call_Argument::set_case_obj(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_case_obj()) {
    clear_value();
    set_has_case_obj();
    _impl_.value_.case_obj_.InitDefault();
  }
  _impl_.value_.case_obj_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.Argument.case_obj)
}
inline std::string* InvokeScriptResult_Call_Argument::mutable_case_obj() {
  std::string* _s = _internal_mutable_case_obj();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.Argument.case_obj)
  return _s;
}
inline const std::string& InvokeScriptResult_Call_Argument::_internal_case_obj() const {
  if (_internal_has_case_obj()) {
    return _impl_.value_.case_obj_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InvokeScriptResult_Call_Argument::_internal_set_case_obj(const std::string& value) {
  if (!_internal_has_case_obj()) {
    clear_value();
    set_has_case_obj();
    _impl_.value_.case_obj_.InitDefault();
  }
  _impl_.value_.case_obj_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call_Argument::_internal_mutable_case_obj() {
  if (!_internal_has_case_obj()) {
    clear_value();
    set_has_case_obj();
    _impl_.value_.case_obj_.InitDefault();
  }
  return _impl_.value_.case_obj_.Mutable(      GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call_Argument::release_case_obj() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Call.Argument.case_obj)
  if (_internal_has_case_obj()) {
    clear_has_value();
    return _impl_.value_.case_obj_.Release();
  } else {
    return nullptr;
  }
}
inline void InvokeScriptResult_Call_Argument::set_allocated_case_obj(std::string* case_obj) {
  if (has_value()) {
    clear_value();
  }
  if (case_obj != nullptr) {
    set_has_case_obj();
    _impl_.value_.case_obj_.InitAllocated(case_obj, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Call.Argument.case_obj)
}

// .vrp.InvokeScriptResult.Call.Argument.List list = 10;
inline bool InvokeScriptResult_Call_Argument::_internal_has_list() const {
  return value_case() == kList;
}
inline bool InvokeScriptResult_Call_Argument::has_list() const {
  return _internal_has_list();
}
inline void InvokeScriptResult_Call_Argument::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void InvokeScriptResult_Call_Argument::clear_list() {
  if (_internal_has_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.list_;
    }
    clear_has_value();
  }
}
inline ::vrp::InvokeScriptResult_Call_Argument_List* InvokeScriptResult_Call_Argument::release_list() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Call.Argument.list)
  if (_internal_has_list()) {
    clear_has_value();
    ::vrp::InvokeScriptResult_Call_Argument_List* temp = _impl_.value_.list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vrp::InvokeScriptResult_Call_Argument_List& InvokeScriptResult_Call_Argument::_internal_list() const {
  return _internal_has_list()
      ? *_impl_.value_.list_
      : reinterpret_cast< ::vrp::InvokeScriptResult_Call_Argument_List&>(::vrp::_InvokeScriptResult_Call_Argument_List_default_instance_);
}
inline const ::vrp::InvokeScriptResult_Call_Argument_List& InvokeScriptResult_Call_Argument::list() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.Argument.list)
  return _internal_list();
}
inline ::vrp::InvokeScriptResult_Call_Argument_List* InvokeScriptResult_Call_Argument::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vrp.InvokeScriptResult.Call.Argument.list)
  if (_internal_has_list()) {
    clear_has_value();
    ::vrp::InvokeScriptResult_Call_Argument_List* temp = _impl_.value_.list_;
    _impl_.value_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InvokeScriptResult_Call_Argument::unsafe_arena_set_allocated_list(::vrp::InvokeScriptResult_Call_Argument_List* list) {
  clear_value();
  if (list) {
    set_has_list();
    _impl_.value_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.Call.Argument.list)
}
inline ::vrp::InvokeScriptResult_Call_Argument_List* InvokeScriptResult_Call_Argument::_internal_mutable_list() {
  if (!_internal_has_list()) {
    clear_value();
    set_has_list();
    _impl_.value_.list_ = CreateMaybeMessage< ::vrp::InvokeScriptResult_Call_Argument_List >(GetArenaForAllocation());
  }
  return _impl_.value_.list_;
}
inline ::vrp::InvokeScriptResult_Call_Argument_List* InvokeScriptResult_Call_Argument::mutable_list() {
  ::vrp::InvokeScriptResult_Call_Argument_List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.Argument.list)
  return _msg;
}

inline bool InvokeScriptResult_Call_Argument::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void InvokeScriptResult_Call_Argument::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline InvokeScriptResult_Call_Argument::ValueCase InvokeScriptResult_Call_Argument::value_case() const {
  return InvokeScriptResult_Call_Argument::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InvokeScriptResult_Call

// string function = 1;
inline void InvokeScriptResult_Call::clear_function() {
  _impl_.function_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Call::function() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.function)
  return _internal_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Call::set_function(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.function)
}
inline std::string* InvokeScriptResult_Call::mutable_function() {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.function)
  return _s;
}
inline const std::string& InvokeScriptResult_Call::_internal_function() const {
  return _impl_.function_.Get();
}
inline void InvokeScriptResult_Call::_internal_set_function(const std::string& value) {
  
  _impl_.function_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call::_internal_mutable_function() {
  
  return _impl_.function_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Call::release_function() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Call.function)
  return _impl_.function_.Release();
}
inline void InvokeScriptResult_Call::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    
  } else {
    
  }
  _impl_.function_.SetAllocated(function, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_.IsDefault()) {
    _impl_.function_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Call.function)
}

// repeated bytes args_bytes = 2 [deprecated = true];
inline int InvokeScriptResult_Call::_internal_args_bytes_size() const {
  return _impl_.args_bytes_.size();
}
inline int InvokeScriptResult_Call::args_bytes_size() const {
  return _internal_args_bytes_size();
}
inline void InvokeScriptResult_Call::clear_args_bytes() {
  _impl_.args_bytes_.Clear();
}
inline std::string* InvokeScriptResult_Call::add_args_bytes() {
  std::string* _s = _internal_add_args_bytes();
  // @@protoc_insertion_point(field_add_mutable:vrp.InvokeScriptResult.Call.args_bytes)
  return _s;
}
inline const std::string& InvokeScriptResult_Call::_internal_args_bytes(int index) const {
  return _impl_.args_bytes_.Get(index);
}
inline const std::string& InvokeScriptResult_Call::args_bytes(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.args_bytes)
  return _internal_args_bytes(index);
}
inline std::string* InvokeScriptResult_Call::mutable_args_bytes(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.args_bytes)
  return _impl_.args_bytes_.Mutable(index);
}
inline void InvokeScriptResult_Call::set_args_bytes(int index, const std::string& value) {
  _impl_.args_bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.args_bytes)
}
inline void InvokeScriptResult_Call::set_args_bytes(int index, std::string&& value) {
  _impl_.args_bytes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Call.args_bytes)
}
inline void InvokeScriptResult_Call::set_args_bytes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vrp.InvokeScriptResult.Call.args_bytes)
}
inline void InvokeScriptResult_Call::set_args_bytes(int index, const void* value, size_t size) {
  _impl_.args_bytes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vrp.InvokeScriptResult.Call.args_bytes)
}
inline std::string* InvokeScriptResult_Call::_internal_add_args_bytes() {
  return _impl_.args_bytes_.Add();
}
inline void InvokeScriptResult_Call::add_args_bytes(const std::string& value) {
  _impl_.args_bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.Call.args_bytes)
}
inline void InvokeScriptResult_Call::add_args_bytes(std::string&& value) {
  _impl_.args_bytes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.Call.args_bytes)
}
inline void InvokeScriptResult_Call::add_args_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vrp.InvokeScriptResult.Call.args_bytes)
}
inline void InvokeScriptResult_Call::add_args_bytes(const void* value, size_t size) {
  _impl_.args_bytes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vrp.InvokeScriptResult.Call.args_bytes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InvokeScriptResult_Call::args_bytes() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.Call.args_bytes)
  return _impl_.args_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InvokeScriptResult_Call::mutable_args_bytes() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.Call.args_bytes)
  return &_impl_.args_bytes_;
}

// repeated .vrp.InvokeScriptResult.Call.Argument args = 3;
inline int InvokeScriptResult_Call::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int InvokeScriptResult_Call::args_size() const {
  return _internal_args_size();
}
inline void InvokeScriptResult_Call::clear_args() {
  _impl_.args_.Clear();
}
inline ::vrp::InvokeScriptResult_Call_Argument* InvokeScriptResult_Call::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Call.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >*
InvokeScriptResult_Call::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.Call.args)
  return &_impl_.args_;
}
inline const ::vrp::InvokeScriptResult_Call_Argument& InvokeScriptResult_Call::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Call_Argument& InvokeScriptResult_Call::args(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Call.args)
  return _internal_args(index);
}
inline ::vrp::InvokeScriptResult_Call_Argument* InvokeScriptResult_Call::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::vrp::InvokeScriptResult_Call_Argument* InvokeScriptResult_Call::add_args() {
  ::vrp::InvokeScriptResult_Call_Argument* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.Call.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Call_Argument >&
InvokeScriptResult_Call::args() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.Call.args)
  return _impl_.args_;
}

// -------------------------------------------------------------------

// InvokeScriptResult_Invocation

// bytes dApp = 1;
inline void InvokeScriptResult_Invocation::clear_dapp() {
  _impl_.dapp_.ClearToEmpty();
}
inline const std::string& InvokeScriptResult_Invocation::dapp() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Invocation.dApp)
  return _internal_dapp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeScriptResult_Invocation::set_dapp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dapp_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vrp.InvokeScriptResult.Invocation.dApp)
}
inline std::string* InvokeScriptResult_Invocation::mutable_dapp() {
  std::string* _s = _internal_mutable_dapp();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Invocation.dApp)
  return _s;
}
inline const std::string& InvokeScriptResult_Invocation::_internal_dapp() const {
  return _impl_.dapp_.Get();
}
inline void InvokeScriptResult_Invocation::_internal_set_dapp(const std::string& value) {
  
  _impl_.dapp_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Invocation::_internal_mutable_dapp() {
  
  return _impl_.dapp_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeScriptResult_Invocation::release_dapp() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Invocation.dApp)
  return _impl_.dapp_.Release();
}
inline void InvokeScriptResult_Invocation::set_allocated_dapp(std::string* dapp) {
  if (dapp != nullptr) {
    
  } else {
    
  }
  _impl_.dapp_.SetAllocated(dapp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dapp_.IsDefault()) {
    _impl_.dapp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Invocation.dApp)
}

// .vrp.InvokeScriptResult.Call call = 2;
inline bool InvokeScriptResult_Invocation::_internal_has_call() const {
  return this != internal_default_instance() && _impl_.call_ != nullptr;
}
inline bool InvokeScriptResult_Invocation::has_call() const {
  return _internal_has_call();
}
inline void InvokeScriptResult_Invocation::clear_call() {
  if (GetArenaForAllocation() == nullptr && _impl_.call_ != nullptr) {
    delete _impl_.call_;
  }
  _impl_.call_ = nullptr;
}
inline const ::vrp::InvokeScriptResult_Call& InvokeScriptResult_Invocation::_internal_call() const {
  const ::vrp::InvokeScriptResult_Call* p = _impl_.call_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::InvokeScriptResult_Call&>(
      ::vrp::_InvokeScriptResult_Call_default_instance_);
}
inline const ::vrp::InvokeScriptResult_Call& InvokeScriptResult_Invocation::call() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Invocation.call)
  return _internal_call();
}
inline void InvokeScriptResult_Invocation::unsafe_arena_set_allocated_call(
    ::vrp::InvokeScriptResult_Call* call) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.call_);
  }
  _impl_.call_ = call;
  if (call) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.Invocation.call)
}
inline ::vrp::InvokeScriptResult_Call* InvokeScriptResult_Invocation::release_call() {
  
  ::vrp::InvokeScriptResult_Call* temp = _impl_.call_;
  _impl_.call_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::InvokeScriptResult_Call* InvokeScriptResult_Invocation::unsafe_arena_release_call() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Invocation.call)
  
  ::vrp::InvokeScriptResult_Call* temp = _impl_.call_;
  _impl_.call_ = nullptr;
  return temp;
}
inline ::vrp::InvokeScriptResult_Call* InvokeScriptResult_Invocation::_internal_mutable_call() {
  
  if (_impl_.call_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::InvokeScriptResult_Call>(GetArenaForAllocation());
    _impl_.call_ = p;
  }
  return _impl_.call_;
}
inline ::vrp::InvokeScriptResult_Call* InvokeScriptResult_Invocation::mutable_call() {
  ::vrp::InvokeScriptResult_Call* _msg = _internal_mutable_call();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Invocation.call)
  return _msg;
}
inline void InvokeScriptResult_Invocation::set_allocated_call(::vrp::InvokeScriptResult_Call* call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.call_;
  }
  if (call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(call);
    if (message_arena != submessage_arena) {
      call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, call, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.call_ = call;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Invocation.call)
}

// repeated .vrp.Amount payments = 3;
inline int InvokeScriptResult_Invocation::_internal_payments_size() const {
  return _impl_.payments_.size();
}
inline int InvokeScriptResult_Invocation::payments_size() const {
  return _internal_payments_size();
}
inline ::vrp::Amount* InvokeScriptResult_Invocation::mutable_payments(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Invocation.payments)
  return _impl_.payments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >*
InvokeScriptResult_Invocation::mutable_payments() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.Invocation.payments)
  return &_impl_.payments_;
}
inline const ::vrp::Amount& InvokeScriptResult_Invocation::_internal_payments(int index) const {
  return _impl_.payments_.Get(index);
}
inline const ::vrp::Amount& InvokeScriptResult_Invocation::payments(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Invocation.payments)
  return _internal_payments(index);
}
inline ::vrp::Amount* InvokeScriptResult_Invocation::_internal_add_payments() {
  return _impl_.payments_.Add();
}
inline ::vrp::Amount* InvokeScriptResult_Invocation::add_payments() {
  ::vrp::Amount* _add = _internal_add_payments();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.Invocation.payments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::Amount >&
InvokeScriptResult_Invocation::payments() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.Invocation.payments)
  return _impl_.payments_;
}

// .vrp.InvokeScriptResult stateChanges = 4;
inline bool InvokeScriptResult_Invocation::_internal_has_statechanges() const {
  return this != internal_default_instance() && _impl_.statechanges_ != nullptr;
}
inline bool InvokeScriptResult_Invocation::has_statechanges() const {
  return _internal_has_statechanges();
}
inline void InvokeScriptResult_Invocation::clear_statechanges() {
  if (GetArenaForAllocation() == nullptr && _impl_.statechanges_ != nullptr) {
    delete _impl_.statechanges_;
  }
  _impl_.statechanges_ = nullptr;
}
inline const ::vrp::InvokeScriptResult& InvokeScriptResult_Invocation::_internal_statechanges() const {
  const ::vrp::InvokeScriptResult* p = _impl_.statechanges_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::InvokeScriptResult&>(
      ::vrp::_InvokeScriptResult_default_instance_);
}
inline const ::vrp::InvokeScriptResult& InvokeScriptResult_Invocation::statechanges() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.Invocation.stateChanges)
  return _internal_statechanges();
}
inline void InvokeScriptResult_Invocation::unsafe_arena_set_allocated_statechanges(
    ::vrp::InvokeScriptResult* statechanges) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statechanges_);
  }
  _impl_.statechanges_ = statechanges;
  if (statechanges) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.Invocation.stateChanges)
}
inline ::vrp::InvokeScriptResult* InvokeScriptResult_Invocation::release_statechanges() {
  
  ::vrp::InvokeScriptResult* temp = _impl_.statechanges_;
  _impl_.statechanges_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::InvokeScriptResult* InvokeScriptResult_Invocation::unsafe_arena_release_statechanges() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.Invocation.stateChanges)
  
  ::vrp::InvokeScriptResult* temp = _impl_.statechanges_;
  _impl_.statechanges_ = nullptr;
  return temp;
}
inline ::vrp::InvokeScriptResult* InvokeScriptResult_Invocation::_internal_mutable_statechanges() {
  
  if (_impl_.statechanges_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::InvokeScriptResult>(GetArenaForAllocation());
    _impl_.statechanges_ = p;
  }
  return _impl_.statechanges_;
}
inline ::vrp::InvokeScriptResult* InvokeScriptResult_Invocation::mutable_statechanges() {
  ::vrp::InvokeScriptResult* _msg = _internal_mutable_statechanges();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.Invocation.stateChanges)
  return _msg;
}
inline void InvokeScriptResult_Invocation::set_allocated_statechanges(::vrp::InvokeScriptResult* statechanges) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.statechanges_;
  }
  if (statechanges) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statechanges);
    if (message_arena != submessage_arena) {
      statechanges = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statechanges, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statechanges_ = statechanges;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.Invocation.stateChanges)
}

// -------------------------------------------------------------------

// InvokeScriptResult

// repeated .vrp.DataTransactionData.DataEntry data = 1;
inline int InvokeScriptResult::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int InvokeScriptResult::data_size() const {
  return _internal_data_size();
}
inline ::vrp::DataTransactionData_DataEntry* InvokeScriptResult::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >*
InvokeScriptResult::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.data)
  return &_impl_.data_;
}
inline const ::vrp::DataTransactionData_DataEntry& InvokeScriptResult::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::vrp::DataTransactionData_DataEntry& InvokeScriptResult::data(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.data)
  return _internal_data(index);
}
inline ::vrp::DataTransactionData_DataEntry* InvokeScriptResult::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::vrp::DataTransactionData_DataEntry* InvokeScriptResult::add_data() {
  ::vrp::DataTransactionData_DataEntry* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::DataTransactionData_DataEntry >&
InvokeScriptResult::data() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.data)
  return _impl_.data_;
}

// repeated .vrp.InvokeScriptResult.Payment transfers = 2;
inline int InvokeScriptResult::_internal_transfers_size() const {
  return _impl_.transfers_.size();
}
inline int InvokeScriptResult::transfers_size() const {
  return _internal_transfers_size();
}
inline void InvokeScriptResult::clear_transfers() {
  _impl_.transfers_.Clear();
}
inline ::vrp::InvokeScriptResult_Payment* InvokeScriptResult::mutable_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.transfers)
  return _impl_.transfers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Payment >*
InvokeScriptResult::mutable_transfers() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.transfers)
  return &_impl_.transfers_;
}
inline const ::vrp::InvokeScriptResult_Payment& InvokeScriptResult::_internal_transfers(int index) const {
  return _impl_.transfers_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Payment& InvokeScriptResult::transfers(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.transfers)
  return _internal_transfers(index);
}
inline ::vrp::InvokeScriptResult_Payment* InvokeScriptResult::_internal_add_transfers() {
  return _impl_.transfers_.Add();
}
inline ::vrp::InvokeScriptResult_Payment* InvokeScriptResult::add_transfers() {
  ::vrp::InvokeScriptResult_Payment* _add = _internal_add_transfers();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Payment >&
InvokeScriptResult::transfers() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.transfers)
  return _impl_.transfers_;
}

// repeated .vrp.InvokeScriptResult.Issue issues = 3;
inline int InvokeScriptResult::_internal_issues_size() const {
  return _impl_.issues_.size();
}
inline int InvokeScriptResult::issues_size() const {
  return _internal_issues_size();
}
inline void InvokeScriptResult::clear_issues() {
  _impl_.issues_.Clear();
}
inline ::vrp::InvokeScriptResult_Issue* InvokeScriptResult::mutable_issues(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.issues)
  return _impl_.issues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Issue >*
InvokeScriptResult::mutable_issues() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.issues)
  return &_impl_.issues_;
}
inline const ::vrp::InvokeScriptResult_Issue& InvokeScriptResult::_internal_issues(int index) const {
  return _impl_.issues_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Issue& InvokeScriptResult::issues(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.issues)
  return _internal_issues(index);
}
inline ::vrp::InvokeScriptResult_Issue* InvokeScriptResult::_internal_add_issues() {
  return _impl_.issues_.Add();
}
inline ::vrp::InvokeScriptResult_Issue* InvokeScriptResult::add_issues() {
  ::vrp::InvokeScriptResult_Issue* _add = _internal_add_issues();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.issues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Issue >&
InvokeScriptResult::issues() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.issues)
  return _impl_.issues_;
}

// repeated .vrp.InvokeScriptResult.Reissue reissues = 4;
inline int InvokeScriptResult::_internal_reissues_size() const {
  return _impl_.reissues_.size();
}
inline int InvokeScriptResult::reissues_size() const {
  return _internal_reissues_size();
}
inline void InvokeScriptResult::clear_reissues() {
  _impl_.reissues_.Clear();
}
inline ::vrp::InvokeScriptResult_Reissue* InvokeScriptResult::mutable_reissues(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.reissues)
  return _impl_.reissues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Reissue >*
InvokeScriptResult::mutable_reissues() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.reissues)
  return &_impl_.reissues_;
}
inline const ::vrp::InvokeScriptResult_Reissue& InvokeScriptResult::_internal_reissues(int index) const {
  return _impl_.reissues_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Reissue& InvokeScriptResult::reissues(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.reissues)
  return _internal_reissues(index);
}
inline ::vrp::InvokeScriptResult_Reissue* InvokeScriptResult::_internal_add_reissues() {
  return _impl_.reissues_.Add();
}
inline ::vrp::InvokeScriptResult_Reissue* InvokeScriptResult::add_reissues() {
  ::vrp::InvokeScriptResult_Reissue* _add = _internal_add_reissues();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.reissues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Reissue >&
InvokeScriptResult::reissues() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.reissues)
  return _impl_.reissues_;
}

// repeated .vrp.InvokeScriptResult.Burn burns = 5;
inline int InvokeScriptResult::_internal_burns_size() const {
  return _impl_.burns_.size();
}
inline int InvokeScriptResult::burns_size() const {
  return _internal_burns_size();
}
inline void InvokeScriptResult::clear_burns() {
  _impl_.burns_.Clear();
}
inline ::vrp::InvokeScriptResult_Burn* InvokeScriptResult::mutable_burns(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.burns)
  return _impl_.burns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Burn >*
InvokeScriptResult::mutable_burns() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.burns)
  return &_impl_.burns_;
}
inline const ::vrp::InvokeScriptResult_Burn& InvokeScriptResult::_internal_burns(int index) const {
  return _impl_.burns_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Burn& InvokeScriptResult::burns(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.burns)
  return _internal_burns(index);
}
inline ::vrp::InvokeScriptResult_Burn* InvokeScriptResult::_internal_add_burns() {
  return _impl_.burns_.Add();
}
inline ::vrp::InvokeScriptResult_Burn* InvokeScriptResult::add_burns() {
  ::vrp::InvokeScriptResult_Burn* _add = _internal_add_burns();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.burns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Burn >&
InvokeScriptResult::burns() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.burns)
  return _impl_.burns_;
}

// .vrp.InvokeScriptResult.ErrorMessage error_message = 6;
inline bool InvokeScriptResult::_internal_has_error_message() const {
  return this != internal_default_instance() && _impl_.error_message_ != nullptr;
}
inline bool InvokeScriptResult::has_error_message() const {
  return _internal_has_error_message();
}
inline void InvokeScriptResult::clear_error_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_message_ != nullptr) {
    delete _impl_.error_message_;
  }
  _impl_.error_message_ = nullptr;
}
inline const ::vrp::InvokeScriptResult_ErrorMessage& InvokeScriptResult::_internal_error_message() const {
  const ::vrp::InvokeScriptResult_ErrorMessage* p = _impl_.error_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::vrp::InvokeScriptResult_ErrorMessage&>(
      ::vrp::_InvokeScriptResult_ErrorMessage_default_instance_);
}
inline const ::vrp::InvokeScriptResult_ErrorMessage& InvokeScriptResult::error_message() const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.error_message)
  return _internal_error_message();
}
inline void InvokeScriptResult::unsafe_arena_set_allocated_error_message(
    ::vrp::InvokeScriptResult_ErrorMessage* error_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_message_);
  }
  _impl_.error_message_ = error_message;
  if (error_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vrp.InvokeScriptResult.error_message)
}
inline ::vrp::InvokeScriptResult_ErrorMessage* InvokeScriptResult::release_error_message() {
  
  ::vrp::InvokeScriptResult_ErrorMessage* temp = _impl_.error_message_;
  _impl_.error_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vrp::InvokeScriptResult_ErrorMessage* InvokeScriptResult::unsafe_arena_release_error_message() {
  // @@protoc_insertion_point(field_release:vrp.InvokeScriptResult.error_message)
  
  ::vrp::InvokeScriptResult_ErrorMessage* temp = _impl_.error_message_;
  _impl_.error_message_ = nullptr;
  return temp;
}
inline ::vrp::InvokeScriptResult_ErrorMessage* InvokeScriptResult::_internal_mutable_error_message() {
  
  if (_impl_.error_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::vrp::InvokeScriptResult_ErrorMessage>(GetArenaForAllocation());
    _impl_.error_message_ = p;
  }
  return _impl_.error_message_;
}
inline ::vrp::InvokeScriptResult_ErrorMessage* InvokeScriptResult::mutable_error_message() {
  ::vrp::InvokeScriptResult_ErrorMessage* _msg = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.error_message)
  return _msg;
}
inline void InvokeScriptResult::set_allocated_error_message(::vrp::InvokeScriptResult_ErrorMessage* error_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_message_;
  }
  if (error_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error_message);
    if (message_arena != submessage_arena) {
      error_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_message_ = error_message;
  // @@protoc_insertion_point(field_set_allocated:vrp.InvokeScriptResult.error_message)
}

// repeated .vrp.InvokeScriptResult.SponsorFee sponsor_fees = 7;
inline int InvokeScriptResult::_internal_sponsor_fees_size() const {
  return _impl_.sponsor_fees_.size();
}
inline int InvokeScriptResult::sponsor_fees_size() const {
  return _internal_sponsor_fees_size();
}
inline void InvokeScriptResult::clear_sponsor_fees() {
  _impl_.sponsor_fees_.Clear();
}
inline ::vrp::InvokeScriptResult_SponsorFee* InvokeScriptResult::mutable_sponsor_fees(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.sponsor_fees)
  return _impl_.sponsor_fees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_SponsorFee >*
InvokeScriptResult::mutable_sponsor_fees() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.sponsor_fees)
  return &_impl_.sponsor_fees_;
}
inline const ::vrp::InvokeScriptResult_SponsorFee& InvokeScriptResult::_internal_sponsor_fees(int index) const {
  return _impl_.sponsor_fees_.Get(index);
}
inline const ::vrp::InvokeScriptResult_SponsorFee& InvokeScriptResult::sponsor_fees(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.sponsor_fees)
  return _internal_sponsor_fees(index);
}
inline ::vrp::InvokeScriptResult_SponsorFee* InvokeScriptResult::_internal_add_sponsor_fees() {
  return _impl_.sponsor_fees_.Add();
}
inline ::vrp::InvokeScriptResult_SponsorFee* InvokeScriptResult::add_sponsor_fees() {
  ::vrp::InvokeScriptResult_SponsorFee* _add = _internal_add_sponsor_fees();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.sponsor_fees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_SponsorFee >&
InvokeScriptResult::sponsor_fees() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.sponsor_fees)
  return _impl_.sponsor_fees_;
}

// repeated .vrp.InvokeScriptResult.Lease leases = 8;
inline int InvokeScriptResult::_internal_leases_size() const {
  return _impl_.leases_.size();
}
inline int InvokeScriptResult::leases_size() const {
  return _internal_leases_size();
}
inline void InvokeScriptResult::clear_leases() {
  _impl_.leases_.Clear();
}
inline ::vrp::InvokeScriptResult_Lease* InvokeScriptResult::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.leases)
  return _impl_.leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Lease >*
InvokeScriptResult::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.leases)
  return &_impl_.leases_;
}
inline const ::vrp::InvokeScriptResult_Lease& InvokeScriptResult::_internal_leases(int index) const {
  return _impl_.leases_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Lease& InvokeScriptResult::leases(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.leases)
  return _internal_leases(index);
}
inline ::vrp::InvokeScriptResult_Lease* InvokeScriptResult::_internal_add_leases() {
  return _impl_.leases_.Add();
}
inline ::vrp::InvokeScriptResult_Lease* InvokeScriptResult::add_leases() {
  ::vrp::InvokeScriptResult_Lease* _add = _internal_add_leases();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Lease >&
InvokeScriptResult::leases() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.leases)
  return _impl_.leases_;
}

// repeated .vrp.InvokeScriptResult.LeaseCancel lease_cancels = 9;
inline int InvokeScriptResult::_internal_lease_cancels_size() const {
  return _impl_.lease_cancels_.size();
}
inline int InvokeScriptResult::lease_cancels_size() const {
  return _internal_lease_cancels_size();
}
inline void InvokeScriptResult::clear_lease_cancels() {
  _impl_.lease_cancels_.Clear();
}
inline ::vrp::InvokeScriptResult_LeaseCancel* InvokeScriptResult::mutable_lease_cancels(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.lease_cancels)
  return _impl_.lease_cancels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_LeaseCancel >*
InvokeScriptResult::mutable_lease_cancels() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.lease_cancels)
  return &_impl_.lease_cancels_;
}
inline const ::vrp::InvokeScriptResult_LeaseCancel& InvokeScriptResult::_internal_lease_cancels(int index) const {
  return _impl_.lease_cancels_.Get(index);
}
inline const ::vrp::InvokeScriptResult_LeaseCancel& InvokeScriptResult::lease_cancels(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.lease_cancels)
  return _internal_lease_cancels(index);
}
inline ::vrp::InvokeScriptResult_LeaseCancel* InvokeScriptResult::_internal_add_lease_cancels() {
  return _impl_.lease_cancels_.Add();
}
inline ::vrp::InvokeScriptResult_LeaseCancel* InvokeScriptResult::add_lease_cancels() {
  ::vrp::InvokeScriptResult_LeaseCancel* _add = _internal_add_lease_cancels();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.lease_cancels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_LeaseCancel >&
InvokeScriptResult::lease_cancels() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.lease_cancels)
  return _impl_.lease_cancels_;
}

// repeated .vrp.InvokeScriptResult.Invocation invokes = 10;
inline int InvokeScriptResult::_internal_invokes_size() const {
  return _impl_.invokes_.size();
}
inline int InvokeScriptResult::invokes_size() const {
  return _internal_invokes_size();
}
inline void InvokeScriptResult::clear_invokes() {
  _impl_.invokes_.Clear();
}
inline ::vrp::InvokeScriptResult_Invocation* InvokeScriptResult::mutable_invokes(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.invokes)
  return _impl_.invokes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Invocation >*
InvokeScriptResult::mutable_invokes() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.invokes)
  return &_impl_.invokes_;
}
inline const ::vrp::InvokeScriptResult_Invocation& InvokeScriptResult::_internal_invokes(int index) const {
  return _impl_.invokes_.Get(index);
}
inline const ::vrp::InvokeScriptResult_Invocation& InvokeScriptResult::invokes(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.invokes)
  return _internal_invokes(index);
}
inline ::vrp::InvokeScriptResult_Invocation* InvokeScriptResult::_internal_add_invokes() {
  return _impl_.invokes_.Add();
}
inline ::vrp::InvokeScriptResult_Invocation* InvokeScriptResult::add_invokes() {
  ::vrp::InvokeScriptResult_Invocation* _add = _internal_add_invokes();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.invokes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_Invocation >&
InvokeScriptResult::invokes() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.invokes)
  return _impl_.invokes_;
}

// repeated .vrp.InvokeScriptResult.PrivatePayment private_payment = 11;
inline int InvokeScriptResult::_internal_private_payment_size() const {
  return _impl_.private_payment_.size();
}
inline int InvokeScriptResult::private_payment_size() const {
  return _internal_private_payment_size();
}
inline void InvokeScriptResult::clear_private_payment() {
  _impl_.private_payment_.Clear();
}
inline ::vrp::InvokeScriptResult_PrivatePayment* InvokeScriptResult::mutable_private_payment(int index) {
  // @@protoc_insertion_point(field_mutable:vrp.InvokeScriptResult.private_payment)
  return _impl_.private_payment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_PrivatePayment >*
InvokeScriptResult::mutable_private_payment() {
  // @@protoc_insertion_point(field_mutable_list:vrp.InvokeScriptResult.private_payment)
  return &_impl_.private_payment_;
}
inline const ::vrp::InvokeScriptResult_PrivatePayment& InvokeScriptResult::_internal_private_payment(int index) const {
  return _impl_.private_payment_.Get(index);
}
inline const ::vrp::InvokeScriptResult_PrivatePayment& InvokeScriptResult::private_payment(int index) const {
  // @@protoc_insertion_point(field_get:vrp.InvokeScriptResult.private_payment)
  return _internal_private_payment(index);
}
inline ::vrp::InvokeScriptResult_PrivatePayment* InvokeScriptResult::_internal_add_private_payment() {
  return _impl_.private_payment_.Add();
}
inline ::vrp::InvokeScriptResult_PrivatePayment* InvokeScriptResult::add_private_payment() {
  ::vrp::InvokeScriptResult_PrivatePayment* _add = _internal_add_private_payment();
  // @@protoc_insertion_point(field_add:vrp.InvokeScriptResult.private_payment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vrp::InvokeScriptResult_PrivatePayment >&
InvokeScriptResult::private_payment() const {
  // @@protoc_insertion_point(field_list:vrp.InvokeScriptResult.private_payment)
  return _impl_.private_payment_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vrp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vrp_2finvoke_5fscript_5fresult_2eproto
