// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vrp/transaction.proto

#include "vrp/transaction.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace vrp {
PROTOBUF_CONSTEXPR SignedTransaction::SignedTransaction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proofs_)*/{}
  , /*decltype(_impl_.transaction_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SignedTransactionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignedTransactionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignedTransactionDefaultTypeInternal() {}
  union {
    SignedTransaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignedTransactionDefaultTypeInternal _SignedTransaction_default_instance_;
PROTOBUF_CONSTEXPR Transaction::Transaction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sender_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fee_)*/nullptr
  , /*decltype(_impl_.chain_id_)*/0
  , /*decltype(_impl_.version_)*/0
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TransactionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransactionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransactionDefaultTypeInternal() {}
  union {
    Transaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransactionDefaultTypeInternal _Transaction_default_instance_;
PROTOBUF_CONSTEXPR GenesisTransactionData::GenesisTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GenesisTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenesisTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenesisTransactionDataDefaultTypeInternal() {}
  union {
    GenesisTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenesisTransactionDataDefaultTypeInternal _GenesisTransactionData_default_instance_;
PROTOBUF_CONSTEXPR PaymentTransactionData::PaymentTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PaymentTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PaymentTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PaymentTransactionDataDefaultTypeInternal() {}
  union {
    PaymentTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaymentTransactionDataDefaultTypeInternal _PaymentTransactionData_default_instance_;
PROTOBUF_CONSTEXPR TransferTransactionData::TransferTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.attachment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recipient_)*/nullptr
  , /*decltype(_impl_.amount_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransferTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransferTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransferTransactionDataDefaultTypeInternal() {}
  union {
    TransferTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransferTransactionDataDefaultTypeInternal _TransferTransactionData_default_instance_;
PROTOBUF_CONSTEXPR CreateAliasTransactionData::CreateAliasTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.alias_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateAliasTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateAliasTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateAliasTransactionDataDefaultTypeInternal() {}
  union {
    CreateAliasTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateAliasTransactionDataDefaultTypeInternal _CreateAliasTransactionData_default_instance_;
PROTOBUF_CONSTEXPR DataTransactionData_DataEntry::DataTransactionData_DataEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DataTransactionData_DataEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataTransactionData_DataEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataTransactionData_DataEntryDefaultTypeInternal() {}
  union {
    DataTransactionData_DataEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataTransactionData_DataEntryDefaultTypeInternal _DataTransactionData_DataEntry_default_instance_;
PROTOBUF_CONSTEXPR DataTransactionData::DataTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DataTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataTransactionDataDefaultTypeInternal() {}
  union {
    DataTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataTransactionDataDefaultTypeInternal _DataTransactionData_default_instance_;
PROTOBUF_CONSTEXPR MassTransferTransactionData_Transfer::MassTransferTransactionData_Transfer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recipient_)*/nullptr
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MassTransferTransactionData_TransferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MassTransferTransactionData_TransferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MassTransferTransactionData_TransferDefaultTypeInternal() {}
  union {
    MassTransferTransactionData_Transfer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MassTransferTransactionData_TransferDefaultTypeInternal _MassTransferTransactionData_Transfer_default_instance_;
PROTOBUF_CONSTEXPR MassTransferTransactionData::MassTransferTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transfers_)*/{}
  , /*decltype(_impl_.asset_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attachment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MassTransferTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MassTransferTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MassTransferTransactionDataDefaultTypeInternal() {}
  union {
    MassTransferTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MassTransferTransactionDataDefaultTypeInternal _MassTransferTransactionData_default_instance_;
PROTOBUF_CONSTEXPR LeaseTransactionData::LeaseTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recipient_)*/nullptr
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseTransactionDataDefaultTypeInternal() {}
  union {
    LeaseTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseTransactionDataDefaultTypeInternal _LeaseTransactionData_default_instance_;
PROTOBUF_CONSTEXPR LeaseCancelTransactionData::LeaseCancelTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lease_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LeaseCancelTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaseCancelTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaseCancelTransactionDataDefaultTypeInternal() {}
  union {
    LeaseCancelTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaseCancelTransactionDataDefaultTypeInternal _LeaseCancelTransactionData_default_instance_;
PROTOBUF_CONSTEXPR BurnTransactionData::BurnTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asset_amount_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BurnTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BurnTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BurnTransactionDataDefaultTypeInternal() {}
  union {
    BurnTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BurnTransactionDataDefaultTypeInternal _BurnTransactionData_default_instance_;
PROTOBUF_CONSTEXPR IssueTransactionData::IssueTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.script_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_.decimals_)*/0
  , /*decltype(_impl_.reissuable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IssueTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IssueTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IssueTransactionDataDefaultTypeInternal() {}
  union {
    IssueTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IssueTransactionDataDefaultTypeInternal _IssueTransactionData_default_instance_;
PROTOBUF_CONSTEXPR ReissueTransactionData::ReissueTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asset_amount_)*/nullptr
  , /*decltype(_impl_.reissuable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReissueTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReissueTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReissueTransactionDataDefaultTypeInternal() {}
  union {
    ReissueTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReissueTransactionDataDefaultTypeInternal _ReissueTransactionData_default_instance_;
PROTOBUF_CONSTEXPR SetAssetScriptTransactionData::SetAssetScriptTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asset_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.script_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetAssetScriptTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetAssetScriptTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetAssetScriptTransactionDataDefaultTypeInternal() {}
  union {
    SetAssetScriptTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetAssetScriptTransactionDataDefaultTypeInternal _SetAssetScriptTransactionData_default_instance_;
PROTOBUF_CONSTEXPR SetScriptTransactionData::SetScriptTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.script_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetScriptTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetScriptTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetScriptTransactionDataDefaultTypeInternal() {}
  union {
    SetScriptTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetScriptTransactionDataDefaultTypeInternal _SetScriptTransactionData_default_instance_;
PROTOBUF_CONSTEXPR ExchangeTransactionData::ExchangeTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_.price_)*/int64_t{0}
  , /*decltype(_impl_.buy_matcher_fee_)*/int64_t{0}
  , /*decltype(_impl_.sell_matcher_fee_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExchangeTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExchangeTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExchangeTransactionDataDefaultTypeInternal() {}
  union {
    ExchangeTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExchangeTransactionDataDefaultTypeInternal _ExchangeTransactionData_default_instance_;
PROTOBUF_CONSTEXPR SponsorFeeTransactionData::SponsorFeeTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.min_fee_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SponsorFeeTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SponsorFeeTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SponsorFeeTransactionDataDefaultTypeInternal() {}
  union {
    SponsorFeeTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SponsorFeeTransactionDataDefaultTypeInternal _SponsorFeeTransactionData_default_instance_;
PROTOBUF_CONSTEXPR InvokeScriptTransactionData::InvokeScriptTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payments_)*/{}
  , /*decltype(_impl_.function_call_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.d_app_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InvokeScriptTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InvokeScriptTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InvokeScriptTransactionDataDefaultTypeInternal() {}
  union {
    InvokeScriptTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InvokeScriptTransactionDataDefaultTypeInternal _InvokeScriptTransactionData_default_instance_;
PROTOBUF_CONSTEXPR UpdateAssetInfoTransactionData::UpdateAssetInfoTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asset_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateAssetInfoTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateAssetInfoTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateAssetInfoTransactionDataDefaultTypeInternal() {}
  union {
    UpdateAssetInfoTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateAssetInfoTransactionDataDefaultTypeInternal _UpdateAssetInfoTransactionData_default_instance_;
PROTOBUF_CONSTEXPR InvokeExpressionTransactionData::InvokeExpressionTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.expression_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InvokeExpressionTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InvokeExpressionTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InvokeExpressionTransactionDataDefaultTypeInternal() {}
  union {
    InvokeExpressionTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InvokeExpressionTransactionDataDefaultTypeInternal _InvokeExpressionTransactionData_default_instance_;
PROTOBUF_CONSTEXPR PrivatePaymentTransactionData::PrivatePaymentTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recipient_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PrivatePaymentTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrivatePaymentTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrivatePaymentTransactionDataDefaultTypeInternal() {}
  union {
    PrivatePaymentTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrivatePaymentTransactionDataDefaultTypeInternal _PrivatePaymentTransactionData_default_instance_;
}  // namespace vrp
static ::_pb::Metadata file_level_metadata_vrp_2ftransaction_2eproto[23];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_vrp_2ftransaction_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_vrp_2ftransaction_2eproto = nullptr;

const uint32_t TableStruct_vrp_2ftransaction_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::SignedTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vrp::SignedTransaction, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vrp::SignedTransaction, _impl_.proofs_),
  PROTOBUF_FIELD_OFFSET(::vrp::SignedTransaction, _impl_.transaction_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _impl_.chain_id_),
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _impl_.sender_public_key_),
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _impl_.fee_),
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _impl_.version_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vrp::Transaction, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::GenesisTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::GenesisTransactionData, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::vrp::GenesisTransactionData, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::PaymentTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::PaymentTransactionData, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::vrp::PaymentTransactionData, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::TransferTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::TransferTransactionData, _impl_.recipient_),
  PROTOBUF_FIELD_OFFSET(::vrp::TransferTransactionData, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::vrp::TransferTransactionData, _impl_.attachment_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::CreateAliasTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::CreateAliasTransactionData, _impl_.alias_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::DataTransactionData_DataEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vrp::DataTransactionData_DataEntry, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::DataTransactionData_DataEntry, _impl_.key_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vrp::DataTransactionData_DataEntry, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::DataTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::DataTransactionData, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::MassTransferTransactionData_Transfer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::MassTransferTransactionData_Transfer, _impl_.recipient_),
  PROTOBUF_FIELD_OFFSET(::vrp::MassTransferTransactionData_Transfer, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::MassTransferTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::MassTransferTransactionData, _impl_.asset_id_),
  PROTOBUF_FIELD_OFFSET(::vrp::MassTransferTransactionData, _impl_.transfers_),
  PROTOBUF_FIELD_OFFSET(::vrp::MassTransferTransactionData, _impl_.attachment_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::LeaseTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::LeaseTransactionData, _impl_.recipient_),
  PROTOBUF_FIELD_OFFSET(::vrp::LeaseTransactionData, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::LeaseCancelTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::LeaseCancelTransactionData, _impl_.lease_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::BurnTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::BurnTransactionData, _impl_.asset_amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::IssueTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::IssueTransactionData, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vrp::IssueTransactionData, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::vrp::IssueTransactionData, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::vrp::IssueTransactionData, _impl_.decimals_),
  PROTOBUF_FIELD_OFFSET(::vrp::IssueTransactionData, _impl_.reissuable_),
  PROTOBUF_FIELD_OFFSET(::vrp::IssueTransactionData, _impl_.script_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::ReissueTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::ReissueTransactionData, _impl_.asset_amount_),
  PROTOBUF_FIELD_OFFSET(::vrp::ReissueTransactionData, _impl_.reissuable_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::SetAssetScriptTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::SetAssetScriptTransactionData, _impl_.asset_id_),
  PROTOBUF_FIELD_OFFSET(::vrp::SetAssetScriptTransactionData, _impl_.script_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::SetScriptTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::SetScriptTransactionData, _impl_.script_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::ExchangeTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::ExchangeTransactionData, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::vrp::ExchangeTransactionData, _impl_.price_),
  PROTOBUF_FIELD_OFFSET(::vrp::ExchangeTransactionData, _impl_.buy_matcher_fee_),
  PROTOBUF_FIELD_OFFSET(::vrp::ExchangeTransactionData, _impl_.sell_matcher_fee_),
  PROTOBUF_FIELD_OFFSET(::vrp::ExchangeTransactionData, _impl_.orders_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::SponsorFeeTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::SponsorFeeTransactionData, _impl_.min_fee_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::InvokeScriptTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::InvokeScriptTransactionData, _impl_.d_app_),
  PROTOBUF_FIELD_OFFSET(::vrp::InvokeScriptTransactionData, _impl_.function_call_),
  PROTOBUF_FIELD_OFFSET(::vrp::InvokeScriptTransactionData, _impl_.payments_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::UpdateAssetInfoTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::UpdateAssetInfoTransactionData, _impl_.asset_id_),
  PROTOBUF_FIELD_OFFSET(::vrp::UpdateAssetInfoTransactionData, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vrp::UpdateAssetInfoTransactionData, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::vrp::UpdateAssetInfoTransactionData, _impl_.image_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::InvokeExpressionTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::InvokeExpressionTransactionData, _impl_.expression_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vrp::PrivatePaymentTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vrp::PrivatePaymentTransactionData, _impl_.recipient_address_),
  PROTOBUF_FIELD_OFFSET(::vrp::PrivatePaymentTransactionData, _impl_.amount_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::vrp::SignedTransaction)},
  { 10, -1, -1, sizeof(::vrp::Transaction)},
  { 40, -1, -1, sizeof(::vrp::GenesisTransactionData)},
  { 48, -1, -1, sizeof(::vrp::PaymentTransactionData)},
  { 56, -1, -1, sizeof(::vrp::TransferTransactionData)},
  { 65, -1, -1, sizeof(::vrp::CreateAliasTransactionData)},
  { 72, -1, -1, sizeof(::vrp::DataTransactionData_DataEntry)},
  { 84, -1, -1, sizeof(::vrp::DataTransactionData)},
  { 91, -1, -1, sizeof(::vrp::MassTransferTransactionData_Transfer)},
  { 99, -1, -1, sizeof(::vrp::MassTransferTransactionData)},
  { 108, -1, -1, sizeof(::vrp::LeaseTransactionData)},
  { 116, -1, -1, sizeof(::vrp::LeaseCancelTransactionData)},
  { 123, -1, -1, sizeof(::vrp::BurnTransactionData)},
  { 130, -1, -1, sizeof(::vrp::IssueTransactionData)},
  { 142, -1, -1, sizeof(::vrp::ReissueTransactionData)},
  { 150, -1, -1, sizeof(::vrp::SetAssetScriptTransactionData)},
  { 158, -1, -1, sizeof(::vrp::SetScriptTransactionData)},
  { 165, -1, -1, sizeof(::vrp::ExchangeTransactionData)},
  { 176, -1, -1, sizeof(::vrp::SponsorFeeTransactionData)},
  { 183, -1, -1, sizeof(::vrp::InvokeScriptTransactionData)},
  { 192, -1, -1, sizeof(::vrp::UpdateAssetInfoTransactionData)},
  { 202, -1, -1, sizeof(::vrp::InvokeExpressionTransactionData)},
  { 209, -1, -1, sizeof(::vrp::PrivatePaymentTransactionData)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::vrp::_SignedTransaction_default_instance_._instance,
  &::vrp::_Transaction_default_instance_._instance,
  &::vrp::_GenesisTransactionData_default_instance_._instance,
  &::vrp::_PaymentTransactionData_default_instance_._instance,
  &::vrp::_TransferTransactionData_default_instance_._instance,
  &::vrp::_CreateAliasTransactionData_default_instance_._instance,
  &::vrp::_DataTransactionData_DataEntry_default_instance_._instance,
  &::vrp::_DataTransactionData_default_instance_._instance,
  &::vrp::_MassTransferTransactionData_Transfer_default_instance_._instance,
  &::vrp::_MassTransferTransactionData_default_instance_._instance,
  &::vrp::_LeaseTransactionData_default_instance_._instance,
  &::vrp::_LeaseCancelTransactionData_default_instance_._instance,
  &::vrp::_BurnTransactionData_default_instance_._instance,
  &::vrp::_IssueTransactionData_default_instance_._instance,
  &::vrp::_ReissueTransactionData_default_instance_._instance,
  &::vrp::_SetAssetScriptTransactionData_default_instance_._instance,
  &::vrp::_SetScriptTransactionData_default_instance_._instance,
  &::vrp::_ExchangeTransactionData_default_instance_._instance,
  &::vrp::_SponsorFeeTransactionData_default_instance_._instance,
  &::vrp::_InvokeScriptTransactionData_default_instance_._instance,
  &::vrp::_UpdateAssetInfoTransactionData_default_instance_._instance,
  &::vrp::_InvokeExpressionTransactionData_default_instance_._instance,
  &::vrp::_PrivatePaymentTransactionData_default_instance_._instance,
};

const char descriptor_table_protodef_vrp_2ftransaction_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025vrp/transaction.proto\022\003vrp\032\020vrp/amount"
  ".proto\032\023vrp/recipient.proto\032\017vrp/order.p"
  "roto\"\177\n\021SignedTransaction\022+\n\017vrp_transac"
  "tion\030\001 \001(\0132\020.vrp.TransactionH\000\022\036\n\024ethere"
  "um_transaction\030\003 \001(\014H\000\022\016\n\006proofs\030\002 \003(\014B\r"
  "\n\013transaction\"\276\010\n\013Transaction\022\020\n\010chain_i"
  "d\030\001 \001(\005\022\031\n\021sender_public_key\030\002 \001(\014\022\030\n\003fe"
  "e\030\003 \001(\0132\013.vrp.Amount\022\021\n\ttimestamp\030\004 \001(\003\022"
  "\017\n\007version\030\005 \001(\005\022.\n\007genesis\030e \001(\0132\033.vrp."
  "GenesisTransactionDataH\000\022.\n\007payment\030f \001("
  "\0132\033.vrp.PaymentTransactionDataH\000\022*\n\005issu"
  "e\030g \001(\0132\031.vrp.IssueTransactionDataH\000\0220\n\010"
  "transfer\030h \001(\0132\034.vrp.TransferTransaction"
  "DataH\000\022.\n\007reissue\030i \001(\0132\033.vrp.ReissueTra"
  "nsactionDataH\000\022(\n\004burn\030j \001(\0132\030.vrp.BurnT"
  "ransactionDataH\000\0220\n\010exchange\030k \001(\0132\034.vrp"
  ".ExchangeTransactionDataH\000\022*\n\005lease\030l \001("
  "\0132\031.vrp.LeaseTransactionDataH\000\0227\n\014lease_"
  "cancel\030m \001(\0132\037.vrp.LeaseCancelTransactio"
  "nDataH\000\0227\n\014create_alias\030n \001(\0132\037.vrp.Crea"
  "teAliasTransactionDataH\000\0229\n\rmass_transfe"
  "r\030o \001(\0132 .vrp.MassTransferTransactionDat"
  "aH\000\0224\n\020data_transaction\030p \001(\0132\030.vrp.Data"
  "TransactionDataH\000\0223\n\nset_script\030q \001(\0132\035."
  "vrp.SetScriptTransactionDataH\000\0225\n\013sponso"
  "r_fee\030r \001(\0132\036.vrp.SponsorFeeTransactionD"
  "ataH\000\022>\n\020set_asset_script\030s \001(\0132\".vrp.Se"
  "tAssetScriptTransactionDataH\000\0229\n\rinvoke_"
  "script\030t \001(\0132 .vrp.InvokeScriptTransacti"
  "onDataH\000\022@\n\021update_asset_info\030u \001(\0132#.vr"
  "p.UpdateAssetInfoTransactionDataH\000\022:\n\014an"
  "onymous_tx\030v \001(\0132\".vrp.PrivatePaymentTra"
  "nsactionDataH\000B\006\n\004data\"C\n\026GenesisTransac"
  "tionData\022\031\n\021recipient_address\030\001 \001(\014\022\016\n\006a"
  "mount\030\002 \001(\003\"C\n\026PaymentTransactionData\022\031\n"
  "\021recipient_address\030\001 \001(\014\022\016\n\006amount\030\002 \001(\003"
  "\"m\n\027TransferTransactionData\022!\n\trecipient"
  "\030\001 \001(\0132\016.vrp.Recipient\022\033\n\006amount\030\002 \001(\0132\013"
  ".vrp.Amount\022\022\n\nattachment\030\003 \001(\014\"+\n\032Creat"
  "eAliasTransactionData\022\r\n\005alias\030\001 \001(\t\"\305\001\n"
  "\023DataTransactionData\0220\n\004data\030\001 \003(\0132\".vrp"
  ".DataTransactionData.DataEntry\032|\n\tDataEn"
  "try\022\013\n\003key\030\001 \001(\t\022\023\n\tint_value\030\n \001(\003H\000\022\024\n"
  "\nbool_value\030\013 \001(\010H\000\022\026\n\014binary_value\030\014 \001("
  "\014H\000\022\026\n\014string_value\030\r \001(\tH\000B\007\n\005value\"\300\001\n"
  "\033MassTransferTransactionData\022\020\n\010asset_id"
  "\030\001 \001(\014\022<\n\ttransfers\030\002 \003(\0132).vrp.MassTran"
  "sferTransactionData.Transfer\022\022\n\nattachme"
  "nt\030\003 \001(\014\032=\n\010Transfer\022!\n\trecipient\030\001 \001(\0132"
  "\016.vrp.Recipient\022\016\n\006amount\030\002 \001(\003\"I\n\024Lease"
  "TransactionData\022!\n\trecipient\030\001 \001(\0132\016.vrp"
  ".Recipient\022\016\n\006amount\030\002 \001(\003\".\n\032LeaseCance"
  "lTransactionData\022\020\n\010lease_id\030\001 \001(\014\"8\n\023Bu"
  "rnTransactionData\022!\n\014asset_amount\030\001 \001(\0132"
  "\013.vrp.Amount\"\177\n\024IssueTransactionData\022\014\n\004"
  "name\030\001 \001(\t\022\023\n\013description\030\002 \001(\t\022\016\n\006amoun"
  "t\030\003 \001(\003\022\020\n\010decimals\030\004 \001(\005\022\022\n\nreissuable\030"
  "\005 \001(\010\022\016\n\006script\030\006 \001(\014\"O\n\026ReissueTransact"
  "ionData\022!\n\014asset_amount\030\001 \001(\0132\013.vrp.Amou"
  "nt\022\022\n\nreissuable\030\002 \001(\010\"A\n\035SetAssetScript"
  "TransactionData\022\020\n\010asset_id\030\001 \001(\014\022\016\n\006scr"
  "ipt\030\002 \001(\014\"*\n\030SetScriptTransactionData\022\016\n"
  "\006script\030\001 \001(\014\"\207\001\n\027ExchangeTransactionDat"
  "a\022\016\n\006amount\030\001 \001(\003\022\r\n\005price\030\002 \001(\003\022\027\n\017buy_"
  "matcher_fee\030\003 \001(\003\022\030\n\020sell_matcher_fee\030\004 "
  "\001(\003\022\032\n\006orders\030\005 \003(\0132\n.vrp.Order\"9\n\031Spons"
  "orFeeTransactionData\022\034\n\007min_fee\030\001 \001(\0132\013."
  "vrp.Amount\"r\n\033InvokeScriptTransactionDat"
  "a\022\035\n\005d_app\030\001 \001(\0132\016.vrp.Recipient\022\025\n\rfunc"
  "tion_call\030\002 \001(\014\022\035\n\010payments\030\003 \003(\0132\013.vrp."
  "Amount\"d\n\036UpdateAssetInfoTransactionData"
  "\022\020\n\010asset_id\030\001 \001(\014\022\014\n\004name\030\002 \001(\t\022\023\n\013desc"
  "ription\030\003 \001(\t\022\r\n\005image\030\004 \001(\t\"5\n\037InvokeEx"
  "pressionTransactionData\022\022\n\nexpression\030\001 "
  "\001(\014\"J\n\035PrivatePaymentTransactionData\022\031\n\021"
  "recipient_address\030\001 \001(\014\022\016\n\006amount\030\002 \001(\003B"
  "T\n\034com.vrp.protobuf.transactionZ.github."
  "com/eVESTXCOIN/govrp/grpc/generated/vrp\252"
  "\002\003VRPb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_vrp_2ftransaction_2eproto_deps[3] = {
  &::descriptor_table_vrp_2famount_2eproto,
  &::descriptor_table_vrp_2forder_2eproto,
  &::descriptor_table_vrp_2frecipient_2eproto,
};
static ::_pbi::once_flag descriptor_table_vrp_2ftransaction_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_vrp_2ftransaction_2eproto = {
    false, false, 3133, descriptor_table_protodef_vrp_2ftransaction_2eproto,
    "vrp/transaction.proto",
    &descriptor_table_vrp_2ftransaction_2eproto_once, descriptor_table_vrp_2ftransaction_2eproto_deps, 3, 23,
    schemas, file_default_instances, TableStruct_vrp_2ftransaction_2eproto::offsets,
    file_level_metadata_vrp_2ftransaction_2eproto, file_level_enum_descriptors_vrp_2ftransaction_2eproto,
    file_level_service_descriptors_vrp_2ftransaction_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_vrp_2ftransaction_2eproto_getter() {
  return &descriptor_table_vrp_2ftransaction_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_vrp_2ftransaction_2eproto(&descriptor_table_vrp_2ftransaction_2eproto);
namespace vrp {

// ===================================================================

class SignedTransaction::_Internal {
 public:
  static const ::vrp::Transaction& vrp_transaction(const SignedTransaction* msg);
};

const ::vrp::Transaction&
SignedTransaction::_Internal::vrp_transaction(const SignedTransaction* msg) {
  return *msg->_impl_.transaction_.vrp_transaction_;
}
void SignedTransaction::set_allocated_vrp_transaction(::vrp::Transaction* vrp_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_transaction();
  if (vrp_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vrp_transaction);
    if (message_arena != submessage_arena) {
      vrp_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vrp_transaction, submessage_arena);
    }
    set_has_vrp_transaction();
    _impl_.transaction_.vrp_transaction_ = vrp_transaction;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.SignedTransaction.vrp_transaction)
}
SignedTransaction::SignedTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.SignedTransaction)
}
SignedTransaction::SignedTransaction(const SignedTransaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignedTransaction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proofs_){from._impl_.proofs_}
    , decltype(_impl_.transaction_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_transaction();
  switch (from.transaction_case()) {
    case kVrpTransaction: {
      _this->_internal_mutable_vrp_transaction()->::vrp::Transaction::MergeFrom(
          from._internal_vrp_transaction());
      break;
    }
    case kEthereumTransaction: {
      _this->_internal_set_ethereum_transaction(from._internal_ethereum_transaction());
      break;
    }
    case TRANSACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vrp.SignedTransaction)
}

inline void SignedTransaction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.proofs_){arena}
    , decltype(_impl_.transaction_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_transaction();
}

SignedTransaction::~SignedTransaction() {
  // @@protoc_insertion_point(destructor:vrp.SignedTransaction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignedTransaction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proofs_.~RepeatedPtrField();
  if (has_transaction()) {
    clear_transaction();
  }
}

void SignedTransaction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignedTransaction::clear_transaction() {
// @@protoc_insertion_point(one_of_clear_start:vrp.SignedTransaction)
  switch (transaction_case()) {
    case kVrpTransaction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.transaction_.vrp_transaction_;
      }
      break;
    }
    case kEthereumTransaction: {
      _impl_.transaction_.ethereum_transaction_.Destroy();
      break;
    }
    case TRANSACTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TRANSACTION_NOT_SET;
}


void SignedTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.SignedTransaction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proofs_.Clear();
  clear_transaction();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignedTransaction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Transaction vrp_transaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_vrp_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes proofs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_proofs();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes ethereum_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ethereum_transaction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignedTransaction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.SignedTransaction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Transaction vrp_transaction = 1;
  if (_internal_has_vrp_transaction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::vrp_transaction(this),
        _Internal::vrp_transaction(this).GetCachedSize(), target, stream);
  }

  // repeated bytes proofs = 2;
  for (int i = 0, n = this->_internal_proofs_size(); i < n; i++) {
    const auto& s = this->_internal_proofs(i);
    target = stream->WriteBytes(2, s, target);
  }

  // bytes ethereum_transaction = 3;
  if (_internal_has_ethereum_transaction()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ethereum_transaction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.SignedTransaction)
  return target;
}

size_t SignedTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.SignedTransaction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes proofs = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.proofs_.size());
  for (int i = 0, n = _impl_.proofs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.proofs_.Get(i));
  }

  switch (transaction_case()) {
    // .vrp.Transaction vrp_transaction = 1;
    case kVrpTransaction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transaction_.vrp_transaction_);
      break;
    }
    // bytes ethereum_transaction = 3;
    case kEthereumTransaction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ethereum_transaction());
      break;
    }
    case TRANSACTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignedTransaction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignedTransaction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignedTransaction::GetClassData() const { return &_class_data_; }


void SignedTransaction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignedTransaction*>(&to_msg);
  auto& from = static_cast<const SignedTransaction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.SignedTransaction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.proofs_.MergeFrom(from._impl_.proofs_);
  switch (from.transaction_case()) {
    case kVrpTransaction: {
      _this->_internal_mutable_vrp_transaction()->::vrp::Transaction::MergeFrom(
          from._internal_vrp_transaction());
      break;
    }
    case kEthereumTransaction: {
      _this->_internal_set_ethereum_transaction(from._internal_ethereum_transaction());
      break;
    }
    case TRANSACTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignedTransaction::CopyFrom(const SignedTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.SignedTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedTransaction::IsInitialized() const {
  return true;
}

void SignedTransaction::InternalSwap(SignedTransaction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.proofs_.InternalSwap(&other->_impl_.proofs_);
  swap(_impl_.transaction_, other->_impl_.transaction_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignedTransaction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[0]);
}

// ===================================================================

class Transaction::_Internal {
 public:
  static const ::vrp::Amount& fee(const Transaction* msg);
  static const ::vrp::GenesisTransactionData& genesis(const Transaction* msg);
  static const ::vrp::PaymentTransactionData& payment(const Transaction* msg);
  static const ::vrp::IssueTransactionData& issue(const Transaction* msg);
  static const ::vrp::TransferTransactionData& transfer(const Transaction* msg);
  static const ::vrp::ReissueTransactionData& reissue(const Transaction* msg);
  static const ::vrp::BurnTransactionData& burn(const Transaction* msg);
  static const ::vrp::ExchangeTransactionData& exchange(const Transaction* msg);
  static const ::vrp::LeaseTransactionData& lease(const Transaction* msg);
  static const ::vrp::LeaseCancelTransactionData& lease_cancel(const Transaction* msg);
  static const ::vrp::CreateAliasTransactionData& create_alias(const Transaction* msg);
  static const ::vrp::MassTransferTransactionData& mass_transfer(const Transaction* msg);
  static const ::vrp::DataTransactionData& data_transaction(const Transaction* msg);
  static const ::vrp::SetScriptTransactionData& set_script(const Transaction* msg);
  static const ::vrp::SponsorFeeTransactionData& sponsor_fee(const Transaction* msg);
  static const ::vrp::SetAssetScriptTransactionData& set_asset_script(const Transaction* msg);
  static const ::vrp::InvokeScriptTransactionData& invoke_script(const Transaction* msg);
  static const ::vrp::UpdateAssetInfoTransactionData& update_asset_info(const Transaction* msg);
  static const ::vrp::PrivatePaymentTransactionData& anonymous_tx(const Transaction* msg);
};

const ::vrp::Amount&
Transaction::_Internal::fee(const Transaction* msg) {
  return *msg->_impl_.fee_;
}
const ::vrp::GenesisTransactionData&
Transaction::_Internal::genesis(const Transaction* msg) {
  return *msg->_impl_.data_.genesis_;
}
const ::vrp::PaymentTransactionData&
Transaction::_Internal::payment(const Transaction* msg) {
  return *msg->_impl_.data_.payment_;
}
const ::vrp::IssueTransactionData&
Transaction::_Internal::issue(const Transaction* msg) {
  return *msg->_impl_.data_.issue_;
}
const ::vrp::TransferTransactionData&
Transaction::_Internal::transfer(const Transaction* msg) {
  return *msg->_impl_.data_.transfer_;
}
const ::vrp::ReissueTransactionData&
Transaction::_Internal::reissue(const Transaction* msg) {
  return *msg->_impl_.data_.reissue_;
}
const ::vrp::BurnTransactionData&
Transaction::_Internal::burn(const Transaction* msg) {
  return *msg->_impl_.data_.burn_;
}
const ::vrp::ExchangeTransactionData&
Transaction::_Internal::exchange(const Transaction* msg) {
  return *msg->_impl_.data_.exchange_;
}
const ::vrp::LeaseTransactionData&
Transaction::_Internal::lease(const Transaction* msg) {
  return *msg->_impl_.data_.lease_;
}
const ::vrp::LeaseCancelTransactionData&
Transaction::_Internal::lease_cancel(const Transaction* msg) {
  return *msg->_impl_.data_.lease_cancel_;
}
const ::vrp::CreateAliasTransactionData&
Transaction::_Internal::create_alias(const Transaction* msg) {
  return *msg->_impl_.data_.create_alias_;
}
const ::vrp::MassTransferTransactionData&
Transaction::_Internal::mass_transfer(const Transaction* msg) {
  return *msg->_impl_.data_.mass_transfer_;
}
const ::vrp::DataTransactionData&
Transaction::_Internal::data_transaction(const Transaction* msg) {
  return *msg->_impl_.data_.data_transaction_;
}
const ::vrp::SetScriptTransactionData&
Transaction::_Internal::set_script(const Transaction* msg) {
  return *msg->_impl_.data_.set_script_;
}
const ::vrp::SponsorFeeTransactionData&
Transaction::_Internal::sponsor_fee(const Transaction* msg) {
  return *msg->_impl_.data_.sponsor_fee_;
}
const ::vrp::SetAssetScriptTransactionData&
Transaction::_Internal::set_asset_script(const Transaction* msg) {
  return *msg->_impl_.data_.set_asset_script_;
}
const ::vrp::InvokeScriptTransactionData&
Transaction::_Internal::invoke_script(const Transaction* msg) {
  return *msg->_impl_.data_.invoke_script_;
}
const ::vrp::UpdateAssetInfoTransactionData&
Transaction::_Internal::update_asset_info(const Transaction* msg) {
  return *msg->_impl_.data_.update_asset_info_;
}
const ::vrp::PrivatePaymentTransactionData&
Transaction::_Internal::anonymous_tx(const Transaction* msg) {
  return *msg->_impl_.data_.anonymous_tx_;
}
void Transaction::clear_fee() {
  if (GetArenaForAllocation() == nullptr && _impl_.fee_ != nullptr) {
    delete _impl_.fee_;
  }
  _impl_.fee_ = nullptr;
}
void Transaction::set_allocated_genesis(::vrp::GenesisTransactionData* genesis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (genesis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(genesis);
    if (message_arena != submessage_arena) {
      genesis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, genesis, submessage_arena);
    }
    set_has_genesis();
    _impl_.data_.genesis_ = genesis;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.genesis)
}
void Transaction::set_allocated_payment(::vrp::PaymentTransactionData* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payment);
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    set_has_payment();
    _impl_.data_.payment_ = payment;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.payment)
}
void Transaction::set_allocated_issue(::vrp::IssueTransactionData* issue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (issue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(issue);
    if (message_arena != submessage_arena) {
      issue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, issue, submessage_arena);
    }
    set_has_issue();
    _impl_.data_.issue_ = issue;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.issue)
}
void Transaction::set_allocated_transfer(::vrp::TransferTransactionData* transfer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (transfer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transfer);
    if (message_arena != submessage_arena) {
      transfer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transfer, submessage_arena);
    }
    set_has_transfer();
    _impl_.data_.transfer_ = transfer;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.transfer)
}
void Transaction::set_allocated_reissue(::vrp::ReissueTransactionData* reissue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (reissue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reissue);
    if (message_arena != submessage_arena) {
      reissue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reissue, submessage_arena);
    }
    set_has_reissue();
    _impl_.data_.reissue_ = reissue;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.reissue)
}
void Transaction::set_allocated_burn(::vrp::BurnTransactionData* burn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (burn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(burn);
    if (message_arena != submessage_arena) {
      burn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, burn, submessage_arena);
    }
    set_has_burn();
    _impl_.data_.burn_ = burn;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.burn)
}
void Transaction::set_allocated_exchange(::vrp::ExchangeTransactionData* exchange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (exchange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exchange);
    if (message_arena != submessage_arena) {
      exchange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exchange, submessage_arena);
    }
    set_has_exchange();
    _impl_.data_.exchange_ = exchange;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.exchange)
}
void Transaction::set_allocated_lease(::vrp::LeaseTransactionData* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lease);
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    set_has_lease();
    _impl_.data_.lease_ = lease;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.lease)
}
void Transaction::set_allocated_lease_cancel(::vrp::LeaseCancelTransactionData* lease_cancel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (lease_cancel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lease_cancel);
    if (message_arena != submessage_arena) {
      lease_cancel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_cancel, submessage_arena);
    }
    set_has_lease_cancel();
    _impl_.data_.lease_cancel_ = lease_cancel;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.lease_cancel)
}
void Transaction::set_allocated_create_alias(::vrp::CreateAliasTransactionData* create_alias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (create_alias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_alias);
    if (message_arena != submessage_arena) {
      create_alias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_alias, submessage_arena);
    }
    set_has_create_alias();
    _impl_.data_.create_alias_ = create_alias;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.create_alias)
}
void Transaction::set_allocated_mass_transfer(::vrp::MassTransferTransactionData* mass_transfer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (mass_transfer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mass_transfer);
    if (message_arena != submessage_arena) {
      mass_transfer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mass_transfer, submessage_arena);
    }
    set_has_mass_transfer();
    _impl_.data_.mass_transfer_ = mass_transfer;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.mass_transfer)
}
void Transaction::set_allocated_data_transaction(::vrp::DataTransactionData* data_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (data_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_transaction);
    if (message_arena != submessage_arena) {
      data_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_transaction, submessage_arena);
    }
    set_has_data_transaction();
    _impl_.data_.data_transaction_ = data_transaction;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.data_transaction)
}
void Transaction::set_allocated_set_script(::vrp::SetScriptTransactionData* set_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (set_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_script);
    if (message_arena != submessage_arena) {
      set_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_script, submessage_arena);
    }
    set_has_set_script();
    _impl_.data_.set_script_ = set_script;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.set_script)
}
void Transaction::set_allocated_sponsor_fee(::vrp::SponsorFeeTransactionData* sponsor_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (sponsor_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sponsor_fee);
    if (message_arena != submessage_arena) {
      sponsor_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sponsor_fee, submessage_arena);
    }
    set_has_sponsor_fee();
    _impl_.data_.sponsor_fee_ = sponsor_fee;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.sponsor_fee)
}
void Transaction::set_allocated_set_asset_script(::vrp::SetAssetScriptTransactionData* set_asset_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (set_asset_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_asset_script);
    if (message_arena != submessage_arena) {
      set_asset_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_asset_script, submessage_arena);
    }
    set_has_set_asset_script();
    _impl_.data_.set_asset_script_ = set_asset_script;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.set_asset_script)
}
void Transaction::set_allocated_invoke_script(::vrp::InvokeScriptTransactionData* invoke_script) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (invoke_script) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invoke_script);
    if (message_arena != submessage_arena) {
      invoke_script = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoke_script, submessage_arena);
    }
    set_has_invoke_script();
    _impl_.data_.invoke_script_ = invoke_script;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.invoke_script)
}
void Transaction::set_allocated_update_asset_info(::vrp::UpdateAssetInfoTransactionData* update_asset_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (update_asset_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_asset_info);
    if (message_arena != submessage_arena) {
      update_asset_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_asset_info, submessage_arena);
    }
    set_has_update_asset_info();
    _impl_.data_.update_asset_info_ = update_asset_info;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.update_asset_info)
}
void Transaction::set_allocated_anonymous_tx(::vrp::PrivatePaymentTransactionData* anonymous_tx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (anonymous_tx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(anonymous_tx);
    if (message_arena != submessage_arena) {
      anonymous_tx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anonymous_tx, submessage_arena);
    }
    set_has_anonymous_tx();
    _impl_.data_.anonymous_tx_ = anonymous_tx;
  }
  // @@protoc_insertion_point(field_set_allocated:vrp.Transaction.anonymous_tx)
}
Transaction::Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.Transaction)
}
Transaction::Transaction(const Transaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Transaction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sender_public_key_){}
    , decltype(_impl_.fee_){nullptr}
    , decltype(_impl_.chain_id_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sender_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sender_public_key().empty()) {
    _this->_impl_.sender_public_key_.Set(from._internal_sender_public_key(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fee()) {
    _this->_impl_.fee_ = new ::vrp::Amount(*from._impl_.fee_);
  }
  ::memcpy(&_impl_.chain_id_, &from._impl_.chain_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.chain_id_)) + sizeof(_impl_.timestamp_));
  clear_has_data();
  switch (from.data_case()) {
    case kGenesis: {
      _this->_internal_mutable_genesis()->::vrp::GenesisTransactionData::MergeFrom(
          from._internal_genesis());
      break;
    }
    case kPayment: {
      _this->_internal_mutable_payment()->::vrp::PaymentTransactionData::MergeFrom(
          from._internal_payment());
      break;
    }
    case kIssue: {
      _this->_internal_mutable_issue()->::vrp::IssueTransactionData::MergeFrom(
          from._internal_issue());
      break;
    }
    case kTransfer: {
      _this->_internal_mutable_transfer()->::vrp::TransferTransactionData::MergeFrom(
          from._internal_transfer());
      break;
    }
    case kReissue: {
      _this->_internal_mutable_reissue()->::vrp::ReissueTransactionData::MergeFrom(
          from._internal_reissue());
      break;
    }
    case kBurn: {
      _this->_internal_mutable_burn()->::vrp::BurnTransactionData::MergeFrom(
          from._internal_burn());
      break;
    }
    case kExchange: {
      _this->_internal_mutable_exchange()->::vrp::ExchangeTransactionData::MergeFrom(
          from._internal_exchange());
      break;
    }
    case kLease: {
      _this->_internal_mutable_lease()->::vrp::LeaseTransactionData::MergeFrom(
          from._internal_lease());
      break;
    }
    case kLeaseCancel: {
      _this->_internal_mutable_lease_cancel()->::vrp::LeaseCancelTransactionData::MergeFrom(
          from._internal_lease_cancel());
      break;
    }
    case kCreateAlias: {
      _this->_internal_mutable_create_alias()->::vrp::CreateAliasTransactionData::MergeFrom(
          from._internal_create_alias());
      break;
    }
    case kMassTransfer: {
      _this->_internal_mutable_mass_transfer()->::vrp::MassTransferTransactionData::MergeFrom(
          from._internal_mass_transfer());
      break;
    }
    case kDataTransaction: {
      _this->_internal_mutable_data_transaction()->::vrp::DataTransactionData::MergeFrom(
          from._internal_data_transaction());
      break;
    }
    case kSetScript: {
      _this->_internal_mutable_set_script()->::vrp::SetScriptTransactionData::MergeFrom(
          from._internal_set_script());
      break;
    }
    case kSponsorFee: {
      _this->_internal_mutable_sponsor_fee()->::vrp::SponsorFeeTransactionData::MergeFrom(
          from._internal_sponsor_fee());
      break;
    }
    case kSetAssetScript: {
      _this->_internal_mutable_set_asset_script()->::vrp::SetAssetScriptTransactionData::MergeFrom(
          from._internal_set_asset_script());
      break;
    }
    case kInvokeScript: {
      _this->_internal_mutable_invoke_script()->::vrp::InvokeScriptTransactionData::MergeFrom(
          from._internal_invoke_script());
      break;
    }
    case kUpdateAssetInfo: {
      _this->_internal_mutable_update_asset_info()->::vrp::UpdateAssetInfoTransactionData::MergeFrom(
          from._internal_update_asset_info());
      break;
    }
    case kAnonymousTx: {
      _this->_internal_mutable_anonymous_tx()->::vrp::PrivatePaymentTransactionData::MergeFrom(
          from._internal_anonymous_tx());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vrp.Transaction)
}

inline void Transaction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sender_public_key_){}
    , decltype(_impl_.fee_){nullptr}
    , decltype(_impl_.chain_id_){0}
    , decltype(_impl_.version_){0}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.sender_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_data();
}

Transaction::~Transaction() {
  // @@protoc_insertion_point(destructor:vrp.Transaction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Transaction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sender_public_key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fee_;
  if (has_data()) {
    clear_data();
  }
}

void Transaction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Transaction::clear_data() {
// @@protoc_insertion_point(one_of_clear_start:vrp.Transaction)
  switch (data_case()) {
    case kGenesis: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.genesis_;
      }
      break;
    }
    case kPayment: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.payment_;
      }
      break;
    }
    case kIssue: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.issue_;
      }
      break;
    }
    case kTransfer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.transfer_;
      }
      break;
    }
    case kReissue: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.reissue_;
      }
      break;
    }
    case kBurn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.burn_;
      }
      break;
    }
    case kExchange: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.exchange_;
      }
      break;
    }
    case kLease: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.lease_;
      }
      break;
    }
    case kLeaseCancel: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.lease_cancel_;
      }
      break;
    }
    case kCreateAlias: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.create_alias_;
      }
      break;
    }
    case kMassTransfer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.mass_transfer_;
      }
      break;
    }
    case kDataTransaction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.data_transaction_;
      }
      break;
    }
    case kSetScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.set_script_;
      }
      break;
    }
    case kSponsorFee: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.sponsor_fee_;
      }
      break;
    }
    case kSetAssetScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.set_asset_script_;
      }
      break;
    }
    case kInvokeScript: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.invoke_script_;
      }
      break;
    }
    case kUpdateAssetInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.update_asset_info_;
      }
      break;
    }
    case kAnonymousTx: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.data_.anonymous_tx_;
      }
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}


void Transaction::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.Transaction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sender_public_key_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.fee_ != nullptr) {
    delete _impl_.fee_;
  }
  _impl_.fee_ = nullptr;
  ::memset(&_impl_.chain_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.timestamp_) -
      reinterpret_cast<char*>(&_impl_.chain_id_)) + sizeof(_impl_.timestamp_));
  clear_data();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Transaction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 chain_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.chain_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes sender_public_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sender_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.Amount fee = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fee(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.GenesisTransactionData genesis = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_genesis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.PaymentTransactionData payment = 102;
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_payment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.IssueTransactionData issue = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_issue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.TransferTransactionData transfer = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_transfer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.ReissueTransactionData reissue = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_reissue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.BurnTransactionData burn = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_burn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.ExchangeTransactionData exchange = 107;
      case 107:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_exchange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.LeaseTransactionData lease = 108;
      case 108:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.LeaseCancelTransactionData lease_cancel = 109;
      case 109:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease_cancel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.CreateAliasTransactionData create_alias = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_alias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.MassTransferTransactionData mass_transfer = 111;
      case 111:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_mass_transfer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.DataTransactionData data_transaction = 112;
      case 112:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_data_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.SetScriptTransactionData set_script = 113;
      case 113:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.SponsorFeeTransactionData sponsor_fee = 114;
      case 114:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_sponsor_fee(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.SetAssetScriptTransactionData set_asset_script = 115;
      case 115:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_asset_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.InvokeScriptTransactionData invoke_script = 116;
      case 116:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_invoke_script(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.UpdateAssetInfoTransactionData update_asset_info = 117;
      case 117:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_asset_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.PrivatePaymentTransactionData anonymous_tx = 118;
      case 118:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_anonymous_tx(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Transaction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.Transaction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 chain_id = 1;
  if (this->_internal_chain_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_chain_id(), target);
  }

  // bytes sender_public_key = 2;
  if (!this->_internal_sender_public_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sender_public_key(), target);
  }

  // .vrp.Amount fee = 3;
  if (this->_internal_has_fee()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fee(this),
        _Internal::fee(this).GetCachedSize(), target, stream);
  }

  // int64 timestamp = 4;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_timestamp(), target);
  }

  // int32 version = 5;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_version(), target);
  }

  // .vrp.GenesisTransactionData genesis = 101;
  if (_internal_has_genesis()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(101, _Internal::genesis(this),
        _Internal::genesis(this).GetCachedSize(), target, stream);
  }

  // .vrp.PaymentTransactionData payment = 102;
  if (_internal_has_payment()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(102, _Internal::payment(this),
        _Internal::payment(this).GetCachedSize(), target, stream);
  }

  // .vrp.IssueTransactionData issue = 103;
  if (_internal_has_issue()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(103, _Internal::issue(this),
        _Internal::issue(this).GetCachedSize(), target, stream);
  }

  // .vrp.TransferTransactionData transfer = 104;
  if (_internal_has_transfer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(104, _Internal::transfer(this),
        _Internal::transfer(this).GetCachedSize(), target, stream);
  }

  // .vrp.ReissueTransactionData reissue = 105;
  if (_internal_has_reissue()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(105, _Internal::reissue(this),
        _Internal::reissue(this).GetCachedSize(), target, stream);
  }

  // .vrp.BurnTransactionData burn = 106;
  if (_internal_has_burn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(106, _Internal::burn(this),
        _Internal::burn(this).GetCachedSize(), target, stream);
  }

  // .vrp.ExchangeTransactionData exchange = 107;
  if (_internal_has_exchange()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(107, _Internal::exchange(this),
        _Internal::exchange(this).GetCachedSize(), target, stream);
  }

  // .vrp.LeaseTransactionData lease = 108;
  if (_internal_has_lease()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(108, _Internal::lease(this),
        _Internal::lease(this).GetCachedSize(), target, stream);
  }

  // .vrp.LeaseCancelTransactionData lease_cancel = 109;
  if (_internal_has_lease_cancel()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(109, _Internal::lease_cancel(this),
        _Internal::lease_cancel(this).GetCachedSize(), target, stream);
  }

  // .vrp.CreateAliasTransactionData create_alias = 110;
  if (_internal_has_create_alias()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(110, _Internal::create_alias(this),
        _Internal::create_alias(this).GetCachedSize(), target, stream);
  }

  // .vrp.MassTransferTransactionData mass_transfer = 111;
  if (_internal_has_mass_transfer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(111, _Internal::mass_transfer(this),
        _Internal::mass_transfer(this).GetCachedSize(), target, stream);
  }

  // .vrp.DataTransactionData data_transaction = 112;
  if (_internal_has_data_transaction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(112, _Internal::data_transaction(this),
        _Internal::data_transaction(this).GetCachedSize(), target, stream);
  }

  // .vrp.SetScriptTransactionData set_script = 113;
  if (_internal_has_set_script()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(113, _Internal::set_script(this),
        _Internal::set_script(this).GetCachedSize(), target, stream);
  }

  // .vrp.SponsorFeeTransactionData sponsor_fee = 114;
  if (_internal_has_sponsor_fee()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(114, _Internal::sponsor_fee(this),
        _Internal::sponsor_fee(this).GetCachedSize(), target, stream);
  }

  // .vrp.SetAssetScriptTransactionData set_asset_script = 115;
  if (_internal_has_set_asset_script()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(115, _Internal::set_asset_script(this),
        _Internal::set_asset_script(this).GetCachedSize(), target, stream);
  }

  // .vrp.InvokeScriptTransactionData invoke_script = 116;
  if (_internal_has_invoke_script()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(116, _Internal::invoke_script(this),
        _Internal::invoke_script(this).GetCachedSize(), target, stream);
  }

  // .vrp.UpdateAssetInfoTransactionData update_asset_info = 117;
  if (_internal_has_update_asset_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(117, _Internal::update_asset_info(this),
        _Internal::update_asset_info(this).GetCachedSize(), target, stream);
  }

  // .vrp.PrivatePaymentTransactionData anonymous_tx = 118;
  if (_internal_has_anonymous_tx()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(118, _Internal::anonymous_tx(this),
        _Internal::anonymous_tx(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.Transaction)
  return target;
}

size_t Transaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.Transaction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes sender_public_key = 2;
  if (!this->_internal_sender_public_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sender_public_key());
  }

  // .vrp.Amount fee = 3;
  if (this->_internal_has_fee()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fee_);
  }

  // int32 chain_id = 1;
  if (this->_internal_chain_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chain_id());
  }

  // int32 version = 5;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
  }

  // int64 timestamp = 4;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  switch (data_case()) {
    // .vrp.GenesisTransactionData genesis = 101;
    case kGenesis: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.genesis_);
      break;
    }
    // .vrp.PaymentTransactionData payment = 102;
    case kPayment: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.payment_);
      break;
    }
    // .vrp.IssueTransactionData issue = 103;
    case kIssue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.issue_);
      break;
    }
    // .vrp.TransferTransactionData transfer = 104;
    case kTransfer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.transfer_);
      break;
    }
    // .vrp.ReissueTransactionData reissue = 105;
    case kReissue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.reissue_);
      break;
    }
    // .vrp.BurnTransactionData burn = 106;
    case kBurn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.burn_);
      break;
    }
    // .vrp.ExchangeTransactionData exchange = 107;
    case kExchange: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.exchange_);
      break;
    }
    // .vrp.LeaseTransactionData lease = 108;
    case kLease: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.lease_);
      break;
    }
    // .vrp.LeaseCancelTransactionData lease_cancel = 109;
    case kLeaseCancel: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.lease_cancel_);
      break;
    }
    // .vrp.CreateAliasTransactionData create_alias = 110;
    case kCreateAlias: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.create_alias_);
      break;
    }
    // .vrp.MassTransferTransactionData mass_transfer = 111;
    case kMassTransfer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.mass_transfer_);
      break;
    }
    // .vrp.DataTransactionData data_transaction = 112;
    case kDataTransaction: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.data_transaction_);
      break;
    }
    // .vrp.SetScriptTransactionData set_script = 113;
    case kSetScript: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.set_script_);
      break;
    }
    // .vrp.SponsorFeeTransactionData sponsor_fee = 114;
    case kSponsorFee: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.sponsor_fee_);
      break;
    }
    // .vrp.SetAssetScriptTransactionData set_asset_script = 115;
    case kSetAssetScript: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.set_asset_script_);
      break;
    }
    // .vrp.InvokeScriptTransactionData invoke_script = 116;
    case kInvokeScript: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.invoke_script_);
      break;
    }
    // .vrp.UpdateAssetInfoTransactionData update_asset_info = 117;
    case kUpdateAssetInfo: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.update_asset_info_);
      break;
    }
    // .vrp.PrivatePaymentTransactionData anonymous_tx = 118;
    case kAnonymousTx: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_.anonymous_tx_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transaction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Transaction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transaction::GetClassData() const { return &_class_data_; }


void Transaction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Transaction*>(&to_msg);
  auto& from = static_cast<const Transaction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.Transaction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sender_public_key().empty()) {
    _this->_internal_set_sender_public_key(from._internal_sender_public_key());
  }
  if (from._internal_has_fee()) {
    _this->_internal_mutable_fee()->::vrp::Amount::MergeFrom(
        from._internal_fee());
  }
  if (from._internal_chain_id() != 0) {
    _this->_internal_set_chain_id(from._internal_chain_id());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  switch (from.data_case()) {
    case kGenesis: {
      _this->_internal_mutable_genesis()->::vrp::GenesisTransactionData::MergeFrom(
          from._internal_genesis());
      break;
    }
    case kPayment: {
      _this->_internal_mutable_payment()->::vrp::PaymentTransactionData::MergeFrom(
          from._internal_payment());
      break;
    }
    case kIssue: {
      _this->_internal_mutable_issue()->::vrp::IssueTransactionData::MergeFrom(
          from._internal_issue());
      break;
    }
    case kTransfer: {
      _this->_internal_mutable_transfer()->::vrp::TransferTransactionData::MergeFrom(
          from._internal_transfer());
      break;
    }
    case kReissue: {
      _this->_internal_mutable_reissue()->::vrp::ReissueTransactionData::MergeFrom(
          from._internal_reissue());
      break;
    }
    case kBurn: {
      _this->_internal_mutable_burn()->::vrp::BurnTransactionData::MergeFrom(
          from._internal_burn());
      break;
    }
    case kExchange: {
      _this->_internal_mutable_exchange()->::vrp::ExchangeTransactionData::MergeFrom(
          from._internal_exchange());
      break;
    }
    case kLease: {
      _this->_internal_mutable_lease()->::vrp::LeaseTransactionData::MergeFrom(
          from._internal_lease());
      break;
    }
    case kLeaseCancel: {
      _this->_internal_mutable_lease_cancel()->::vrp::LeaseCancelTransactionData::MergeFrom(
          from._internal_lease_cancel());
      break;
    }
    case kCreateAlias: {
      _this->_internal_mutable_create_alias()->::vrp::CreateAliasTransactionData::MergeFrom(
          from._internal_create_alias());
      break;
    }
    case kMassTransfer: {
      _this->_internal_mutable_mass_transfer()->::vrp::MassTransferTransactionData::MergeFrom(
          from._internal_mass_transfer());
      break;
    }
    case kDataTransaction: {
      _this->_internal_mutable_data_transaction()->::vrp::DataTransactionData::MergeFrom(
          from._internal_data_transaction());
      break;
    }
    case kSetScript: {
      _this->_internal_mutable_set_script()->::vrp::SetScriptTransactionData::MergeFrom(
          from._internal_set_script());
      break;
    }
    case kSponsorFee: {
      _this->_internal_mutable_sponsor_fee()->::vrp::SponsorFeeTransactionData::MergeFrom(
          from._internal_sponsor_fee());
      break;
    }
    case kSetAssetScript: {
      _this->_internal_mutable_set_asset_script()->::vrp::SetAssetScriptTransactionData::MergeFrom(
          from._internal_set_asset_script());
      break;
    }
    case kInvokeScript: {
      _this->_internal_mutable_invoke_script()->::vrp::InvokeScriptTransactionData::MergeFrom(
          from._internal_invoke_script());
      break;
    }
    case kUpdateAssetInfo: {
      _this->_internal_mutable_update_asset_info()->::vrp::UpdateAssetInfoTransactionData::MergeFrom(
          from._internal_update_asset_info());
      break;
    }
    case kAnonymousTx: {
      _this->_internal_mutable_anonymous_tx()->::vrp::PrivatePaymentTransactionData::MergeFrom(
          from._internal_anonymous_tx());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Transaction::CopyFrom(const Transaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.Transaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transaction::IsInitialized() const {
  return true;
}

void Transaction::InternalSwap(Transaction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sender_public_key_, lhs_arena,
      &other->_impl_.sender_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Transaction, _impl_.timestamp_)
      + sizeof(Transaction::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(Transaction, _impl_.fee_)>(
          reinterpret_cast<char*>(&_impl_.fee_),
          reinterpret_cast<char*>(&other->_impl_.fee_));
  swap(_impl_.data_, other->_impl_.data_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Transaction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[1]);
}

// ===================================================================

class GenesisTransactionData::_Internal {
 public:
};

GenesisTransactionData::GenesisTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.GenesisTransactionData)
}
GenesisTransactionData::GenesisTransactionData(const GenesisTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GenesisTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.amount_ = from._impl_.amount_;
  // @@protoc_insertion_point(copy_constructor:vrp.GenesisTransactionData)
}

inline void GenesisTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GenesisTransactionData::~GenesisTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.GenesisTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenesisTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recipient_address_.Destroy();
}

void GenesisTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GenesisTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.GenesisTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipient_address_.ClearToEmpty();
  _impl_.amount_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenesisTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes recipient_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenesisTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.GenesisTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_recipient_address(), target);
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.GenesisTransactionData)
  return target;
}

size_t GenesisTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.GenesisTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenesisTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GenesisTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenesisTransactionData::GetClassData() const { return &_class_data_; }


void GenesisTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GenesisTransactionData*>(&to_msg);
  auto& from = static_cast<const GenesisTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.GenesisTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenesisTransactionData::CopyFrom(const GenesisTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.GenesisTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenesisTransactionData::IsInitialized() const {
  return true;
}

void GenesisTransactionData::InternalSwap(GenesisTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GenesisTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[2]);
}

// ===================================================================

class PaymentTransactionData::_Internal {
 public:
};

PaymentTransactionData::PaymentTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.PaymentTransactionData)
}
PaymentTransactionData::PaymentTransactionData(const PaymentTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PaymentTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.amount_ = from._impl_.amount_;
  // @@protoc_insertion_point(copy_constructor:vrp.PaymentTransactionData)
}

inline void PaymentTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PaymentTransactionData::~PaymentTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.PaymentTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PaymentTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recipient_address_.Destroy();
}

void PaymentTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PaymentTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.PaymentTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipient_address_.ClearToEmpty();
  _impl_.amount_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PaymentTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes recipient_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaymentTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.PaymentTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_recipient_address(), target);
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.PaymentTransactionData)
  return target;
}

size_t PaymentTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.PaymentTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PaymentTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PaymentTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PaymentTransactionData::GetClassData() const { return &_class_data_; }


void PaymentTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PaymentTransactionData*>(&to_msg);
  auto& from = static_cast<const PaymentTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.PaymentTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PaymentTransactionData::CopyFrom(const PaymentTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.PaymentTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaymentTransactionData::IsInitialized() const {
  return true;
}

void PaymentTransactionData::InternalSwap(PaymentTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PaymentTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[3]);
}

// ===================================================================

class TransferTransactionData::_Internal {
 public:
  static const ::vrp::Recipient& recipient(const TransferTransactionData* msg);
  static const ::vrp::Amount& amount(const TransferTransactionData* msg);
};

const ::vrp::Recipient&
TransferTransactionData::_Internal::recipient(const TransferTransactionData* msg) {
  return *msg->_impl_.recipient_;
}
const ::vrp::Amount&
TransferTransactionData::_Internal::amount(const TransferTransactionData* msg) {
  return *msg->_impl_.amount_;
}
void TransferTransactionData::clear_recipient() {
  if (GetArenaForAllocation() == nullptr && _impl_.recipient_ != nullptr) {
    delete _impl_.recipient_;
  }
  _impl_.recipient_ = nullptr;
}
void TransferTransactionData::clear_amount() {
  if (GetArenaForAllocation() == nullptr && _impl_.amount_ != nullptr) {
    delete _impl_.amount_;
  }
  _impl_.amount_ = nullptr;
}
TransferTransactionData::TransferTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.TransferTransactionData)
}
TransferTransactionData::TransferTransactionData(const TransferTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransferTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.attachment_){}
    , decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.attachment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_attachment().empty()) {
    _this->_impl_.attachment_.Set(from._internal_attachment(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_recipient()) {
    _this->_impl_.recipient_ = new ::vrp::Recipient(*from._impl_.recipient_);
  }
  if (from._internal_has_amount()) {
    _this->_impl_.amount_ = new ::vrp::Amount(*from._impl_.amount_);
  }
  // @@protoc_insertion_point(copy_constructor:vrp.TransferTransactionData)
}

inline void TransferTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.attachment_){}
    , decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.attachment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TransferTransactionData::~TransferTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.TransferTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransferTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachment_.Destroy();
  if (this != internal_default_instance()) delete _impl_.recipient_;
  if (this != internal_default_instance()) delete _impl_.amount_;
}

void TransferTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransferTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.TransferTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attachment_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.recipient_ != nullptr) {
    delete _impl_.recipient_;
  }
  _impl_.recipient_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.amount_ != nullptr) {
    delete _impl_.amount_;
  }
  _impl_.amount_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransferTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Recipient recipient = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_recipient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vrp.Amount amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_amount(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes attachment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_attachment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransferTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.TransferTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Recipient recipient = 1;
  if (this->_internal_has_recipient()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::recipient(this),
        _Internal::recipient(this).GetCachedSize(), target, stream);
  }

  // .vrp.Amount amount = 2;
  if (this->_internal_has_amount()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::amount(this),
        _Internal::amount(this).GetCachedSize(), target, stream);
  }

  // bytes attachment = 3;
  if (!this->_internal_attachment().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_attachment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.TransferTransactionData)
  return target;
}

size_t TransferTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.TransferTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes attachment = 3;
  if (!this->_internal_attachment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attachment());
  }

  // .vrp.Recipient recipient = 1;
  if (this->_internal_has_recipient()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.recipient_);
  }

  // .vrp.Amount amount = 2;
  if (this->_internal_has_amount()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amount_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransferTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransferTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransferTransactionData::GetClassData() const { return &_class_data_; }


void TransferTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransferTransactionData*>(&to_msg);
  auto& from = static_cast<const TransferTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.TransferTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_attachment().empty()) {
    _this->_internal_set_attachment(from._internal_attachment());
  }
  if (from._internal_has_recipient()) {
    _this->_internal_mutable_recipient()->::vrp::Recipient::MergeFrom(
        from._internal_recipient());
  }
  if (from._internal_has_amount()) {
    _this->_internal_mutable_amount()->::vrp::Amount::MergeFrom(
        from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransferTransactionData::CopyFrom(const TransferTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.TransferTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransferTransactionData::IsInitialized() const {
  return true;
}

void TransferTransactionData::InternalSwap(TransferTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attachment_, lhs_arena,
      &other->_impl_.attachment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransferTransactionData, _impl_.amount_)
      + sizeof(TransferTransactionData::_impl_.amount_)
      - PROTOBUF_FIELD_OFFSET(TransferTransactionData, _impl_.recipient_)>(
          reinterpret_cast<char*>(&_impl_.recipient_),
          reinterpret_cast<char*>(&other->_impl_.recipient_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransferTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[4]);
}

// ===================================================================

class CreateAliasTransactionData::_Internal {
 public:
};

CreateAliasTransactionData::CreateAliasTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.CreateAliasTransactionData)
}
CreateAliasTransactionData::CreateAliasTransactionData(const CreateAliasTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateAliasTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.alias_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    _this->_impl_.alias_.Set(from._internal_alias(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vrp.CreateAliasTransactionData)
}

inline void CreateAliasTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.alias_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateAliasTransactionData::~CreateAliasTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.CreateAliasTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateAliasTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.alias_.Destroy();
}

void CreateAliasTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateAliasTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.CreateAliasTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.alias_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateAliasTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string alias = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.CreateAliasTransactionData.alias"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateAliasTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.CreateAliasTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string alias = 1;
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.CreateAliasTransactionData.alias");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_alias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.CreateAliasTransactionData)
  return target;
}

size_t CreateAliasTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.CreateAliasTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string alias = 1;
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateAliasTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateAliasTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateAliasTransactionData::GetClassData() const { return &_class_data_; }


void CreateAliasTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateAliasTransactionData*>(&to_msg);
  auto& from = static_cast<const CreateAliasTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.CreateAliasTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_alias().empty()) {
    _this->_internal_set_alias(from._internal_alias());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateAliasTransactionData::CopyFrom(const CreateAliasTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.CreateAliasTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateAliasTransactionData::IsInitialized() const {
  return true;
}

void CreateAliasTransactionData::InternalSwap(CreateAliasTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.alias_, lhs_arena,
      &other->_impl_.alias_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateAliasTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[5]);
}

// ===================================================================

class DataTransactionData_DataEntry::_Internal {
 public:
};

DataTransactionData_DataEntry::DataTransactionData_DataEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.DataTransactionData.DataEntry)
}
DataTransactionData_DataEntry::DataTransactionData_DataEntry(const DataTransactionData_DataEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataTransactionData_DataEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  clear_has_value();
  switch (from.value_case()) {
    case kIntValue: {
      _this->_internal_set_int_value(from._internal_int_value());
      break;
    }
    case kBoolValue: {
      _this->_internal_set_bool_value(from._internal_bool_value());
      break;
    }
    case kBinaryValue: {
      _this->_internal_set_binary_value(from._internal_binary_value());
      break;
    }
    case kStringValue: {
      _this->_internal_set_string_value(from._internal_string_value());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vrp.DataTransactionData.DataEntry)
}

inline void DataTransactionData_DataEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_value();
}

DataTransactionData_DataEntry::~DataTransactionData_DataEntry() {
  // @@protoc_insertion_point(destructor:vrp.DataTransactionData.DataEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataTransactionData_DataEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  if (has_value()) {
    clear_value();
  }
}

void DataTransactionData_DataEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataTransactionData_DataEntry::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:vrp.DataTransactionData.DataEntry)
  switch (value_case()) {
    case kIntValue: {
      // No need to clear
      break;
    }
    case kBoolValue: {
      // No need to clear
      break;
    }
    case kBinaryValue: {
      _impl_.value_.binary_value_.Destroy();
      break;
    }
    case kStringValue: {
      _impl_.value_.string_value_.Destroy();
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}


void DataTransactionData_DataEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.DataTransactionData.DataEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  clear_value();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataTransactionData_DataEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.DataTransactionData.DataEntry.key"));
        } else
          goto handle_unusual;
        continue;
      // int64 int_value = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _internal_set_int_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bool_value = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _internal_set_bool_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes binary_value = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_binary_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string string_value = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_string_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.DataTransactionData.DataEntry.string_value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataTransactionData_DataEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.DataTransactionData.DataEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.DataTransactionData.DataEntry.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // int64 int_value = 10;
  if (_internal_has_int_value()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_int_value(), target);
  }

  // bool bool_value = 11;
  if (_internal_has_bool_value()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_bool_value(), target);
  }

  // bytes binary_value = 12;
  if (_internal_has_binary_value()) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_binary_value(), target);
  }

  // string string_value = 13;
  if (_internal_has_string_value()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_string_value().data(), static_cast<int>(this->_internal_string_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.DataTransactionData.DataEntry.string_value");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_string_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.DataTransactionData.DataEntry)
  return target;
}

size_t DataTransactionData_DataEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.DataTransactionData.DataEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  switch (value_case()) {
    // int64 int_value = 10;
    case kIntValue: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_int_value());
      break;
    }
    // bool bool_value = 11;
    case kBoolValue: {
      total_size += 1 + 1;
      break;
    }
    // bytes binary_value = 12;
    case kBinaryValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_binary_value());
      break;
    }
    // string string_value = 13;
    case kStringValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_value());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataTransactionData_DataEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataTransactionData_DataEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataTransactionData_DataEntry::GetClassData() const { return &_class_data_; }


void DataTransactionData_DataEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataTransactionData_DataEntry*>(&to_msg);
  auto& from = static_cast<const DataTransactionData_DataEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.DataTransactionData.DataEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  switch (from.value_case()) {
    case kIntValue: {
      _this->_internal_set_int_value(from._internal_int_value());
      break;
    }
    case kBoolValue: {
      _this->_internal_set_bool_value(from._internal_bool_value());
      break;
    }
    case kBinaryValue: {
      _this->_internal_set_binary_value(from._internal_binary_value());
      break;
    }
    case kStringValue: {
      _this->_internal_set_string_value(from._internal_string_value());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataTransactionData_DataEntry::CopyFrom(const DataTransactionData_DataEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.DataTransactionData.DataEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataTransactionData_DataEntry::IsInitialized() const {
  return true;
}

void DataTransactionData_DataEntry::InternalSwap(DataTransactionData_DataEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata DataTransactionData_DataEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[6]);
}

// ===================================================================

class DataTransactionData::_Internal {
 public:
};

DataTransactionData::DataTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.DataTransactionData)
}
DataTransactionData::DataTransactionData(const DataTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){from._impl_.data_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vrp.DataTransactionData)
}

inline void DataTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DataTransactionData::~DataTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.DataTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedPtrField();
}

void DataTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.DataTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vrp.DataTransactionData.DataEntry data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.DataTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vrp.DataTransactionData.DataEntry data = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.DataTransactionData)
  return target;
}

size_t DataTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.DataTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vrp.DataTransactionData.DataEntry data = 1;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->_impl_.data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataTransactionData::GetClassData() const { return &_class_data_; }


void DataTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataTransactionData*>(&to_msg);
  auto& from = static_cast<const DataTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.DataTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataTransactionData::CopyFrom(const DataTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.DataTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataTransactionData::IsInitialized() const {
  return true;
}

void DataTransactionData::InternalSwap(DataTransactionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DataTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[7]);
}

// ===================================================================

class MassTransferTransactionData_Transfer::_Internal {
 public:
  static const ::vrp::Recipient& recipient(const MassTransferTransactionData_Transfer* msg);
};

const ::vrp::Recipient&
MassTransferTransactionData_Transfer::_Internal::recipient(const MassTransferTransactionData_Transfer* msg) {
  return *msg->_impl_.recipient_;
}
void MassTransferTransactionData_Transfer::clear_recipient() {
  if (GetArenaForAllocation() == nullptr && _impl_.recipient_ != nullptr) {
    delete _impl_.recipient_;
  }
  _impl_.recipient_ = nullptr;
}
MassTransferTransactionData_Transfer::MassTransferTransactionData_Transfer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.MassTransferTransactionData.Transfer)
}
MassTransferTransactionData_Transfer::MassTransferTransactionData_Transfer(const MassTransferTransactionData_Transfer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MassTransferTransactionData_Transfer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_recipient()) {
    _this->_impl_.recipient_ = new ::vrp::Recipient(*from._impl_.recipient_);
  }
  _this->_impl_.amount_ = from._impl_.amount_;
  // @@protoc_insertion_point(copy_constructor:vrp.MassTransferTransactionData.Transfer)
}

inline void MassTransferTransactionData_Transfer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MassTransferTransactionData_Transfer::~MassTransferTransactionData_Transfer() {
  // @@protoc_insertion_point(destructor:vrp.MassTransferTransactionData.Transfer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MassTransferTransactionData_Transfer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.recipient_;
}

void MassTransferTransactionData_Transfer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MassTransferTransactionData_Transfer::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.MassTransferTransactionData.Transfer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.recipient_ != nullptr) {
    delete _impl_.recipient_;
  }
  _impl_.recipient_ = nullptr;
  _impl_.amount_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MassTransferTransactionData_Transfer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Recipient recipient = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_recipient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MassTransferTransactionData_Transfer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.MassTransferTransactionData.Transfer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Recipient recipient = 1;
  if (this->_internal_has_recipient()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::recipient(this),
        _Internal::recipient(this).GetCachedSize(), target, stream);
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.MassTransferTransactionData.Transfer)
  return target;
}

size_t MassTransferTransactionData_Transfer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.MassTransferTransactionData.Transfer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vrp.Recipient recipient = 1;
  if (this->_internal_has_recipient()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.recipient_);
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MassTransferTransactionData_Transfer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MassTransferTransactionData_Transfer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MassTransferTransactionData_Transfer::GetClassData() const { return &_class_data_; }


void MassTransferTransactionData_Transfer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MassTransferTransactionData_Transfer*>(&to_msg);
  auto& from = static_cast<const MassTransferTransactionData_Transfer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.MassTransferTransactionData.Transfer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_recipient()) {
    _this->_internal_mutable_recipient()->::vrp::Recipient::MergeFrom(
        from._internal_recipient());
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MassTransferTransactionData_Transfer::CopyFrom(const MassTransferTransactionData_Transfer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.MassTransferTransactionData.Transfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MassTransferTransactionData_Transfer::IsInitialized() const {
  return true;
}

void MassTransferTransactionData_Transfer::InternalSwap(MassTransferTransactionData_Transfer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MassTransferTransactionData_Transfer, _impl_.amount_)
      + sizeof(MassTransferTransactionData_Transfer::_impl_.amount_)
      - PROTOBUF_FIELD_OFFSET(MassTransferTransactionData_Transfer, _impl_.recipient_)>(
          reinterpret_cast<char*>(&_impl_.recipient_),
          reinterpret_cast<char*>(&other->_impl_.recipient_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MassTransferTransactionData_Transfer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[8]);
}

// ===================================================================

class MassTransferTransactionData::_Internal {
 public:
};

MassTransferTransactionData::MassTransferTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.MassTransferTransactionData)
}
MassTransferTransactionData::MassTransferTransactionData(const MassTransferTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MassTransferTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transfers_){from._impl_.transfers_}
    , decltype(_impl_.asset_id_){}
    , decltype(_impl_.attachment_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_asset_id().empty()) {
    _this->_impl_.asset_id_.Set(from._internal_asset_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.attachment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_attachment().empty()) {
    _this->_impl_.attachment_.Set(from._internal_attachment(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vrp.MassTransferTransactionData)
}

inline void MassTransferTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transfers_){arena}
    , decltype(_impl_.asset_id_){}
    , decltype(_impl_.attachment_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attachment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MassTransferTransactionData::~MassTransferTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.MassTransferTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MassTransferTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transfers_.~RepeatedPtrField();
  _impl_.asset_id_.Destroy();
  _impl_.attachment_.Destroy();
}

void MassTransferTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MassTransferTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.MassTransferTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transfers_.Clear();
  _impl_.asset_id_.ClearToEmpty();
  _impl_.attachment_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MassTransferTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes asset_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vrp.MassTransferTransactionData.Transfer transfers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transfers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes attachment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_attachment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MassTransferTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.MassTransferTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_asset_id(), target);
  }

  // repeated .vrp.MassTransferTransactionData.Transfer transfers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transfers_size()); i < n; i++) {
    const auto& repfield = this->_internal_transfers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bytes attachment = 3;
  if (!this->_internal_attachment().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_attachment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.MassTransferTransactionData)
  return target;
}

size_t MassTransferTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.MassTransferTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vrp.MassTransferTransactionData.Transfer transfers = 2;
  total_size += 1UL * this->_internal_transfers_size();
  for (const auto& msg : this->_impl_.transfers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_asset_id());
  }

  // bytes attachment = 3;
  if (!this->_internal_attachment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attachment());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MassTransferTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MassTransferTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MassTransferTransactionData::GetClassData() const { return &_class_data_; }


void MassTransferTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MassTransferTransactionData*>(&to_msg);
  auto& from = static_cast<const MassTransferTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.MassTransferTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transfers_.MergeFrom(from._impl_.transfers_);
  if (!from._internal_asset_id().empty()) {
    _this->_internal_set_asset_id(from._internal_asset_id());
  }
  if (!from._internal_attachment().empty()) {
    _this->_internal_set_attachment(from._internal_attachment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MassTransferTransactionData::CopyFrom(const MassTransferTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.MassTransferTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MassTransferTransactionData::IsInitialized() const {
  return true;
}

void MassTransferTransactionData::InternalSwap(MassTransferTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transfers_.InternalSwap(&other->_impl_.transfers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.asset_id_, lhs_arena,
      &other->_impl_.asset_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attachment_, lhs_arena,
      &other->_impl_.attachment_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MassTransferTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[9]);
}

// ===================================================================

class LeaseTransactionData::_Internal {
 public:
  static const ::vrp::Recipient& recipient(const LeaseTransactionData* msg);
};

const ::vrp::Recipient&
LeaseTransactionData::_Internal::recipient(const LeaseTransactionData* msg) {
  return *msg->_impl_.recipient_;
}
void LeaseTransactionData::clear_recipient() {
  if (GetArenaForAllocation() == nullptr && _impl_.recipient_ != nullptr) {
    delete _impl_.recipient_;
  }
  _impl_.recipient_ = nullptr;
}
LeaseTransactionData::LeaseTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.LeaseTransactionData)
}
LeaseTransactionData::LeaseTransactionData(const LeaseTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_recipient()) {
    _this->_impl_.recipient_ = new ::vrp::Recipient(*from._impl_.recipient_);
  }
  _this->_impl_.amount_ = from._impl_.amount_;
  // @@protoc_insertion_point(copy_constructor:vrp.LeaseTransactionData)
}

inline void LeaseTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_){nullptr}
    , decltype(_impl_.amount_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LeaseTransactionData::~LeaseTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.LeaseTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.recipient_;
}

void LeaseTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.LeaseTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.recipient_ != nullptr) {
    delete _impl_.recipient_;
  }
  _impl_.recipient_ = nullptr;
  _impl_.amount_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Recipient recipient = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_recipient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaseTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.LeaseTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Recipient recipient = 1;
  if (this->_internal_has_recipient()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::recipient(this),
        _Internal::recipient(this).GetCachedSize(), target, stream);
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.LeaseTransactionData)
  return target;
}

size_t LeaseTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.LeaseTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vrp.Recipient recipient = 1;
  if (this->_internal_has_recipient()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.recipient_);
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseTransactionData::GetClassData() const { return &_class_data_; }


void LeaseTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseTransactionData*>(&to_msg);
  auto& from = static_cast<const LeaseTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.LeaseTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_recipient()) {
    _this->_internal_mutable_recipient()->::vrp::Recipient::MergeFrom(
        from._internal_recipient());
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseTransactionData::CopyFrom(const LeaseTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.LeaseTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseTransactionData::IsInitialized() const {
  return true;
}

void LeaseTransactionData::InternalSwap(LeaseTransactionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseTransactionData, _impl_.amount_)
      + sizeof(LeaseTransactionData::_impl_.amount_)
      - PROTOBUF_FIELD_OFFSET(LeaseTransactionData, _impl_.recipient_)>(
          reinterpret_cast<char*>(&_impl_.recipient_),
          reinterpret_cast<char*>(&other->_impl_.recipient_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[10]);
}

// ===================================================================

class LeaseCancelTransactionData::_Internal {
 public:
};

LeaseCancelTransactionData::LeaseCancelTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.LeaseCancelTransactionData)
}
LeaseCancelTransactionData::LeaseCancelTransactionData(const LeaseCancelTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LeaseCancelTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lease_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.lease_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lease_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_lease_id().empty()) {
    _this->_impl_.lease_id_.Set(from._internal_lease_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vrp.LeaseCancelTransactionData)
}

inline void LeaseCancelTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lease_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.lease_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lease_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LeaseCancelTransactionData::~LeaseCancelTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.LeaseCancelTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaseCancelTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lease_id_.Destroy();
}

void LeaseCancelTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LeaseCancelTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.LeaseCancelTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lease_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseCancelTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes lease_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_lease_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaseCancelTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.LeaseCancelTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes lease_id = 1;
  if (!this->_internal_lease_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_lease_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.LeaseCancelTransactionData)
  return target;
}

size_t LeaseCancelTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.LeaseCancelTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes lease_id = 1;
  if (!this->_internal_lease_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_lease_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaseCancelTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LeaseCancelTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaseCancelTransactionData::GetClassData() const { return &_class_data_; }


void LeaseCancelTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LeaseCancelTransactionData*>(&to_msg);
  auto& from = static_cast<const LeaseCancelTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.LeaseCancelTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_lease_id().empty()) {
    _this->_internal_set_lease_id(from._internal_lease_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaseCancelTransactionData::CopyFrom(const LeaseCancelTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.LeaseCancelTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseCancelTransactionData::IsInitialized() const {
  return true;
}

void LeaseCancelTransactionData::InternalSwap(LeaseCancelTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lease_id_, lhs_arena,
      &other->_impl_.lease_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseCancelTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[11]);
}

// ===================================================================

class BurnTransactionData::_Internal {
 public:
  static const ::vrp::Amount& asset_amount(const BurnTransactionData* msg);
};

const ::vrp::Amount&
BurnTransactionData::_Internal::asset_amount(const BurnTransactionData* msg) {
  return *msg->_impl_.asset_amount_;
}
void BurnTransactionData::clear_asset_amount() {
  if (GetArenaForAllocation() == nullptr && _impl_.asset_amount_ != nullptr) {
    delete _impl_.asset_amount_;
  }
  _impl_.asset_amount_ = nullptr;
}
BurnTransactionData::BurnTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.BurnTransactionData)
}
BurnTransactionData::BurnTransactionData(const BurnTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BurnTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_amount_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_asset_amount()) {
    _this->_impl_.asset_amount_ = new ::vrp::Amount(*from._impl_.asset_amount_);
  }
  // @@protoc_insertion_point(copy_constructor:vrp.BurnTransactionData)
}

inline void BurnTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_amount_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BurnTransactionData::~BurnTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.BurnTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BurnTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.asset_amount_;
}

void BurnTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BurnTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.BurnTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.asset_amount_ != nullptr) {
    delete _impl_.asset_amount_;
  }
  _impl_.asset_amount_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BurnTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Amount asset_amount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_asset_amount(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BurnTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.BurnTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Amount asset_amount = 1;
  if (this->_internal_has_asset_amount()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::asset_amount(this),
        _Internal::asset_amount(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.BurnTransactionData)
  return target;
}

size_t BurnTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.BurnTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vrp.Amount asset_amount = 1;
  if (this->_internal_has_asset_amount()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.asset_amount_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BurnTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BurnTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BurnTransactionData::GetClassData() const { return &_class_data_; }


void BurnTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BurnTransactionData*>(&to_msg);
  auto& from = static_cast<const BurnTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.BurnTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_asset_amount()) {
    _this->_internal_mutable_asset_amount()->::vrp::Amount::MergeFrom(
        from._internal_asset_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BurnTransactionData::CopyFrom(const BurnTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.BurnTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BurnTransactionData::IsInitialized() const {
  return true;
}

void BurnTransactionData::InternalSwap(BurnTransactionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.asset_amount_, other->_impl_.asset_amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BurnTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[12]);
}

// ===================================================================

class IssueTransactionData::_Internal {
 public:
};

IssueTransactionData::IssueTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.IssueTransactionData)
}
IssueTransactionData::IssueTransactionData(const IssueTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IssueTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.script_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.decimals_){}
    , decltype(_impl_.reissuable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.script_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_script().empty()) {
    _this->_impl_.script_.Set(from._internal_script(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.amount_, &from._impl_.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reissuable_) -
    reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.reissuable_));
  // @@protoc_insertion_point(copy_constructor:vrp.IssueTransactionData)
}

inline void IssueTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.script_){}
    , decltype(_impl_.amount_){int64_t{0}}
    , decltype(_impl_.decimals_){0}
    , decltype(_impl_.reissuable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.script_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IssueTransactionData::~IssueTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.IssueTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IssueTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.script_.Destroy();
}

void IssueTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IssueTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.IssueTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.script_.ClearToEmpty();
  ::memset(&_impl_.amount_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.reissuable_) -
      reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.reissuable_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IssueTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.IssueTransactionData.name"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.IssueTransactionData.description"));
        } else
          goto handle_unusual;
        continue;
      // int64 amount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 decimals = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.decimals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reissuable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.reissuable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes script = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_script();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IssueTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.IssueTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.IssueTransactionData.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.IssueTransactionData.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // int64 amount = 3;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_amount(), target);
  }

  // int32 decimals = 4;
  if (this->_internal_decimals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_decimals(), target);
  }

  // bool reissuable = 5;
  if (this->_internal_reissuable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_reissuable(), target);
  }

  // bytes script = 6;
  if (!this->_internal_script().empty()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_script(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.IssueTransactionData)
  return target;
}

size_t IssueTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.IssueTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // bytes script = 6;
  if (!this->_internal_script().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_script());
  }

  // int64 amount = 3;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
  }

  // int32 decimals = 4;
  if (this->_internal_decimals() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_decimals());
  }

  // bool reissuable = 5;
  if (this->_internal_reissuable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IssueTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IssueTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IssueTransactionData::GetClassData() const { return &_class_data_; }


void IssueTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IssueTransactionData*>(&to_msg);
  auto& from = static_cast<const IssueTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.IssueTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_script().empty()) {
    _this->_internal_set_script(from._internal_script());
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (from._internal_decimals() != 0) {
    _this->_internal_set_decimals(from._internal_decimals());
  }
  if (from._internal_reissuable() != 0) {
    _this->_internal_set_reissuable(from._internal_reissuable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IssueTransactionData::CopyFrom(const IssueTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.IssueTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IssueTransactionData::IsInitialized() const {
  return true;
}

void IssueTransactionData::InternalSwap(IssueTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.script_, lhs_arena,
      &other->_impl_.script_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IssueTransactionData, _impl_.reissuable_)
      + sizeof(IssueTransactionData::_impl_.reissuable_)
      - PROTOBUF_FIELD_OFFSET(IssueTransactionData, _impl_.amount_)>(
          reinterpret_cast<char*>(&_impl_.amount_),
          reinterpret_cast<char*>(&other->_impl_.amount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IssueTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[13]);
}

// ===================================================================

class ReissueTransactionData::_Internal {
 public:
  static const ::vrp::Amount& asset_amount(const ReissueTransactionData* msg);
};

const ::vrp::Amount&
ReissueTransactionData::_Internal::asset_amount(const ReissueTransactionData* msg) {
  return *msg->_impl_.asset_amount_;
}
void ReissueTransactionData::clear_asset_amount() {
  if (GetArenaForAllocation() == nullptr && _impl_.asset_amount_ != nullptr) {
    delete _impl_.asset_amount_;
  }
  _impl_.asset_amount_ = nullptr;
}
ReissueTransactionData::ReissueTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.ReissueTransactionData)
}
ReissueTransactionData::ReissueTransactionData(const ReissueTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReissueTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_amount_){nullptr}
    , decltype(_impl_.reissuable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_asset_amount()) {
    _this->_impl_.asset_amount_ = new ::vrp::Amount(*from._impl_.asset_amount_);
  }
  _this->_impl_.reissuable_ = from._impl_.reissuable_;
  // @@protoc_insertion_point(copy_constructor:vrp.ReissueTransactionData)
}

inline void ReissueTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_amount_){nullptr}
    , decltype(_impl_.reissuable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReissueTransactionData::~ReissueTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.ReissueTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReissueTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.asset_amount_;
}

void ReissueTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReissueTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.ReissueTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.asset_amount_ != nullptr) {
    delete _impl_.asset_amount_;
  }
  _impl_.asset_amount_ = nullptr;
  _impl_.reissuable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReissueTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Amount asset_amount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_asset_amount(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reissuable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.reissuable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReissueTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.ReissueTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Amount asset_amount = 1;
  if (this->_internal_has_asset_amount()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::asset_amount(this),
        _Internal::asset_amount(this).GetCachedSize(), target, stream);
  }

  // bool reissuable = 2;
  if (this->_internal_reissuable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_reissuable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.ReissueTransactionData)
  return target;
}

size_t ReissueTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.ReissueTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vrp.Amount asset_amount = 1;
  if (this->_internal_has_asset_amount()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.asset_amount_);
  }

  // bool reissuable = 2;
  if (this->_internal_reissuable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReissueTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReissueTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReissueTransactionData::GetClassData() const { return &_class_data_; }


void ReissueTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReissueTransactionData*>(&to_msg);
  auto& from = static_cast<const ReissueTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.ReissueTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_asset_amount()) {
    _this->_internal_mutable_asset_amount()->::vrp::Amount::MergeFrom(
        from._internal_asset_amount());
  }
  if (from._internal_reissuable() != 0) {
    _this->_internal_set_reissuable(from._internal_reissuable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReissueTransactionData::CopyFrom(const ReissueTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.ReissueTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReissueTransactionData::IsInitialized() const {
  return true;
}

void ReissueTransactionData::InternalSwap(ReissueTransactionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReissueTransactionData, _impl_.reissuable_)
      + sizeof(ReissueTransactionData::_impl_.reissuable_)
      - PROTOBUF_FIELD_OFFSET(ReissueTransactionData, _impl_.asset_amount_)>(
          reinterpret_cast<char*>(&_impl_.asset_amount_),
          reinterpret_cast<char*>(&other->_impl_.asset_amount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReissueTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[14]);
}

// ===================================================================

class SetAssetScriptTransactionData::_Internal {
 public:
};

SetAssetScriptTransactionData::SetAssetScriptTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.SetAssetScriptTransactionData)
}
SetAssetScriptTransactionData::SetAssetScriptTransactionData(const SetAssetScriptTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetAssetScriptTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.script_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_asset_id().empty()) {
    _this->_impl_.asset_id_.Set(from._internal_asset_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.script_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_script().empty()) {
    _this->_impl_.script_.Set(from._internal_script(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vrp.SetAssetScriptTransactionData)
}

inline void SetAssetScriptTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.script_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.script_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetAssetScriptTransactionData::~SetAssetScriptTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.SetAssetScriptTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetAssetScriptTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.asset_id_.Destroy();
  _impl_.script_.Destroy();
}

void SetAssetScriptTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetAssetScriptTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.SetAssetScriptTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.asset_id_.ClearToEmpty();
  _impl_.script_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetAssetScriptTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes asset_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes script = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_script();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetAssetScriptTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.SetAssetScriptTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_asset_id(), target);
  }

  // bytes script = 2;
  if (!this->_internal_script().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_script(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.SetAssetScriptTransactionData)
  return target;
}

size_t SetAssetScriptTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.SetAssetScriptTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_asset_id());
  }

  // bytes script = 2;
  if (!this->_internal_script().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_script());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetAssetScriptTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetAssetScriptTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetAssetScriptTransactionData::GetClassData() const { return &_class_data_; }


void SetAssetScriptTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetAssetScriptTransactionData*>(&to_msg);
  auto& from = static_cast<const SetAssetScriptTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.SetAssetScriptTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_asset_id().empty()) {
    _this->_internal_set_asset_id(from._internal_asset_id());
  }
  if (!from._internal_script().empty()) {
    _this->_internal_set_script(from._internal_script());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetAssetScriptTransactionData::CopyFrom(const SetAssetScriptTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.SetAssetScriptTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetAssetScriptTransactionData::IsInitialized() const {
  return true;
}

void SetAssetScriptTransactionData::InternalSwap(SetAssetScriptTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.asset_id_, lhs_arena,
      &other->_impl_.asset_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.script_, lhs_arena,
      &other->_impl_.script_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SetAssetScriptTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[15]);
}

// ===================================================================

class SetScriptTransactionData::_Internal {
 public:
};

SetScriptTransactionData::SetScriptTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.SetScriptTransactionData)
}
SetScriptTransactionData::SetScriptTransactionData(const SetScriptTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetScriptTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.script_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.script_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_script().empty()) {
    _this->_impl_.script_.Set(from._internal_script(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vrp.SetScriptTransactionData)
}

inline void SetScriptTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.script_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.script_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetScriptTransactionData::~SetScriptTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.SetScriptTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetScriptTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.script_.Destroy();
}

void SetScriptTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetScriptTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.SetScriptTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.script_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetScriptTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes script = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_script();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetScriptTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.SetScriptTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes script = 1;
  if (!this->_internal_script().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_script(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.SetScriptTransactionData)
  return target;
}

size_t SetScriptTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.SetScriptTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes script = 1;
  if (!this->_internal_script().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_script());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetScriptTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetScriptTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetScriptTransactionData::GetClassData() const { return &_class_data_; }


void SetScriptTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetScriptTransactionData*>(&to_msg);
  auto& from = static_cast<const SetScriptTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.SetScriptTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_script().empty()) {
    _this->_internal_set_script(from._internal_script());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetScriptTransactionData::CopyFrom(const SetScriptTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.SetScriptTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetScriptTransactionData::IsInitialized() const {
  return true;
}

void SetScriptTransactionData::InternalSwap(SetScriptTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.script_, lhs_arena,
      &other->_impl_.script_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SetScriptTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[16]);
}

// ===================================================================

class ExchangeTransactionData::_Internal {
 public:
};

void ExchangeTransactionData::clear_orders() {
  _impl_.orders_.Clear();
}
ExchangeTransactionData::ExchangeTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.ExchangeTransactionData)
}
ExchangeTransactionData::ExchangeTransactionData(const ExchangeTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExchangeTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){from._impl_.orders_}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.price_){}
    , decltype(_impl_.buy_matcher_fee_){}
    , decltype(_impl_.sell_matcher_fee_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.amount_, &from._impl_.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sell_matcher_fee_) -
    reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.sell_matcher_fee_));
  // @@protoc_insertion_point(copy_constructor:vrp.ExchangeTransactionData)
}

inline void ExchangeTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){arena}
    , decltype(_impl_.amount_){int64_t{0}}
    , decltype(_impl_.price_){int64_t{0}}
    , decltype(_impl_.buy_matcher_fee_){int64_t{0}}
    , decltype(_impl_.sell_matcher_fee_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExchangeTransactionData::~ExchangeTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.ExchangeTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExchangeTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.orders_.~RepeatedPtrField();
}

void ExchangeTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExchangeTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.ExchangeTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.orders_.Clear();
  ::memset(&_impl_.amount_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sell_matcher_fee_) -
      reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.sell_matcher_fee_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExchangeTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 amount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 price = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 buy_matcher_fee = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.buy_matcher_fee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 sell_matcher_fee = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.sell_matcher_fee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vrp.Order orders = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExchangeTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.ExchangeTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 amount = 1;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_amount(), target);
  }

  // int64 price = 2;
  if (this->_internal_price() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_price(), target);
  }

  // int64 buy_matcher_fee = 3;
  if (this->_internal_buy_matcher_fee() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_buy_matcher_fee(), target);
  }

  // int64 sell_matcher_fee = 4;
  if (this->_internal_sell_matcher_fee() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_sell_matcher_fee(), target);
  }

  // repeated .vrp.Order orders = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.ExchangeTransactionData)
  return target;
}

size_t ExchangeTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.ExchangeTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vrp.Order orders = 5;
  total_size += 1UL * this->_internal_orders_size();
  for (const auto& msg : this->_impl_.orders_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 amount = 1;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
  }

  // int64 price = 2;
  if (this->_internal_price() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_price());
  }

  // int64 buy_matcher_fee = 3;
  if (this->_internal_buy_matcher_fee() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_buy_matcher_fee());
  }

  // int64 sell_matcher_fee = 4;
  if (this->_internal_sell_matcher_fee() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sell_matcher_fee());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExchangeTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExchangeTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExchangeTransactionData::GetClassData() const { return &_class_data_; }


void ExchangeTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExchangeTransactionData*>(&to_msg);
  auto& from = static_cast<const ExchangeTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.ExchangeTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.orders_.MergeFrom(from._impl_.orders_);
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  if (from._internal_price() != 0) {
    _this->_internal_set_price(from._internal_price());
  }
  if (from._internal_buy_matcher_fee() != 0) {
    _this->_internal_set_buy_matcher_fee(from._internal_buy_matcher_fee());
  }
  if (from._internal_sell_matcher_fee() != 0) {
    _this->_internal_set_sell_matcher_fee(from._internal_sell_matcher_fee());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExchangeTransactionData::CopyFrom(const ExchangeTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.ExchangeTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeTransactionData::IsInitialized() const {
  return true;
}

void ExchangeTransactionData::InternalSwap(ExchangeTransactionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.orders_.InternalSwap(&other->_impl_.orders_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExchangeTransactionData, _impl_.sell_matcher_fee_)
      + sizeof(ExchangeTransactionData::_impl_.sell_matcher_fee_)
      - PROTOBUF_FIELD_OFFSET(ExchangeTransactionData, _impl_.amount_)>(
          reinterpret_cast<char*>(&_impl_.amount_),
          reinterpret_cast<char*>(&other->_impl_.amount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExchangeTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[17]);
}

// ===================================================================

class SponsorFeeTransactionData::_Internal {
 public:
  static const ::vrp::Amount& min_fee(const SponsorFeeTransactionData* msg);
};

const ::vrp::Amount&
SponsorFeeTransactionData::_Internal::min_fee(const SponsorFeeTransactionData* msg) {
  return *msg->_impl_.min_fee_;
}
void SponsorFeeTransactionData::clear_min_fee() {
  if (GetArenaForAllocation() == nullptr && _impl_.min_fee_ != nullptr) {
    delete _impl_.min_fee_;
  }
  _impl_.min_fee_ = nullptr;
}
SponsorFeeTransactionData::SponsorFeeTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.SponsorFeeTransactionData)
}
SponsorFeeTransactionData::SponsorFeeTransactionData(const SponsorFeeTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SponsorFeeTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.min_fee_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_min_fee()) {
    _this->_impl_.min_fee_ = new ::vrp::Amount(*from._impl_.min_fee_);
  }
  // @@protoc_insertion_point(copy_constructor:vrp.SponsorFeeTransactionData)
}

inline void SponsorFeeTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.min_fee_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SponsorFeeTransactionData::~SponsorFeeTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.SponsorFeeTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SponsorFeeTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.min_fee_;
}

void SponsorFeeTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SponsorFeeTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.SponsorFeeTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.min_fee_ != nullptr) {
    delete _impl_.min_fee_;
  }
  _impl_.min_fee_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SponsorFeeTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Amount min_fee = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_min_fee(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SponsorFeeTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.SponsorFeeTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Amount min_fee = 1;
  if (this->_internal_has_min_fee()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::min_fee(this),
        _Internal::min_fee(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.SponsorFeeTransactionData)
  return target;
}

size_t SponsorFeeTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.SponsorFeeTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vrp.Amount min_fee = 1;
  if (this->_internal_has_min_fee()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.min_fee_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SponsorFeeTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SponsorFeeTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SponsorFeeTransactionData::GetClassData() const { return &_class_data_; }


void SponsorFeeTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SponsorFeeTransactionData*>(&to_msg);
  auto& from = static_cast<const SponsorFeeTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.SponsorFeeTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_min_fee()) {
    _this->_internal_mutable_min_fee()->::vrp::Amount::MergeFrom(
        from._internal_min_fee());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SponsorFeeTransactionData::CopyFrom(const SponsorFeeTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.SponsorFeeTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SponsorFeeTransactionData::IsInitialized() const {
  return true;
}

void SponsorFeeTransactionData::InternalSwap(SponsorFeeTransactionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.min_fee_, other->_impl_.min_fee_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SponsorFeeTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[18]);
}

// ===================================================================

class InvokeScriptTransactionData::_Internal {
 public:
  static const ::vrp::Recipient& d_app(const InvokeScriptTransactionData* msg);
};

const ::vrp::Recipient&
InvokeScriptTransactionData::_Internal::d_app(const InvokeScriptTransactionData* msg) {
  return *msg->_impl_.d_app_;
}
void InvokeScriptTransactionData::clear_d_app() {
  if (GetArenaForAllocation() == nullptr && _impl_.d_app_ != nullptr) {
    delete _impl_.d_app_;
  }
  _impl_.d_app_ = nullptr;
}
void InvokeScriptTransactionData::clear_payments() {
  _impl_.payments_.Clear();
}
InvokeScriptTransactionData::InvokeScriptTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.InvokeScriptTransactionData)
}
InvokeScriptTransactionData::InvokeScriptTransactionData(const InvokeScriptTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InvokeScriptTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payments_){from._impl_.payments_}
    , decltype(_impl_.function_call_){}
    , decltype(_impl_.d_app_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.function_call_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_call_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_function_call().empty()) {
    _this->_impl_.function_call_.Set(from._internal_function_call(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_d_app()) {
    _this->_impl_.d_app_ = new ::vrp::Recipient(*from._impl_.d_app_);
  }
  // @@protoc_insertion_point(copy_constructor:vrp.InvokeScriptTransactionData)
}

inline void InvokeScriptTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payments_){arena}
    , decltype(_impl_.function_call_){}
    , decltype(_impl_.d_app_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.function_call_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_call_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InvokeScriptTransactionData::~InvokeScriptTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.InvokeScriptTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InvokeScriptTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payments_.~RepeatedPtrField();
  _impl_.function_call_.Destroy();
  if (this != internal_default_instance()) delete _impl_.d_app_;
}

void InvokeScriptTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InvokeScriptTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.InvokeScriptTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.payments_.Clear();
  _impl_.function_call_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.d_app_ != nullptr) {
    delete _impl_.d_app_;
  }
  _impl_.d_app_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InvokeScriptTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vrp.Recipient d_app = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_d_app(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes function_call = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_function_call();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vrp.Amount payments = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_payments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InvokeScriptTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.InvokeScriptTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vrp.Recipient d_app = 1;
  if (this->_internal_has_d_app()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::d_app(this),
        _Internal::d_app(this).GetCachedSize(), target, stream);
  }

  // bytes function_call = 2;
  if (!this->_internal_function_call().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_function_call(), target);
  }

  // repeated .vrp.Amount payments = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_payments_size()); i < n; i++) {
    const auto& repfield = this->_internal_payments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.InvokeScriptTransactionData)
  return target;
}

size_t InvokeScriptTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.InvokeScriptTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vrp.Amount payments = 3;
  total_size += 1UL * this->_internal_payments_size();
  for (const auto& msg : this->_impl_.payments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes function_call = 2;
  if (!this->_internal_function_call().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_function_call());
  }

  // .vrp.Recipient d_app = 1;
  if (this->_internal_has_d_app()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.d_app_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InvokeScriptTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InvokeScriptTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InvokeScriptTransactionData::GetClassData() const { return &_class_data_; }


void InvokeScriptTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InvokeScriptTransactionData*>(&to_msg);
  auto& from = static_cast<const InvokeScriptTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.InvokeScriptTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.payments_.MergeFrom(from._impl_.payments_);
  if (!from._internal_function_call().empty()) {
    _this->_internal_set_function_call(from._internal_function_call());
  }
  if (from._internal_has_d_app()) {
    _this->_internal_mutable_d_app()->::vrp::Recipient::MergeFrom(
        from._internal_d_app());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InvokeScriptTransactionData::CopyFrom(const InvokeScriptTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.InvokeScriptTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvokeScriptTransactionData::IsInitialized() const {
  return true;
}

void InvokeScriptTransactionData::InternalSwap(InvokeScriptTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.payments_.InternalSwap(&other->_impl_.payments_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.function_call_, lhs_arena,
      &other->_impl_.function_call_, rhs_arena
  );
  swap(_impl_.d_app_, other->_impl_.d_app_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InvokeScriptTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[19]);
}

// ===================================================================

class UpdateAssetInfoTransactionData::_Internal {
 public:
};

UpdateAssetInfoTransactionData::UpdateAssetInfoTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.UpdateAssetInfoTransactionData)
}
UpdateAssetInfoTransactionData::UpdateAssetInfoTransactionData(const UpdateAssetInfoTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateAssetInfoTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.image_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_asset_id().empty()) {
    _this->_impl_.asset_id_.Set(from._internal_asset_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_image().empty()) {
    _this->_impl_.image_.Set(from._internal_image(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vrp.UpdateAssetInfoTransactionData)
}

inline void UpdateAssetInfoTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asset_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.image_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateAssetInfoTransactionData::~UpdateAssetInfoTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.UpdateAssetInfoTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateAssetInfoTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.asset_id_.Destroy();
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.image_.Destroy();
}

void UpdateAssetInfoTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateAssetInfoTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.UpdateAssetInfoTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.asset_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.image_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateAssetInfoTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes asset_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.UpdateAssetInfoTransactionData.name"));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.UpdateAssetInfoTransactionData.description"));
        } else
          goto handle_unusual;
        continue;
      // string image = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vrp.UpdateAssetInfoTransactionData.image"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateAssetInfoTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.UpdateAssetInfoTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_asset_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.UpdateAssetInfoTransactionData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.UpdateAssetInfoTransactionData.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // string image = 4;
  if (!this->_internal_image().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_image().data(), static_cast<int>(this->_internal_image().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vrp.UpdateAssetInfoTransactionData.image");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_image(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.UpdateAssetInfoTransactionData)
  return target;
}

size_t UpdateAssetInfoTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.UpdateAssetInfoTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes asset_id = 1;
  if (!this->_internal_asset_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_asset_id());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string image = 4;
  if (!this->_internal_image().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_image());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateAssetInfoTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateAssetInfoTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateAssetInfoTransactionData::GetClassData() const { return &_class_data_; }


void UpdateAssetInfoTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateAssetInfoTransactionData*>(&to_msg);
  auto& from = static_cast<const UpdateAssetInfoTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.UpdateAssetInfoTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_asset_id().empty()) {
    _this->_internal_set_asset_id(from._internal_asset_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_image().empty()) {
    _this->_internal_set_image(from._internal_image());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateAssetInfoTransactionData::CopyFrom(const UpdateAssetInfoTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.UpdateAssetInfoTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateAssetInfoTransactionData::IsInitialized() const {
  return true;
}

void UpdateAssetInfoTransactionData::InternalSwap(UpdateAssetInfoTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.asset_id_, lhs_arena,
      &other->_impl_.asset_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_, lhs_arena,
      &other->_impl_.image_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateAssetInfoTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[20]);
}

// ===================================================================

class InvokeExpressionTransactionData::_Internal {
 public:
};

InvokeExpressionTransactionData::InvokeExpressionTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.InvokeExpressionTransactionData)
}
InvokeExpressionTransactionData::InvokeExpressionTransactionData(const InvokeExpressionTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InvokeExpressionTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.expression_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.expression_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expression_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_expression().empty()) {
    _this->_impl_.expression_.Set(from._internal_expression(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vrp.InvokeExpressionTransactionData)
}

inline void InvokeExpressionTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.expression_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.expression_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expression_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InvokeExpressionTransactionData::~InvokeExpressionTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.InvokeExpressionTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InvokeExpressionTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.expression_.Destroy();
}

void InvokeExpressionTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InvokeExpressionTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.InvokeExpressionTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.expression_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InvokeExpressionTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes expression = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_expression();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InvokeExpressionTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.InvokeExpressionTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes expression = 1;
  if (!this->_internal_expression().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_expression(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.InvokeExpressionTransactionData)
  return target;
}

size_t InvokeExpressionTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.InvokeExpressionTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes expression = 1;
  if (!this->_internal_expression().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_expression());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InvokeExpressionTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InvokeExpressionTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InvokeExpressionTransactionData::GetClassData() const { return &_class_data_; }


void InvokeExpressionTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InvokeExpressionTransactionData*>(&to_msg);
  auto& from = static_cast<const InvokeExpressionTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.InvokeExpressionTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_expression().empty()) {
    _this->_internal_set_expression(from._internal_expression());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InvokeExpressionTransactionData::CopyFrom(const InvokeExpressionTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.InvokeExpressionTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvokeExpressionTransactionData::IsInitialized() const {
  return true;
}

void InvokeExpressionTransactionData::InternalSwap(InvokeExpressionTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.expression_, lhs_arena,
      &other->_impl_.expression_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata InvokeExpressionTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[21]);
}

// ===================================================================

class PrivatePaymentTransactionData::_Internal {
 public:
};

PrivatePaymentTransactionData::PrivatePaymentTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vrp.PrivatePaymentTransactionData)
}
PrivatePaymentTransactionData::PrivatePaymentTransactionData(const PrivatePaymentTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PrivatePaymentTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recipient_address().empty()) {
    _this->_impl_.recipient_address_.Set(from._internal_recipient_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.amount_ = from._impl_.amount_;
  // @@protoc_insertion_point(copy_constructor:vrp.PrivatePaymentTransactionData)
}

inline void PrivatePaymentTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recipient_address_){}
    , decltype(_impl_.amount_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.recipient_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PrivatePaymentTransactionData::~PrivatePaymentTransactionData() {
  // @@protoc_insertion_point(destructor:vrp.PrivatePaymentTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrivatePaymentTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recipient_address_.Destroy();
}

void PrivatePaymentTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrivatePaymentTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:vrp.PrivatePaymentTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipient_address_.ClearToEmpty();
  _impl_.amount_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrivatePaymentTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes recipient_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_recipient_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrivatePaymentTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vrp.PrivatePaymentTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_recipient_address(), target);
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vrp.PrivatePaymentTransactionData)
  return target;
}

size_t PrivatePaymentTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vrp.PrivatePaymentTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes recipient_address = 1;
  if (!this->_internal_recipient_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recipient_address());
  }

  // int64 amount = 2;
  if (this->_internal_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrivatePaymentTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PrivatePaymentTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrivatePaymentTransactionData::GetClassData() const { return &_class_data_; }


void PrivatePaymentTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PrivatePaymentTransactionData*>(&to_msg);
  auto& from = static_cast<const PrivatePaymentTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vrp.PrivatePaymentTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_recipient_address().empty()) {
    _this->_internal_set_recipient_address(from._internal_recipient_address());
  }
  if (from._internal_amount() != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrivatePaymentTransactionData::CopyFrom(const PrivatePaymentTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vrp.PrivatePaymentTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivatePaymentTransactionData::IsInitialized() const {
  return true;
}

void PrivatePaymentTransactionData::InternalSwap(PrivatePaymentTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recipient_address_, lhs_arena,
      &other->_impl_.recipient_address_, rhs_arena
  );
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PrivatePaymentTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vrp_2ftransaction_2eproto_getter, &descriptor_table_vrp_2ftransaction_2eproto_once,
      file_level_metadata_vrp_2ftransaction_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace vrp
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vrp::SignedTransaction*
Arena::CreateMaybeMessage< ::vrp::SignedTransaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::SignedTransaction >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::Transaction*
Arena::CreateMaybeMessage< ::vrp::Transaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::Transaction >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::GenesisTransactionData*
Arena::CreateMaybeMessage< ::vrp::GenesisTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::GenesisTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::PaymentTransactionData*
Arena::CreateMaybeMessage< ::vrp::PaymentTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::PaymentTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::TransferTransactionData*
Arena::CreateMaybeMessage< ::vrp::TransferTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::TransferTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::CreateAliasTransactionData*
Arena::CreateMaybeMessage< ::vrp::CreateAliasTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::CreateAliasTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::DataTransactionData_DataEntry*
Arena::CreateMaybeMessage< ::vrp::DataTransactionData_DataEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::DataTransactionData_DataEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::DataTransactionData*
Arena::CreateMaybeMessage< ::vrp::DataTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::DataTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::MassTransferTransactionData_Transfer*
Arena::CreateMaybeMessage< ::vrp::MassTransferTransactionData_Transfer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::MassTransferTransactionData_Transfer >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::MassTransferTransactionData*
Arena::CreateMaybeMessage< ::vrp::MassTransferTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::MassTransferTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::LeaseTransactionData*
Arena::CreateMaybeMessage< ::vrp::LeaseTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::LeaseTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::LeaseCancelTransactionData*
Arena::CreateMaybeMessage< ::vrp::LeaseCancelTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::LeaseCancelTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::BurnTransactionData*
Arena::CreateMaybeMessage< ::vrp::BurnTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::BurnTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::IssueTransactionData*
Arena::CreateMaybeMessage< ::vrp::IssueTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::IssueTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::ReissueTransactionData*
Arena::CreateMaybeMessage< ::vrp::ReissueTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::ReissueTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::SetAssetScriptTransactionData*
Arena::CreateMaybeMessage< ::vrp::SetAssetScriptTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::SetAssetScriptTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::SetScriptTransactionData*
Arena::CreateMaybeMessage< ::vrp::SetScriptTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::SetScriptTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::ExchangeTransactionData*
Arena::CreateMaybeMessage< ::vrp::ExchangeTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::ExchangeTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::SponsorFeeTransactionData*
Arena::CreateMaybeMessage< ::vrp::SponsorFeeTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::SponsorFeeTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::InvokeScriptTransactionData*
Arena::CreateMaybeMessage< ::vrp::InvokeScriptTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::InvokeScriptTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::UpdateAssetInfoTransactionData*
Arena::CreateMaybeMessage< ::vrp::UpdateAssetInfoTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::UpdateAssetInfoTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::InvokeExpressionTransactionData*
Arena::CreateMaybeMessage< ::vrp::InvokeExpressionTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::InvokeExpressionTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::vrp::PrivatePaymentTransactionData*
Arena::CreateMaybeMessage< ::vrp::PrivatePaymentTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vrp::PrivatePaymentTransactionData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
