/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const vrp = $root.vrp = (() => {

    /**
     * Namespace vrp.
     * @exports vrp
     * @namespace
     */
    const vrp = {};

    vrp.Amount = (function() {

        /**
         * Properties of an Amount.
         * @memberof vrp
         * @interface IAmount
         * @property {Uint8Array|null} [assetId] Amount assetId
         * @property {Long|null} [amount] Amount amount
         */

        /**
         * Constructs a new Amount.
         * @memberof vrp
         * @classdesc Represents an Amount.
         * @implements IAmount
         * @constructor
         * @param {vrp.IAmount=} [p] Properties to set
         */
        function Amount(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Amount assetId.
         * @member {Uint8Array} assetId
         * @memberof vrp.Amount
         * @instance
         */
        Amount.prototype.assetId = $util.newBuffer([]);

        /**
         * Amount amount.
         * @member {Long} amount
         * @memberof vrp.Amount
         * @instance
         */
        Amount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified Amount message. Does not implicitly {@link vrp.Amount.verify|verify} messages.
         * @function encode
         * @memberof vrp.Amount
         * @static
         * @param {vrp.IAmount} m Amount message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Amount.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes an Amount message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.Amount
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.Amount} Amount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Amount.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.Amount();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Amount;
    })();

    vrp.Block = (function() {

        /**
         * Properties of a Block.
         * @memberof vrp
         * @interface IBlock
         * @property {vrp.Block.IHeader|null} [header] Block header
         * @property {Uint8Array|null} [signature] Block signature
         * @property {Array.<vrp.ISignedTransaction>|null} [transactions] Block transactions
         */

        /**
         * Constructs a new Block.
         * @memberof vrp
         * @classdesc Represents a Block.
         * @implements IBlock
         * @constructor
         * @param {vrp.IBlock=} [p] Properties to set
         */
        function Block(p) {
            this.transactions = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Block header.
         * @member {vrp.Block.IHeader|null|undefined} header
         * @memberof vrp.Block
         * @instance
         */
        Block.prototype.header = null;

        /**
         * Block signature.
         * @member {Uint8Array} signature
         * @memberof vrp.Block
         * @instance
         */
        Block.prototype.signature = $util.newBuffer([]);

        /**
         * Block transactions.
         * @member {Array.<vrp.ISignedTransaction>} transactions
         * @memberof vrp.Block
         * @instance
         */
        Block.prototype.transactions = $util.emptyArray;

        /**
         * Encodes the specified Block message. Does not implicitly {@link vrp.Block.verify|verify} messages.
         * @function encode
         * @memberof vrp.Block
         * @static
         * @param {vrp.IBlock} m Block message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.vrp.Block.Header.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
                w.uint32(18).bytes(m.signature);
            if (m.transactions != null && m.transactions.length) {
                for (var i = 0; i < m.transactions.length; ++i)
                    $root.vrp.SignedTransaction.encode(m.transactions[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a Block message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.Block();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.vrp.Block.Header.decode(r, r.uint32());
                    break;
                case 2:
                    m.signature = r.bytes();
                    break;
                case 3:
                    if (!(m.transactions && m.transactions.length))
                        m.transactions = [];
                    m.transactions.push($root.vrp.SignedTransaction.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        Block.Header = (function() {

            /**
             * Properties of a Header.
             * @memberof vrp.Block
             * @interface IHeader
             * @property {number|null} [chainId] Header chainId
             * @property {Uint8Array|null} [reference] Header reference
             * @property {Long|null} [baseTarget] Header baseTarget
             * @property {Uint8Array|null} [generationSignature] Header generationSignature
             * @property {Array.<number>|null} [featureVotes] Header featureVotes
             * @property {Long|null} [timestamp] Header timestamp
             * @property {number|null} [version] Header version
             * @property {Uint8Array|null} [generator] Header generator
             * @property {Long|null} [rewardVote] Header rewardVote
             * @property {Long|null} [rewardBurned] Header rewardBurned
             * @property {Uint8Array|null} [transactionsRoot] Header transactionsRoot
             */

            /**
             * Constructs a new Header.
             * @memberof vrp.Block
             * @classdesc Represents a Header.
             * @implements IHeader
             * @constructor
             * @param {vrp.Block.IHeader=} [p] Properties to set
             */
            function Header(p) {
                this.featureVotes = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Header chainId.
             * @member {number} chainId
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.chainId = 0;

            /**
             * Header reference.
             * @member {Uint8Array} reference
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.reference = $util.newBuffer([]);

            /**
             * Header baseTarget.
             * @member {Long} baseTarget
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.baseTarget = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Header generationSignature.
             * @member {Uint8Array} generationSignature
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.generationSignature = $util.newBuffer([]);

            /**
             * Header featureVotes.
             * @member {Array.<number>} featureVotes
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.featureVotes = $util.emptyArray;

            /**
             * Header timestamp.
             * @member {Long} timestamp
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Header version.
             * @member {number} version
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.version = 0;

            /**
             * Header generator.
             * @member {Uint8Array} generator
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.generator = $util.newBuffer([]);

            /**
             * Header rewardVote.
             * @member {Long} rewardVote
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.rewardVote = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Header rewardBurned.
             * @member {Long} rewardBurned
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.rewardBurned = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Header transactionsRoot.
             * @member {Uint8Array} transactionsRoot
             * @memberof vrp.Block.Header
             * @instance
             */
            Header.prototype.transactionsRoot = $util.newBuffer([]);

            /**
             * Encodes the specified Header message. Does not implicitly {@link vrp.Block.Header.verify|verify} messages.
             * @function encode
             * @memberof vrp.Block.Header
             * @static
             * @param {vrp.Block.IHeader} m Header message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Header.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.chainId != null && Object.hasOwnProperty.call(m, "chainId"))
                    w.uint32(8).int32(m.chainId);
                if (m.reference != null && Object.hasOwnProperty.call(m, "reference"))
                    w.uint32(18).bytes(m.reference);
                if (m.baseTarget != null && Object.hasOwnProperty.call(m, "baseTarget"))
                    w.uint32(24).int64(m.baseTarget);
                if (m.generationSignature != null && Object.hasOwnProperty.call(m, "generationSignature"))
                    w.uint32(34).bytes(m.generationSignature);
                if (m.featureVotes != null && m.featureVotes.length) {
                    w.uint32(42).fork();
                    for (var i = 0; i < m.featureVotes.length; ++i)
                        w.uint32(m.featureVotes[i]);
                    w.ldelim();
                }
                if (m.timestamp != null && Object.hasOwnProperty.call(m, "timestamp"))
                    w.uint32(48).int64(m.timestamp);
                if (m.version != null && Object.hasOwnProperty.call(m, "version"))
                    w.uint32(56).int32(m.version);
                if (m.generator != null && Object.hasOwnProperty.call(m, "generator"))
                    w.uint32(66).bytes(m.generator);
                if (m.rewardVote != null && Object.hasOwnProperty.call(m, "rewardVote"))
                    w.uint32(72).int64(m.rewardVote);
                if (m.rewardBurned != null && Object.hasOwnProperty.call(m, "rewardBurned"))
                    w.uint32(80).int64(m.rewardBurned);
                if (m.transactionsRoot != null && Object.hasOwnProperty.call(m, "transactionsRoot"))
                    w.uint32(90).bytes(m.transactionsRoot);
                return w;
            };

            /**
             * Decodes a Header message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.Block.Header
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.Block.Header} Header
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Header.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.Block.Header();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.chainId = r.int32();
                        break;
                    case 2:
                        m.reference = r.bytes();
                        break;
                    case 3:
                        m.baseTarget = r.int64();
                        break;
                    case 4:
                        m.generationSignature = r.bytes();
                        break;
                    case 5:
                        if (!(m.featureVotes && m.featureVotes.length))
                            m.featureVotes = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.featureVotes.push(r.uint32());
                        } else
                            m.featureVotes.push(r.uint32());
                        break;
                    case 6:
                        m.timestamp = r.int64();
                        break;
                    case 7:
                        m.version = r.int32();
                        break;
                    case 8:
                        m.generator = r.bytes();
                        break;
                    case 9:
                        m.rewardVote = r.int64();
                        break;
                    case 10:
                        m.rewardBurned = r.int64();
                        break;
                    case 11:
                        m.transactionsRoot = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Header;
        })();

        return Block;
    })();

    vrp.MicroBlock = (function() {

        /**
         * Properties of a MicroBlock.
         * @memberof vrp
         * @interface IMicroBlock
         * @property {number|null} [version] MicroBlock version
         * @property {Uint8Array|null} [reference] MicroBlock reference
         * @property {Uint8Array|null} [updatedBlockSignature] MicroBlock updatedBlockSignature
         * @property {Uint8Array|null} [senderPublicKey] MicroBlock senderPublicKey
         * @property {Array.<vrp.ISignedTransaction>|null} [transactions] MicroBlock transactions
         */

        /**
         * Constructs a new MicroBlock.
         * @memberof vrp
         * @classdesc Represents a MicroBlock.
         * @implements IMicroBlock
         * @constructor
         * @param {vrp.IMicroBlock=} [p] Properties to set
         */
        function MicroBlock(p) {
            this.transactions = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * MicroBlock version.
         * @member {number} version
         * @memberof vrp.MicroBlock
         * @instance
         */
        MicroBlock.prototype.version = 0;

        /**
         * MicroBlock reference.
         * @member {Uint8Array} reference
         * @memberof vrp.MicroBlock
         * @instance
         */
        MicroBlock.prototype.reference = $util.newBuffer([]);

        /**
         * MicroBlock updatedBlockSignature.
         * @member {Uint8Array} updatedBlockSignature
         * @memberof vrp.MicroBlock
         * @instance
         */
        MicroBlock.prototype.updatedBlockSignature = $util.newBuffer([]);

        /**
         * MicroBlock senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof vrp.MicroBlock
         * @instance
         */
        MicroBlock.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * MicroBlock transactions.
         * @member {Array.<vrp.ISignedTransaction>} transactions
         * @memberof vrp.MicroBlock
         * @instance
         */
        MicroBlock.prototype.transactions = $util.emptyArray;

        /**
         * Encodes the specified MicroBlock message. Does not implicitly {@link vrp.MicroBlock.verify|verify} messages.
         * @function encode
         * @memberof vrp.MicroBlock
         * @static
         * @param {vrp.IMicroBlock} m MicroBlock message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MicroBlock.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.version != null && Object.hasOwnProperty.call(m, "version"))
                w.uint32(8).int32(m.version);
            if (m.reference != null && Object.hasOwnProperty.call(m, "reference"))
                w.uint32(18).bytes(m.reference);
            if (m.updatedBlockSignature != null && Object.hasOwnProperty.call(m, "updatedBlockSignature"))
                w.uint32(26).bytes(m.updatedBlockSignature);
            if (m.senderPublicKey != null && Object.hasOwnProperty.call(m, "senderPublicKey"))
                w.uint32(34).bytes(m.senderPublicKey);
            if (m.transactions != null && m.transactions.length) {
                for (var i = 0; i < m.transactions.length; ++i)
                    $root.vrp.SignedTransaction.encode(m.transactions[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a MicroBlock message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.MicroBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.MicroBlock} MicroBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MicroBlock.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.MicroBlock();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.version = r.int32();
                    break;
                case 2:
                    m.reference = r.bytes();
                    break;
                case 3:
                    m.updatedBlockSignature = r.bytes();
                    break;
                case 4:
                    m.senderPublicKey = r.bytes();
                    break;
                case 5:
                    if (!(m.transactions && m.transactions.length))
                        m.transactions = [];
                    m.transactions.push($root.vrp.SignedTransaction.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return MicroBlock;
    })();

    vrp.SignedMicroBlock = (function() {

        /**
         * Properties of a SignedMicroBlock.
         * @memberof vrp
         * @interface ISignedMicroBlock
         * @property {vrp.IMicroBlock|null} [microBlock] SignedMicroBlock microBlock
         * @property {Uint8Array|null} [signature] SignedMicroBlock signature
         * @property {Uint8Array|null} [totalBlockId] SignedMicroBlock totalBlockId
         */

        /**
         * Constructs a new SignedMicroBlock.
         * @memberof vrp
         * @classdesc Represents a SignedMicroBlock.
         * @implements ISignedMicroBlock
         * @constructor
         * @param {vrp.ISignedMicroBlock=} [p] Properties to set
         */
        function SignedMicroBlock(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SignedMicroBlock microBlock.
         * @member {vrp.IMicroBlock|null|undefined} microBlock
         * @memberof vrp.SignedMicroBlock
         * @instance
         */
        SignedMicroBlock.prototype.microBlock = null;

        /**
         * SignedMicroBlock signature.
         * @member {Uint8Array} signature
         * @memberof vrp.SignedMicroBlock
         * @instance
         */
        SignedMicroBlock.prototype.signature = $util.newBuffer([]);

        /**
         * SignedMicroBlock totalBlockId.
         * @member {Uint8Array} totalBlockId
         * @memberof vrp.SignedMicroBlock
         * @instance
         */
        SignedMicroBlock.prototype.totalBlockId = $util.newBuffer([]);

        /**
         * Encodes the specified SignedMicroBlock message. Does not implicitly {@link vrp.SignedMicroBlock.verify|verify} messages.
         * @function encode
         * @memberof vrp.SignedMicroBlock
         * @static
         * @param {vrp.ISignedMicroBlock} m SignedMicroBlock message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedMicroBlock.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.microBlock != null && Object.hasOwnProperty.call(m, "microBlock"))
                $root.vrp.MicroBlock.encode(m.microBlock, w.uint32(10).fork()).ldelim();
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
                w.uint32(18).bytes(m.signature);
            if (m.totalBlockId != null && Object.hasOwnProperty.call(m, "totalBlockId"))
                w.uint32(26).bytes(m.totalBlockId);
            return w;
        };

        /**
         * Decodes a SignedMicroBlock message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.SignedMicroBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.SignedMicroBlock} SignedMicroBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedMicroBlock.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.SignedMicroBlock();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.microBlock = $root.vrp.MicroBlock.decode(r, r.uint32());
                    break;
                case 2:
                    m.signature = r.bytes();
                    break;
                case 3:
                    m.totalBlockId = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignedMicroBlock;
    })();

    vrp.events = (function() {

        /**
         * Namespace events.
         * @memberof vrp
         * @namespace
         */
        const events = {};

        events.BlockchainUpdated = (function() {

            /**
             * Properties of a BlockchainUpdated.
             * @memberof vrp.events
             * @interface IBlockchainUpdated
             * @property {Uint8Array|null} [id] BlockchainUpdated id
             * @property {number|null} [height] BlockchainUpdated height
             * @property {vrp.events.BlockchainUpdated.IAppend|null} [append] BlockchainUpdated append
             * @property {vrp.events.BlockchainUpdated.IRollback|null} [rollback] BlockchainUpdated rollback
             * @property {Array.<vrp.events.StateUpdate.IAssetInfo>|null} [referencedAssets] BlockchainUpdated referencedAssets
             */

            /**
             * Constructs a new BlockchainUpdated.
             * @memberof vrp.events
             * @classdesc Represents a BlockchainUpdated.
             * @implements IBlockchainUpdated
             * @constructor
             * @param {vrp.events.IBlockchainUpdated=} [p] Properties to set
             */
            function BlockchainUpdated(p) {
                this.referencedAssets = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * BlockchainUpdated id.
             * @member {Uint8Array} id
             * @memberof vrp.events.BlockchainUpdated
             * @instance
             */
            BlockchainUpdated.prototype.id = $util.newBuffer([]);

            /**
             * BlockchainUpdated height.
             * @member {number} height
             * @memberof vrp.events.BlockchainUpdated
             * @instance
             */
            BlockchainUpdated.prototype.height = 0;

            /**
             * BlockchainUpdated append.
             * @member {vrp.events.BlockchainUpdated.IAppend|null|undefined} append
             * @memberof vrp.events.BlockchainUpdated
             * @instance
             */
            BlockchainUpdated.prototype.append = null;

            /**
             * BlockchainUpdated rollback.
             * @member {vrp.events.BlockchainUpdated.IRollback|null|undefined} rollback
             * @memberof vrp.events.BlockchainUpdated
             * @instance
             */
            BlockchainUpdated.prototype.rollback = null;

            /**
             * BlockchainUpdated referencedAssets.
             * @member {Array.<vrp.events.StateUpdate.IAssetInfo>} referencedAssets
             * @memberof vrp.events.BlockchainUpdated
             * @instance
             */
            BlockchainUpdated.prototype.referencedAssets = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * BlockchainUpdated update.
             * @member {"append"|"rollback"|undefined} update
             * @memberof vrp.events.BlockchainUpdated
             * @instance
             */
            Object.defineProperty(BlockchainUpdated.prototype, "update", {
                get: $util.oneOfGetter($oneOfFields = ["append", "rollback"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Encodes the specified BlockchainUpdated message. Does not implicitly {@link vrp.events.BlockchainUpdated.verify|verify} messages.
             * @function encode
             * @memberof vrp.events.BlockchainUpdated
             * @static
             * @param {vrp.events.IBlockchainUpdated} m BlockchainUpdated message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockchainUpdated.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.id != null && Object.hasOwnProperty.call(m, "id"))
                    w.uint32(10).bytes(m.id);
                if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                    w.uint32(16).int32(m.height);
                if (m.append != null && Object.hasOwnProperty.call(m, "append"))
                    $root.vrp.events.BlockchainUpdated.Append.encode(m.append, w.uint32(90).fork()).ldelim();
                if (m.rollback != null && Object.hasOwnProperty.call(m, "rollback"))
                    $root.vrp.events.BlockchainUpdated.Rollback.encode(m.rollback, w.uint32(98).fork()).ldelim();
                if (m.referencedAssets != null && m.referencedAssets.length) {
                    for (var i = 0; i < m.referencedAssets.length; ++i)
                        $root.vrp.events.StateUpdate.AssetInfo.encode(m.referencedAssets[i], w.uint32(170).fork()).ldelim();
                }
                return w;
            };

            /**
             * Decodes a BlockchainUpdated message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.events.BlockchainUpdated
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.events.BlockchainUpdated} BlockchainUpdated
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockchainUpdated.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.BlockchainUpdated();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.id = r.bytes();
                        break;
                    case 2:
                        m.height = r.int32();
                        break;
                    case 11:
                        m.append = $root.vrp.events.BlockchainUpdated.Append.decode(r, r.uint32());
                        break;
                    case 12:
                        m.rollback = $root.vrp.events.BlockchainUpdated.Rollback.decode(r, r.uint32());
                        break;
                    case 21:
                        if (!(m.referencedAssets && m.referencedAssets.length))
                            m.referencedAssets = [];
                        m.referencedAssets.push($root.vrp.events.StateUpdate.AssetInfo.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            BlockchainUpdated.Append = (function() {

                /**
                 * Properties of an Append.
                 * @memberof vrp.events.BlockchainUpdated
                 * @interface IAppend
                 * @property {vrp.events.BlockchainUpdated.Append.IBlockAppend|null} [block] Append block
                 * @property {vrp.events.BlockchainUpdated.Append.IMicroBlockAppend|null} [microBlock] Append microBlock
                 * @property {Array.<Uint8Array>|null} [transactionIds] Append transactionIds
                 * @property {Array.<vrp.events.ITransactionMetadata>|null} [transactionsMetadata] Append transactionsMetadata
                 * @property {vrp.events.IStateUpdate|null} [stateUpdate] Append stateUpdate
                 * @property {Array.<vrp.events.IStateUpdate>|null} [transactionStateUpdates] Append transactionStateUpdates
                 */

                /**
                 * Constructs a new Append.
                 * @memberof vrp.events.BlockchainUpdated
                 * @classdesc Represents an Append.
                 * @implements IAppend
                 * @constructor
                 * @param {vrp.events.BlockchainUpdated.IAppend=} [p] Properties to set
                 */
                function Append(p) {
                    this.transactionIds = [];
                    this.transactionsMetadata = [];
                    this.transactionStateUpdates = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Append block.
                 * @member {vrp.events.BlockchainUpdated.Append.IBlockAppend|null|undefined} block
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @instance
                 */
                Append.prototype.block = null;

                /**
                 * Append microBlock.
                 * @member {vrp.events.BlockchainUpdated.Append.IMicroBlockAppend|null|undefined} microBlock
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @instance
                 */
                Append.prototype.microBlock = null;

                /**
                 * Append transactionIds.
                 * @member {Array.<Uint8Array>} transactionIds
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @instance
                 */
                Append.prototype.transactionIds = $util.emptyArray;

                /**
                 * Append transactionsMetadata.
                 * @member {Array.<vrp.events.ITransactionMetadata>} transactionsMetadata
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @instance
                 */
                Append.prototype.transactionsMetadata = $util.emptyArray;

                /**
                 * Append stateUpdate.
                 * @member {vrp.events.IStateUpdate|null|undefined} stateUpdate
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @instance
                 */
                Append.prototype.stateUpdate = null;

                /**
                 * Append transactionStateUpdates.
                 * @member {Array.<vrp.events.IStateUpdate>} transactionStateUpdates
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @instance
                 */
                Append.prototype.transactionStateUpdates = $util.emptyArray;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Append body.
                 * @member {"block"|"microBlock"|undefined} body
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @instance
                 */
                Object.defineProperty(Append.prototype, "body", {
                    get: $util.oneOfGetter($oneOfFields = ["block", "microBlock"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified Append message. Does not implicitly {@link vrp.events.BlockchainUpdated.Append.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @static
                 * @param {vrp.events.BlockchainUpdated.IAppend} m Append message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Append.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.block != null && Object.hasOwnProperty.call(m, "block"))
                        $root.vrp.events.BlockchainUpdated.Append.BlockAppend.encode(m.block, w.uint32(10).fork()).ldelim();
                    if (m.microBlock != null && Object.hasOwnProperty.call(m, "microBlock"))
                        $root.vrp.events.BlockchainUpdated.Append.MicroBlockAppend.encode(m.microBlock, w.uint32(18).fork()).ldelim();
                    if (m.transactionIds != null && m.transactionIds.length) {
                        for (var i = 0; i < m.transactionIds.length; ++i)
                            w.uint32(26).bytes(m.transactionIds[i]);
                    }
                    if (m.transactionsMetadata != null && m.transactionsMetadata.length) {
                        for (var i = 0; i < m.transactionsMetadata.length; ++i)
                            $root.vrp.events.TransactionMetadata.encode(m.transactionsMetadata[i], w.uint32(34).fork()).ldelim();
                    }
                    if (m.stateUpdate != null && Object.hasOwnProperty.call(m, "stateUpdate"))
                        $root.vrp.events.StateUpdate.encode(m.stateUpdate, w.uint32(90).fork()).ldelim();
                    if (m.transactionStateUpdates != null && m.transactionStateUpdates.length) {
                        for (var i = 0; i < m.transactionStateUpdates.length; ++i)
                            $root.vrp.events.StateUpdate.encode(m.transactionStateUpdates[i], w.uint32(98).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes an Append message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.BlockchainUpdated.Append
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.BlockchainUpdated.Append} Append
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Append.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.BlockchainUpdated.Append();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.block = $root.vrp.events.BlockchainUpdated.Append.BlockAppend.decode(r, r.uint32());
                            break;
                        case 2:
                            m.microBlock = $root.vrp.events.BlockchainUpdated.Append.MicroBlockAppend.decode(r, r.uint32());
                            break;
                        case 3:
                            if (!(m.transactionIds && m.transactionIds.length))
                                m.transactionIds = [];
                            m.transactionIds.push(r.bytes());
                            break;
                        case 4:
                            if (!(m.transactionsMetadata && m.transactionsMetadata.length))
                                m.transactionsMetadata = [];
                            m.transactionsMetadata.push($root.vrp.events.TransactionMetadata.decode(r, r.uint32()));
                            break;
                        case 11:
                            m.stateUpdate = $root.vrp.events.StateUpdate.decode(r, r.uint32());
                            break;
                        case 12:
                            if (!(m.transactionStateUpdates && m.transactionStateUpdates.length))
                                m.transactionStateUpdates = [];
                            m.transactionStateUpdates.push($root.vrp.events.StateUpdate.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                Append.BlockAppend = (function() {

                    /**
                     * Properties of a BlockAppend.
                     * @memberof vrp.events.BlockchainUpdated.Append
                     * @interface IBlockAppend
                     * @property {vrp.IBlock|null} [block] BlockAppend block
                     * @property {Long|null} [updatedVrpAmount] BlockAppend updatedVrpAmount
                     */

                    /**
                     * Constructs a new BlockAppend.
                     * @memberof vrp.events.BlockchainUpdated.Append
                     * @classdesc Represents a BlockAppend.
                     * @implements IBlockAppend
                     * @constructor
                     * @param {vrp.events.BlockchainUpdated.Append.IBlockAppend=} [p] Properties to set
                     */
                    function BlockAppend(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * BlockAppend block.
                     * @member {vrp.IBlock|null|undefined} block
                     * @memberof vrp.events.BlockchainUpdated.Append.BlockAppend
                     * @instance
                     */
                    BlockAppend.prototype.block = null;

                    /**
                     * BlockAppend updatedVrpAmount.
                     * @member {Long} updatedVrpAmount
                     * @memberof vrp.events.BlockchainUpdated.Append.BlockAppend
                     * @instance
                     */
                    BlockAppend.prototype.updatedVrpAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Encodes the specified BlockAppend message. Does not implicitly {@link vrp.events.BlockchainUpdated.Append.BlockAppend.verify|verify} messages.
                     * @function encode
                     * @memberof vrp.events.BlockchainUpdated.Append.BlockAppend
                     * @static
                     * @param {vrp.events.BlockchainUpdated.Append.IBlockAppend} m BlockAppend message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BlockAppend.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.block != null && Object.hasOwnProperty.call(m, "block"))
                            $root.vrp.Block.encode(m.block, w.uint32(10).fork()).ldelim();
                        if (m.updatedVrpAmount != null && Object.hasOwnProperty.call(m, "updatedVrpAmount"))
                            w.uint32(16).int64(m.updatedVrpAmount);
                        return w;
                    };

                    /**
                     * Decodes a BlockAppend message from the specified reader or buffer.
                     * @function decode
                     * @memberof vrp.events.BlockchainUpdated.Append.BlockAppend
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {vrp.events.BlockchainUpdated.Append.BlockAppend} BlockAppend
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BlockAppend.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.BlockchainUpdated.Append.BlockAppend();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.block = $root.vrp.Block.decode(r, r.uint32());
                                break;
                            case 2:
                                m.updatedVrpAmount = r.int64();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return BlockAppend;
                })();

                Append.MicroBlockAppend = (function() {

                    /**
                     * Properties of a MicroBlockAppend.
                     * @memberof vrp.events.BlockchainUpdated.Append
                     * @interface IMicroBlockAppend
                     * @property {vrp.ISignedMicroBlock|null} [microBlock] MicroBlockAppend microBlock
                     * @property {Uint8Array|null} [updatedTransactionsRoot] MicroBlockAppend updatedTransactionsRoot
                     */

                    /**
                     * Constructs a new MicroBlockAppend.
                     * @memberof vrp.events.BlockchainUpdated.Append
                     * @classdesc Represents a MicroBlockAppend.
                     * @implements IMicroBlockAppend
                     * @constructor
                     * @param {vrp.events.BlockchainUpdated.Append.IMicroBlockAppend=} [p] Properties to set
                     */
                    function MicroBlockAppend(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * MicroBlockAppend microBlock.
                     * @member {vrp.ISignedMicroBlock|null|undefined} microBlock
                     * @memberof vrp.events.BlockchainUpdated.Append.MicroBlockAppend
                     * @instance
                     */
                    MicroBlockAppend.prototype.microBlock = null;

                    /**
                     * MicroBlockAppend updatedTransactionsRoot.
                     * @member {Uint8Array} updatedTransactionsRoot
                     * @memberof vrp.events.BlockchainUpdated.Append.MicroBlockAppend
                     * @instance
                     */
                    MicroBlockAppend.prototype.updatedTransactionsRoot = $util.newBuffer([]);

                    /**
                     * Encodes the specified MicroBlockAppend message. Does not implicitly {@link vrp.events.BlockchainUpdated.Append.MicroBlockAppend.verify|verify} messages.
                     * @function encode
                     * @memberof vrp.events.BlockchainUpdated.Append.MicroBlockAppend
                     * @static
                     * @param {vrp.events.BlockchainUpdated.Append.IMicroBlockAppend} m MicroBlockAppend message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MicroBlockAppend.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.microBlock != null && Object.hasOwnProperty.call(m, "microBlock"))
                            $root.vrp.SignedMicroBlock.encode(m.microBlock, w.uint32(10).fork()).ldelim();
                        if (m.updatedTransactionsRoot != null && Object.hasOwnProperty.call(m, "updatedTransactionsRoot"))
                            w.uint32(18).bytes(m.updatedTransactionsRoot);
                        return w;
                    };

                    /**
                     * Decodes a MicroBlockAppend message from the specified reader or buffer.
                     * @function decode
                     * @memberof vrp.events.BlockchainUpdated.Append.MicroBlockAppend
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {vrp.events.BlockchainUpdated.Append.MicroBlockAppend} MicroBlockAppend
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MicroBlockAppend.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.BlockchainUpdated.Append.MicroBlockAppend();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.microBlock = $root.vrp.SignedMicroBlock.decode(r, r.uint32());
                                break;
                            case 2:
                                m.updatedTransactionsRoot = r.bytes();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return MicroBlockAppend;
                })();

                return Append;
            })();

            BlockchainUpdated.Rollback = (function() {

                /**
                 * Properties of a Rollback.
                 * @memberof vrp.events.BlockchainUpdated
                 * @interface IRollback
                 * @property {vrp.events.BlockchainUpdated.Rollback.RollbackType|null} [type] Rollback type
                 * @property {Array.<Uint8Array>|null} [removedTransactionIds] Rollback removedTransactionIds
                 * @property {Array.<vrp.IBlock>|null} [removedBlocks] Rollback removedBlocks
                 * @property {vrp.events.IStateUpdate|null} [rollbackStateUpdate] Rollback rollbackStateUpdate
                 */

                /**
                 * Constructs a new Rollback.
                 * @memberof vrp.events.BlockchainUpdated
                 * @classdesc Represents a Rollback.
                 * @implements IRollback
                 * @constructor
                 * @param {vrp.events.BlockchainUpdated.IRollback=} [p] Properties to set
                 */
                function Rollback(p) {
                    this.removedTransactionIds = [];
                    this.removedBlocks = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Rollback type.
                 * @member {vrp.events.BlockchainUpdated.Rollback.RollbackType} type
                 * @memberof vrp.events.BlockchainUpdated.Rollback
                 * @instance
                 */
                Rollback.prototype.type = 0;

                /**
                 * Rollback removedTransactionIds.
                 * @member {Array.<Uint8Array>} removedTransactionIds
                 * @memberof vrp.events.BlockchainUpdated.Rollback
                 * @instance
                 */
                Rollback.prototype.removedTransactionIds = $util.emptyArray;

                /**
                 * Rollback removedBlocks.
                 * @member {Array.<vrp.IBlock>} removedBlocks
                 * @memberof vrp.events.BlockchainUpdated.Rollback
                 * @instance
                 */
                Rollback.prototype.removedBlocks = $util.emptyArray;

                /**
                 * Rollback rollbackStateUpdate.
                 * @member {vrp.events.IStateUpdate|null|undefined} rollbackStateUpdate
                 * @memberof vrp.events.BlockchainUpdated.Rollback
                 * @instance
                 */
                Rollback.prototype.rollbackStateUpdate = null;

                /**
                 * Encodes the specified Rollback message. Does not implicitly {@link vrp.events.BlockchainUpdated.Rollback.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.BlockchainUpdated.Rollback
                 * @static
                 * @param {vrp.events.BlockchainUpdated.IRollback} m Rollback message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rollback.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.type != null && Object.hasOwnProperty.call(m, "type"))
                        w.uint32(8).int32(m.type);
                    if (m.removedTransactionIds != null && m.removedTransactionIds.length) {
                        for (var i = 0; i < m.removedTransactionIds.length; ++i)
                            w.uint32(18).bytes(m.removedTransactionIds[i]);
                    }
                    if (m.removedBlocks != null && m.removedBlocks.length) {
                        for (var i = 0; i < m.removedBlocks.length; ++i)
                            $root.vrp.Block.encode(m.removedBlocks[i], w.uint32(26).fork()).ldelim();
                    }
                    if (m.rollbackStateUpdate != null && Object.hasOwnProperty.call(m, "rollbackStateUpdate"))
                        $root.vrp.events.StateUpdate.encode(m.rollbackStateUpdate, w.uint32(34).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a Rollback message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.BlockchainUpdated.Rollback
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.BlockchainUpdated.Rollback} Rollback
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rollback.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.BlockchainUpdated.Rollback();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.type = r.int32();
                            break;
                        case 2:
                            if (!(m.removedTransactionIds && m.removedTransactionIds.length))
                                m.removedTransactionIds = [];
                            m.removedTransactionIds.push(r.bytes());
                            break;
                        case 3:
                            if (!(m.removedBlocks && m.removedBlocks.length))
                                m.removedBlocks = [];
                            m.removedBlocks.push($root.vrp.Block.decode(r, r.uint32()));
                            break;
                        case 4:
                            m.rollbackStateUpdate = $root.vrp.events.StateUpdate.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * RollbackType enum.
                 * @name vrp.events.BlockchainUpdated.Rollback.RollbackType
                 * @enum {number}
                 * @property {number} BLOCK=0 BLOCK value
                 * @property {number} MICROBLOCK=1 MICROBLOCK value
                 */
                Rollback.RollbackType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BLOCK"] = 0;
                    values[valuesById[1] = "MICROBLOCK"] = 1;
                    return values;
                })();

                return Rollback;
            })();

            return BlockchainUpdated;
        })();

        events.StateUpdate = (function() {

            /**
             * Properties of a StateUpdate.
             * @memberof vrp.events
             * @interface IStateUpdate
             * @property {Array.<vrp.events.StateUpdate.IBalanceUpdate>|null} [balances] StateUpdate balances
             * @property {Array.<vrp.events.StateUpdate.ILeasingUpdate>|null} [leasingForAddress] StateUpdate leasingForAddress
             * @property {Array.<vrp.events.StateUpdate.IDataEntryUpdate>|null} [dataEntries] StateUpdate dataEntries
             * @property {Array.<vrp.events.StateUpdate.IAssetStateUpdate>|null} [assets] StateUpdate assets
             * @property {Array.<vrp.events.StateUpdate.ILeaseUpdate>|null} [individualLeases] StateUpdate individualLeases
             */

            /**
             * Constructs a new StateUpdate.
             * @memberof vrp.events
             * @classdesc Represents a StateUpdate.
             * @implements IStateUpdate
             * @constructor
             * @param {vrp.events.IStateUpdate=} [p] Properties to set
             */
            function StateUpdate(p) {
                this.balances = [];
                this.leasingForAddress = [];
                this.dataEntries = [];
                this.assets = [];
                this.individualLeases = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * StateUpdate balances.
             * @member {Array.<vrp.events.StateUpdate.IBalanceUpdate>} balances
             * @memberof vrp.events.StateUpdate
             * @instance
             */
            StateUpdate.prototype.balances = $util.emptyArray;

            /**
             * StateUpdate leasingForAddress.
             * @member {Array.<vrp.events.StateUpdate.ILeasingUpdate>} leasingForAddress
             * @memberof vrp.events.StateUpdate
             * @instance
             */
            StateUpdate.prototype.leasingForAddress = $util.emptyArray;

            /**
             * StateUpdate dataEntries.
             * @member {Array.<vrp.events.StateUpdate.IDataEntryUpdate>} dataEntries
             * @memberof vrp.events.StateUpdate
             * @instance
             */
            StateUpdate.prototype.dataEntries = $util.emptyArray;

            /**
             * StateUpdate assets.
             * @member {Array.<vrp.events.StateUpdate.IAssetStateUpdate>} assets
             * @memberof vrp.events.StateUpdate
             * @instance
             */
            StateUpdate.prototype.assets = $util.emptyArray;

            /**
             * StateUpdate individualLeases.
             * @member {Array.<vrp.events.StateUpdate.ILeaseUpdate>} individualLeases
             * @memberof vrp.events.StateUpdate
             * @instance
             */
            StateUpdate.prototype.individualLeases = $util.emptyArray;

            /**
             * Encodes the specified StateUpdate message. Does not implicitly {@link vrp.events.StateUpdate.verify|verify} messages.
             * @function encode
             * @memberof vrp.events.StateUpdate
             * @static
             * @param {vrp.events.IStateUpdate} m StateUpdate message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateUpdate.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.balances != null && m.balances.length) {
                    for (var i = 0; i < m.balances.length; ++i)
                        $root.vrp.events.StateUpdate.BalanceUpdate.encode(m.balances[i], w.uint32(10).fork()).ldelim();
                }
                if (m.leasingForAddress != null && m.leasingForAddress.length) {
                    for (var i = 0; i < m.leasingForAddress.length; ++i)
                        $root.vrp.events.StateUpdate.LeasingUpdate.encode(m.leasingForAddress[i], w.uint32(18).fork()).ldelim();
                }
                if (m.dataEntries != null && m.dataEntries.length) {
                    for (var i = 0; i < m.dataEntries.length; ++i)
                        $root.vrp.events.StateUpdate.DataEntryUpdate.encode(m.dataEntries[i], w.uint32(26).fork()).ldelim();
                }
                if (m.assets != null && m.assets.length) {
                    for (var i = 0; i < m.assets.length; ++i)
                        $root.vrp.events.StateUpdate.AssetStateUpdate.encode(m.assets[i], w.uint32(34).fork()).ldelim();
                }
                if (m.individualLeases != null && m.individualLeases.length) {
                    for (var i = 0; i < m.individualLeases.length; ++i)
                        $root.vrp.events.StateUpdate.LeaseUpdate.encode(m.individualLeases[i], w.uint32(42).fork()).ldelim();
                }
                return w;
            };

            /**
             * Decodes a StateUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.events.StateUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.events.StateUpdate} StateUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateUpdate.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.balances && m.balances.length))
                            m.balances = [];
                        m.balances.push($root.vrp.events.StateUpdate.BalanceUpdate.decode(r, r.uint32()));
                        break;
                    case 2:
                        if (!(m.leasingForAddress && m.leasingForAddress.length))
                            m.leasingForAddress = [];
                        m.leasingForAddress.push($root.vrp.events.StateUpdate.LeasingUpdate.decode(r, r.uint32()));
                        break;
                    case 3:
                        if (!(m.dataEntries && m.dataEntries.length))
                            m.dataEntries = [];
                        m.dataEntries.push($root.vrp.events.StateUpdate.DataEntryUpdate.decode(r, r.uint32()));
                        break;
                    case 4:
                        if (!(m.assets && m.assets.length))
                            m.assets = [];
                        m.assets.push($root.vrp.events.StateUpdate.AssetStateUpdate.decode(r, r.uint32()));
                        break;
                    case 5:
                        if (!(m.individualLeases && m.individualLeases.length))
                            m.individualLeases = [];
                        m.individualLeases.push($root.vrp.events.StateUpdate.LeaseUpdate.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            StateUpdate.BalanceUpdate = (function() {

                /**
                 * Properties of a BalanceUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @interface IBalanceUpdate
                 * @property {Uint8Array|null} [address] BalanceUpdate address
                 * @property {vrp.IAmount|null} [amountAfter] BalanceUpdate amountAfter
                 * @property {Long|null} [amountBefore] BalanceUpdate amountBefore
                 */

                /**
                 * Constructs a new BalanceUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @classdesc Represents a BalanceUpdate.
                 * @implements IBalanceUpdate
                 * @constructor
                 * @param {vrp.events.StateUpdate.IBalanceUpdate=} [p] Properties to set
                 */
                function BalanceUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BalanceUpdate address.
                 * @member {Uint8Array} address
                 * @memberof vrp.events.StateUpdate.BalanceUpdate
                 * @instance
                 */
                BalanceUpdate.prototype.address = $util.newBuffer([]);

                /**
                 * BalanceUpdate amountAfter.
                 * @member {vrp.IAmount|null|undefined} amountAfter
                 * @memberof vrp.events.StateUpdate.BalanceUpdate
                 * @instance
                 */
                BalanceUpdate.prototype.amountAfter = null;

                /**
                 * BalanceUpdate amountBefore.
                 * @member {Long} amountBefore
                 * @memberof vrp.events.StateUpdate.BalanceUpdate
                 * @instance
                 */
                BalanceUpdate.prototype.amountBefore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Encodes the specified BalanceUpdate message. Does not implicitly {@link vrp.events.StateUpdate.BalanceUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.StateUpdate.BalanceUpdate
                 * @static
                 * @param {vrp.events.StateUpdate.IBalanceUpdate} m BalanceUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BalanceUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    if (m.amountAfter != null && Object.hasOwnProperty.call(m, "amountAfter"))
                        $root.vrp.Amount.encode(m.amountAfter, w.uint32(18).fork()).ldelim();
                    if (m.amountBefore != null && Object.hasOwnProperty.call(m, "amountBefore"))
                        w.uint32(24).int64(m.amountBefore);
                    return w;
                };

                /**
                 * Decodes a BalanceUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.StateUpdate.BalanceUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.StateUpdate.BalanceUpdate} BalanceUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BalanceUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.BalanceUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.amountAfter = $root.vrp.Amount.decode(r, r.uint32());
                            break;
                        case 3:
                            m.amountBefore = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BalanceUpdate;
            })();

            StateUpdate.LeasingUpdate = (function() {

                /**
                 * Properties of a LeasingUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @interface ILeasingUpdate
                 * @property {Uint8Array|null} [address] LeasingUpdate address
                 * @property {Long|null} [inAfter] LeasingUpdate inAfter
                 * @property {Long|null} [outAfter] LeasingUpdate outAfter
                 * @property {Long|null} [inBefore] LeasingUpdate inBefore
                 * @property {Long|null} [outBefore] LeasingUpdate outBefore
                 */

                /**
                 * Constructs a new LeasingUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @classdesc Represents a LeasingUpdate.
                 * @implements ILeasingUpdate
                 * @constructor
                 * @param {vrp.events.StateUpdate.ILeasingUpdate=} [p] Properties to set
                 */
                function LeasingUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * LeasingUpdate address.
                 * @member {Uint8Array} address
                 * @memberof vrp.events.StateUpdate.LeasingUpdate
                 * @instance
                 */
                LeasingUpdate.prototype.address = $util.newBuffer([]);

                /**
                 * LeasingUpdate inAfter.
                 * @member {Long} inAfter
                 * @memberof vrp.events.StateUpdate.LeasingUpdate
                 * @instance
                 */
                LeasingUpdate.prototype.inAfter = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LeasingUpdate outAfter.
                 * @member {Long} outAfter
                 * @memberof vrp.events.StateUpdate.LeasingUpdate
                 * @instance
                 */
                LeasingUpdate.prototype.outAfter = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LeasingUpdate inBefore.
                 * @member {Long} inBefore
                 * @memberof vrp.events.StateUpdate.LeasingUpdate
                 * @instance
                 */
                LeasingUpdate.prototype.inBefore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LeasingUpdate outBefore.
                 * @member {Long} outBefore
                 * @memberof vrp.events.StateUpdate.LeasingUpdate
                 * @instance
                 */
                LeasingUpdate.prototype.outBefore = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Encodes the specified LeasingUpdate message. Does not implicitly {@link vrp.events.StateUpdate.LeasingUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.StateUpdate.LeasingUpdate
                 * @static
                 * @param {vrp.events.StateUpdate.ILeasingUpdate} m LeasingUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LeasingUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    if (m.inAfter != null && Object.hasOwnProperty.call(m, "inAfter"))
                        w.uint32(16).int64(m.inAfter);
                    if (m.outAfter != null && Object.hasOwnProperty.call(m, "outAfter"))
                        w.uint32(24).int64(m.outAfter);
                    if (m.inBefore != null && Object.hasOwnProperty.call(m, "inBefore"))
                        w.uint32(32).int64(m.inBefore);
                    if (m.outBefore != null && Object.hasOwnProperty.call(m, "outBefore"))
                        w.uint32(40).int64(m.outBefore);
                    return w;
                };

                /**
                 * Decodes a LeasingUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.StateUpdate.LeasingUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.StateUpdate.LeasingUpdate} LeasingUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LeasingUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.LeasingUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.inAfter = r.int64();
                            break;
                        case 3:
                            m.outAfter = r.int64();
                            break;
                        case 4:
                            m.inBefore = r.int64();
                            break;
                        case 5:
                            m.outBefore = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return LeasingUpdate;
            })();

            StateUpdate.LeaseUpdate = (function() {

                /**
                 * Properties of a LeaseUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @interface ILeaseUpdate
                 * @property {Uint8Array|null} [leaseId] LeaseUpdate leaseId
                 * @property {vrp.events.StateUpdate.LeaseUpdate.LeaseStatus|null} [statusAfter] LeaseUpdate statusAfter
                 * @property {Long|null} [amount] LeaseUpdate amount
                 * @property {Uint8Array|null} [sender] LeaseUpdate sender
                 * @property {Uint8Array|null} [recipient] LeaseUpdate recipient
                 * @property {Uint8Array|null} [originTransactionId] LeaseUpdate originTransactionId
                 */

                /**
                 * Constructs a new LeaseUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @classdesc Represents a LeaseUpdate.
                 * @implements ILeaseUpdate
                 * @constructor
                 * @param {vrp.events.StateUpdate.ILeaseUpdate=} [p] Properties to set
                 */
                function LeaseUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * LeaseUpdate leaseId.
                 * @member {Uint8Array} leaseId
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @instance
                 */
                LeaseUpdate.prototype.leaseId = $util.newBuffer([]);

                /**
                 * LeaseUpdate statusAfter.
                 * @member {vrp.events.StateUpdate.LeaseUpdate.LeaseStatus} statusAfter
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @instance
                 */
                LeaseUpdate.prototype.statusAfter = 0;

                /**
                 * LeaseUpdate amount.
                 * @member {Long} amount
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @instance
                 */
                LeaseUpdate.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LeaseUpdate sender.
                 * @member {Uint8Array} sender
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @instance
                 */
                LeaseUpdate.prototype.sender = $util.newBuffer([]);

                /**
                 * LeaseUpdate recipient.
                 * @member {Uint8Array} recipient
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @instance
                 */
                LeaseUpdate.prototype.recipient = $util.newBuffer([]);

                /**
                 * LeaseUpdate originTransactionId.
                 * @member {Uint8Array} originTransactionId
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @instance
                 */
                LeaseUpdate.prototype.originTransactionId = $util.newBuffer([]);

                /**
                 * Encodes the specified LeaseUpdate message. Does not implicitly {@link vrp.events.StateUpdate.LeaseUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @static
                 * @param {vrp.events.StateUpdate.ILeaseUpdate} m LeaseUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LeaseUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.leaseId != null && Object.hasOwnProperty.call(m, "leaseId"))
                        w.uint32(10).bytes(m.leaseId);
                    if (m.statusAfter != null && Object.hasOwnProperty.call(m, "statusAfter"))
                        w.uint32(16).int32(m.statusAfter);
                    if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                        w.uint32(80).int64(m.amount);
                    if (m.sender != null && Object.hasOwnProperty.call(m, "sender"))
                        w.uint32(90).bytes(m.sender);
                    if (m.recipient != null && Object.hasOwnProperty.call(m, "recipient"))
                        w.uint32(98).bytes(m.recipient);
                    if (m.originTransactionId != null && Object.hasOwnProperty.call(m, "originTransactionId"))
                        w.uint32(106).bytes(m.originTransactionId);
                    return w;
                };

                /**
                 * Decodes a LeaseUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.StateUpdate.LeaseUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.StateUpdate.LeaseUpdate} LeaseUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LeaseUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.LeaseUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.leaseId = r.bytes();
                            break;
                        case 2:
                            m.statusAfter = r.int32();
                            break;
                        case 10:
                            m.amount = r.int64();
                            break;
                        case 11:
                            m.sender = r.bytes();
                            break;
                        case 12:
                            m.recipient = r.bytes();
                            break;
                        case 13:
                            m.originTransactionId = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * LeaseStatus enum.
                 * @name vrp.events.StateUpdate.LeaseUpdate.LeaseStatus
                 * @enum {number}
                 * @property {number} INACTIVE=0 INACTIVE value
                 * @property {number} ACTIVE=1 ACTIVE value
                 */
                LeaseUpdate.LeaseStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INACTIVE"] = 0;
                    values[valuesById[1] = "ACTIVE"] = 1;
                    return values;
                })();

                return LeaseUpdate;
            })();

            StateUpdate.DataEntryUpdate = (function() {

                /**
                 * Properties of a DataEntryUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @interface IDataEntryUpdate
                 * @property {Uint8Array|null} [address] DataEntryUpdate address
                 * @property {vrp.DataTransactionData.IDataEntry|null} [dataEntry] DataEntryUpdate dataEntry
                 * @property {vrp.DataTransactionData.IDataEntry|null} [dataEntryBefore] DataEntryUpdate dataEntryBefore
                 */

                /**
                 * Constructs a new DataEntryUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @classdesc Represents a DataEntryUpdate.
                 * @implements IDataEntryUpdate
                 * @constructor
                 * @param {vrp.events.StateUpdate.IDataEntryUpdate=} [p] Properties to set
                 */
                function DataEntryUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * DataEntryUpdate address.
                 * @member {Uint8Array} address
                 * @memberof vrp.events.StateUpdate.DataEntryUpdate
                 * @instance
                 */
                DataEntryUpdate.prototype.address = $util.newBuffer([]);

                /**
                 * DataEntryUpdate dataEntry.
                 * @member {vrp.DataTransactionData.IDataEntry|null|undefined} dataEntry
                 * @memberof vrp.events.StateUpdate.DataEntryUpdate
                 * @instance
                 */
                DataEntryUpdate.prototype.dataEntry = null;

                /**
                 * DataEntryUpdate dataEntryBefore.
                 * @member {vrp.DataTransactionData.IDataEntry|null|undefined} dataEntryBefore
                 * @memberof vrp.events.StateUpdate.DataEntryUpdate
                 * @instance
                 */
                DataEntryUpdate.prototype.dataEntryBefore = null;

                /**
                 * Encodes the specified DataEntryUpdate message. Does not implicitly {@link vrp.events.StateUpdate.DataEntryUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.StateUpdate.DataEntryUpdate
                 * @static
                 * @param {vrp.events.StateUpdate.IDataEntryUpdate} m DataEntryUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataEntryUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    if (m.dataEntry != null && Object.hasOwnProperty.call(m, "dataEntry"))
                        $root.vrp.DataTransactionData.DataEntry.encode(m.dataEntry, w.uint32(18).fork()).ldelim();
                    if (m.dataEntryBefore != null && Object.hasOwnProperty.call(m, "dataEntryBefore"))
                        $root.vrp.DataTransactionData.DataEntry.encode(m.dataEntryBefore, w.uint32(82).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a DataEntryUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.StateUpdate.DataEntryUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.StateUpdate.DataEntryUpdate} DataEntryUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataEntryUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.DataEntryUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.dataEntry = $root.vrp.DataTransactionData.DataEntry.decode(r, r.uint32());
                            break;
                        case 10:
                            m.dataEntryBefore = $root.vrp.DataTransactionData.DataEntry.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return DataEntryUpdate;
            })();

            StateUpdate.AssetStateUpdate = (function() {

                /**
                 * Properties of an AssetStateUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @interface IAssetStateUpdate
                 * @property {vrp.events.StateUpdate.IAssetDetails|null} [before] AssetStateUpdate before
                 * @property {vrp.events.StateUpdate.IAssetDetails|null} [after] AssetStateUpdate after
                 */

                /**
                 * Constructs a new AssetStateUpdate.
                 * @memberof vrp.events.StateUpdate
                 * @classdesc Represents an AssetStateUpdate.
                 * @implements IAssetStateUpdate
                 * @constructor
                 * @param {vrp.events.StateUpdate.IAssetStateUpdate=} [p] Properties to set
                 */
                function AssetStateUpdate(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * AssetStateUpdate before.
                 * @member {vrp.events.StateUpdate.IAssetDetails|null|undefined} before
                 * @memberof vrp.events.StateUpdate.AssetStateUpdate
                 * @instance
                 */
                AssetStateUpdate.prototype.before = null;

                /**
                 * AssetStateUpdate after.
                 * @member {vrp.events.StateUpdate.IAssetDetails|null|undefined} after
                 * @memberof vrp.events.StateUpdate.AssetStateUpdate
                 * @instance
                 */
                AssetStateUpdate.prototype.after = null;

                /**
                 * Encodes the specified AssetStateUpdate message. Does not implicitly {@link vrp.events.StateUpdate.AssetStateUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.StateUpdate.AssetStateUpdate
                 * @static
                 * @param {vrp.events.StateUpdate.IAssetStateUpdate} m AssetStateUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AssetStateUpdate.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.before != null && Object.hasOwnProperty.call(m, "before"))
                        $root.vrp.events.StateUpdate.AssetDetails.encode(m.before, w.uint32(10).fork()).ldelim();
                    if (m.after != null && Object.hasOwnProperty.call(m, "after"))
                        $root.vrp.events.StateUpdate.AssetDetails.encode(m.after, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an AssetStateUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.StateUpdate.AssetStateUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.StateUpdate.AssetStateUpdate} AssetStateUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AssetStateUpdate.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.AssetStateUpdate();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.before = $root.vrp.events.StateUpdate.AssetDetails.decode(r, r.uint32());
                            break;
                        case 2:
                            m.after = $root.vrp.events.StateUpdate.AssetDetails.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AssetStateUpdate;
            })();

            StateUpdate.AssetDetails = (function() {

                /**
                 * Properties of an AssetDetails.
                 * @memberof vrp.events.StateUpdate
                 * @interface IAssetDetails
                 * @property {Uint8Array|null} [assetId] AssetDetails assetId
                 * @property {Uint8Array|null} [issuer] AssetDetails issuer
                 * @property {number|null} [decimals] AssetDetails decimals
                 * @property {string|null} [name] AssetDetails name
                 * @property {string|null} [description] AssetDetails description
                 * @property {string|null} [image] AssetDetails image
                 * @property {boolean|null} [reissuable] AssetDetails reissuable
                 * @property {Long|null} [volume] AssetDetails volume
                 * @property {vrp.events.StateUpdate.AssetDetails.IAssetScriptInfo|null} [scriptInfo] AssetDetails scriptInfo
                 * @property {Long|null} [sponsorship] AssetDetails sponsorship
                 * @property {boolean|null} [nft] AssetDetails nft
                 * @property {number|null} [lastUpdated] AssetDetails lastUpdated
                 * @property {Uint8Array|null} [safeVolume] AssetDetails safeVolume
                 */

                /**
                 * Constructs a new AssetDetails.
                 * @memberof vrp.events.StateUpdate
                 * @classdesc Represents an AssetDetails.
                 * @implements IAssetDetails
                 * @constructor
                 * @param {vrp.events.StateUpdate.IAssetDetails=} [p] Properties to set
                 */
                function AssetDetails(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * AssetDetails assetId.
                 * @member {Uint8Array} assetId
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.assetId = $util.newBuffer([]);

                /**
                 * AssetDetails issuer.
                 * @member {Uint8Array} issuer
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.issuer = $util.newBuffer([]);

                /**
                 * AssetDetails decimals.
                 * @member {number} decimals
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.decimals = 0;

                /**
                 * AssetDetails name.
                 * @member {string} name
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.name = "";

                /**
                 * AssetDetails description.
                 * @member {string} description
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.description = "";

                /**
                 * AssetDetails image.
                 * @member {string} image
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.image = "";

                /**
                 * AssetDetails reissuable.
                 * @member {boolean} reissuable
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.reissuable = false;

                /**
                 * AssetDetails volume.
                 * @member {Long} volume
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * AssetDetails scriptInfo.
                 * @member {vrp.events.StateUpdate.AssetDetails.IAssetScriptInfo|null|undefined} scriptInfo
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.scriptInfo = null;

                /**
                 * AssetDetails sponsorship.
                 * @member {Long} sponsorship
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.sponsorship = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * AssetDetails nft.
                 * @member {boolean} nft
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.nft = false;

                /**
                 * AssetDetails lastUpdated.
                 * @member {number} lastUpdated
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.lastUpdated = 0;

                /**
                 * AssetDetails safeVolume.
                 * @member {Uint8Array} safeVolume
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @instance
                 */
                AssetDetails.prototype.safeVolume = $util.newBuffer([]);

                /**
                 * Encodes the specified AssetDetails message. Does not implicitly {@link vrp.events.StateUpdate.AssetDetails.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @static
                 * @param {vrp.events.StateUpdate.IAssetDetails} m AssetDetails message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AssetDetails.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                        w.uint32(10).bytes(m.assetId);
                    if (m.issuer != null && Object.hasOwnProperty.call(m, "issuer"))
                        w.uint32(18).bytes(m.issuer);
                    if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                        w.uint32(24).int32(m.decimals);
                    if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                        w.uint32(34).string(m.name);
                    if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                        w.uint32(42).string(m.description);
                    if (m.image != null && Object.hasOwnProperty.call(m, "image"))
                        w.uint32(50).string(m.image);
                    if (m.reissuable != null && Object.hasOwnProperty.call(m, "reissuable"))
                        w.uint32(56).bool(m.reissuable);
                    if (m.volume != null && Object.hasOwnProperty.call(m, "volume"))
                        w.uint32(64).int64(m.volume);
                    if (m.scriptInfo != null && Object.hasOwnProperty.call(m, "scriptInfo"))
                        $root.vrp.events.StateUpdate.AssetDetails.AssetScriptInfo.encode(m.scriptInfo, w.uint32(74).fork()).ldelim();
                    if (m.sponsorship != null && Object.hasOwnProperty.call(m, "sponsorship"))
                        w.uint32(80).int64(m.sponsorship);
                    if (m.nft != null && Object.hasOwnProperty.call(m, "nft"))
                        w.uint32(88).bool(m.nft);
                    if (m.lastUpdated != null && Object.hasOwnProperty.call(m, "lastUpdated"))
                        w.uint32(96).int32(m.lastUpdated);
                    if (m.safeVolume != null && Object.hasOwnProperty.call(m, "safeVolume"))
                        w.uint32(162).bytes(m.safeVolume);
                    return w;
                };

                /**
                 * Decodes an AssetDetails message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.StateUpdate.AssetDetails
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.StateUpdate.AssetDetails} AssetDetails
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AssetDetails.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.AssetDetails();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        case 2:
                            m.issuer = r.bytes();
                            break;
                        case 3:
                            m.decimals = r.int32();
                            break;
                        case 4:
                            m.name = r.string();
                            break;
                        case 5:
                            m.description = r.string();
                            break;
                        case 6:
                            m.image = r.string();
                            break;
                        case 7:
                            m.reissuable = r.bool();
                            break;
                        case 8:
                            m.volume = r.int64();
                            break;
                        case 9:
                            m.scriptInfo = $root.vrp.events.StateUpdate.AssetDetails.AssetScriptInfo.decode(r, r.uint32());
                            break;
                        case 10:
                            m.sponsorship = r.int64();
                            break;
                        case 11:
                            m.nft = r.bool();
                            break;
                        case 12:
                            m.lastUpdated = r.int32();
                            break;
                        case 20:
                            m.safeVolume = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                AssetDetails.AssetScriptInfo = (function() {

                    /**
                     * Properties of an AssetScriptInfo.
                     * @memberof vrp.events.StateUpdate.AssetDetails
                     * @interface IAssetScriptInfo
                     * @property {Uint8Array|null} [script] AssetScriptInfo script
                     * @property {Long|null} [complexity] AssetScriptInfo complexity
                     */

                    /**
                     * Constructs a new AssetScriptInfo.
                     * @memberof vrp.events.StateUpdate.AssetDetails
                     * @classdesc Represents an AssetScriptInfo.
                     * @implements IAssetScriptInfo
                     * @constructor
                     * @param {vrp.events.StateUpdate.AssetDetails.IAssetScriptInfo=} [p] Properties to set
                     */
                    function AssetScriptInfo(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * AssetScriptInfo script.
                     * @member {Uint8Array} script
                     * @memberof vrp.events.StateUpdate.AssetDetails.AssetScriptInfo
                     * @instance
                     */
                    AssetScriptInfo.prototype.script = $util.newBuffer([]);

                    /**
                     * AssetScriptInfo complexity.
                     * @member {Long} complexity
                     * @memberof vrp.events.StateUpdate.AssetDetails.AssetScriptInfo
                     * @instance
                     */
                    AssetScriptInfo.prototype.complexity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Encodes the specified AssetScriptInfo message. Does not implicitly {@link vrp.events.StateUpdate.AssetDetails.AssetScriptInfo.verify|verify} messages.
                     * @function encode
                     * @memberof vrp.events.StateUpdate.AssetDetails.AssetScriptInfo
                     * @static
                     * @param {vrp.events.StateUpdate.AssetDetails.IAssetScriptInfo} m AssetScriptInfo message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AssetScriptInfo.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.script != null && Object.hasOwnProperty.call(m, "script"))
                            w.uint32(10).bytes(m.script);
                        if (m.complexity != null && Object.hasOwnProperty.call(m, "complexity"))
                            w.uint32(16).int64(m.complexity);
                        return w;
                    };

                    /**
                     * Decodes an AssetScriptInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof vrp.events.StateUpdate.AssetDetails.AssetScriptInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {vrp.events.StateUpdate.AssetDetails.AssetScriptInfo} AssetScriptInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AssetScriptInfo.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.AssetDetails.AssetScriptInfo();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.script = r.bytes();
                                break;
                            case 2:
                                m.complexity = r.int64();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return AssetScriptInfo;
                })();

                return AssetDetails;
            })();

            StateUpdate.AssetInfo = (function() {

                /**
                 * Properties of an AssetInfo.
                 * @memberof vrp.events.StateUpdate
                 * @interface IAssetInfo
                 * @property {Uint8Array|null} [id] AssetInfo id
                 * @property {number|null} [decimals] AssetInfo decimals
                 * @property {string|null} [name] AssetInfo name
                 * @property {string|null} [image] AssetInfo image
                 */

                /**
                 * Constructs a new AssetInfo.
                 * @memberof vrp.events.StateUpdate
                 * @classdesc Represents an AssetInfo.
                 * @implements IAssetInfo
                 * @constructor
                 * @param {vrp.events.StateUpdate.IAssetInfo=} [p] Properties to set
                 */
                function AssetInfo(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * AssetInfo id.
                 * @member {Uint8Array} id
                 * @memberof vrp.events.StateUpdate.AssetInfo
                 * @instance
                 */
                AssetInfo.prototype.id = $util.newBuffer([]);

                /**
                 * AssetInfo decimals.
                 * @member {number} decimals
                 * @memberof vrp.events.StateUpdate.AssetInfo
                 * @instance
                 */
                AssetInfo.prototype.decimals = 0;

                /**
                 * AssetInfo name.
                 * @member {string} name
                 * @memberof vrp.events.StateUpdate.AssetInfo
                 * @instance
                 */
                AssetInfo.prototype.name = "";

                /**
                 * AssetInfo image.
                 * @member {string} image
                 * @memberof vrp.events.StateUpdate.AssetInfo
                 * @instance
                 */
                AssetInfo.prototype.image = "";

                /**
                 * Encodes the specified AssetInfo message. Does not implicitly {@link vrp.events.StateUpdate.AssetInfo.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.StateUpdate.AssetInfo
                 * @static
                 * @param {vrp.events.StateUpdate.IAssetInfo} m AssetInfo message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AssetInfo.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && Object.hasOwnProperty.call(m, "id"))
                        w.uint32(10).bytes(m.id);
                    if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                        w.uint32(16).int32(m.decimals);
                    if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                        w.uint32(26).string(m.name);
                    if (m.image != null && Object.hasOwnProperty.call(m, "image"))
                        w.uint32(34).string(m.image);
                    return w;
                };

                /**
                 * Decodes an AssetInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.StateUpdate.AssetInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.StateUpdate.AssetInfo} AssetInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AssetInfo.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.StateUpdate.AssetInfo();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.bytes();
                            break;
                        case 2:
                            m.decimals = r.int32();
                            break;
                        case 3:
                            m.name = r.string();
                            break;
                        case 4:
                            m.image = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AssetInfo;
            })();

            return StateUpdate;
        })();

        events.TransactionMetadata = (function() {

            /**
             * Properties of a TransactionMetadata.
             * @memberof vrp.events
             * @interface ITransactionMetadata
             * @property {vrp.events.TransactionMetadata.ITransferMetadata|null} [transfer] TransactionMetadata transfer
             * @property {vrp.events.TransactionMetadata.IExchangeMetadata|null} [exchange] TransactionMetadata exchange
             * @property {vrp.events.TransactionMetadata.IMassTransferMetadata|null} [massTransfer] TransactionMetadata massTransfer
             * @property {vrp.events.TransactionMetadata.IInvokeScriptMetadata|null} [invokeScript] TransactionMetadata invokeScript
             * @property {vrp.events.TransactionMetadata.ILeaseMetadata|null} [leaseMeta] TransactionMetadata leaseMeta
             * @property {vrp.events.TransactionMetadata.IEthereumMetadata|null} [ethereum] TransactionMetadata ethereum
             */

            /**
             * Constructs a new TransactionMetadata.
             * @memberof vrp.events
             * @classdesc Represents a TransactionMetadata.
             * @implements ITransactionMetadata
             * @constructor
             * @param {vrp.events.ITransactionMetadata=} [p] Properties to set
             */
            function TransactionMetadata(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * TransactionMetadata transfer.
             * @member {vrp.events.TransactionMetadata.ITransferMetadata|null|undefined} transfer
             * @memberof vrp.events.TransactionMetadata
             * @instance
             */
            TransactionMetadata.prototype.transfer = null;

            /**
             * TransactionMetadata exchange.
             * @member {vrp.events.TransactionMetadata.IExchangeMetadata|null|undefined} exchange
             * @memberof vrp.events.TransactionMetadata
             * @instance
             */
            TransactionMetadata.prototype.exchange = null;

            /**
             * TransactionMetadata massTransfer.
             * @member {vrp.events.TransactionMetadata.IMassTransferMetadata|null|undefined} massTransfer
             * @memberof vrp.events.TransactionMetadata
             * @instance
             */
            TransactionMetadata.prototype.massTransfer = null;

            /**
             * TransactionMetadata invokeScript.
             * @member {vrp.events.TransactionMetadata.IInvokeScriptMetadata|null|undefined} invokeScript
             * @memberof vrp.events.TransactionMetadata
             * @instance
             */
            TransactionMetadata.prototype.invokeScript = null;

            /**
             * TransactionMetadata leaseMeta.
             * @member {vrp.events.TransactionMetadata.ILeaseMetadata|null|undefined} leaseMeta
             * @memberof vrp.events.TransactionMetadata
             * @instance
             */
            TransactionMetadata.prototype.leaseMeta = null;

            /**
             * TransactionMetadata ethereum.
             * @member {vrp.events.TransactionMetadata.IEthereumMetadata|null|undefined} ethereum
             * @memberof vrp.events.TransactionMetadata
             * @instance
             */
            TransactionMetadata.prototype.ethereum = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TransactionMetadata metadata.
             * @member {"transfer"|"exchange"|"massTransfer"|"invokeScript"|"leaseMeta"|"ethereum"|undefined} metadata
             * @memberof vrp.events.TransactionMetadata
             * @instance
             */
            Object.defineProperty(TransactionMetadata.prototype, "metadata", {
                get: $util.oneOfGetter($oneOfFields = ["transfer", "exchange", "massTransfer", "invokeScript", "leaseMeta", "ethereum"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Encodes the specified TransactionMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.verify|verify} messages.
             * @function encode
             * @memberof vrp.events.TransactionMetadata
             * @static
             * @param {vrp.events.ITransactionMetadata} m TransactionMetadata message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionMetadata.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.transfer != null && Object.hasOwnProperty.call(m, "transfer"))
                    $root.vrp.events.TransactionMetadata.TransferMetadata.encode(m.transfer, w.uint32(834).fork()).ldelim();
                if (m.exchange != null && Object.hasOwnProperty.call(m, "exchange"))
                    $root.vrp.events.TransactionMetadata.ExchangeMetadata.encode(m.exchange, w.uint32(858).fork()).ldelim();
                if (m.massTransfer != null && Object.hasOwnProperty.call(m, "massTransfer"))
                    $root.vrp.events.TransactionMetadata.MassTransferMetadata.encode(m.massTransfer, w.uint32(890).fork()).ldelim();
                if (m.invokeScript != null && Object.hasOwnProperty.call(m, "invokeScript"))
                    $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.encode(m.invokeScript, w.uint32(930).fork()).ldelim();
                if (m.leaseMeta != null && Object.hasOwnProperty.call(m, "leaseMeta"))
                    $root.vrp.events.TransactionMetadata.LeaseMetadata.encode(m.leaseMeta, w.uint32(938).fork()).ldelim();
                if (m.ethereum != null && Object.hasOwnProperty.call(m, "ethereum"))
                    $root.vrp.events.TransactionMetadata.EthereumMetadata.encode(m.ethereum, w.uint32(2410).fork()).ldelim();
                return w;
            };

            /**
             * Decodes a TransactionMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.events.TransactionMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.events.TransactionMetadata} TransactionMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionMetadata.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 104:
                        m.transfer = $root.vrp.events.TransactionMetadata.TransferMetadata.decode(r, r.uint32());
                        break;
                    case 107:
                        m.exchange = $root.vrp.events.TransactionMetadata.ExchangeMetadata.decode(r, r.uint32());
                        break;
                    case 111:
                        m.massTransfer = $root.vrp.events.TransactionMetadata.MassTransferMetadata.decode(r, r.uint32());
                        break;
                    case 116:
                        m.invokeScript = $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.decode(r, r.uint32());
                        break;
                    case 117:
                        m.leaseMeta = $root.vrp.events.TransactionMetadata.LeaseMetadata.decode(r, r.uint32());
                        break;
                    case 301:
                        m.ethereum = $root.vrp.events.TransactionMetadata.EthereumMetadata.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            TransactionMetadata.TransferMetadata = (function() {

                /**
                 * Properties of a TransferMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @interface ITransferMetadata
                 * @property {Uint8Array|null} [recipientAddress] TransferMetadata recipientAddress
                 */

                /**
                 * Constructs a new TransferMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @classdesc Represents a TransferMetadata.
                 * @implements ITransferMetadata
                 * @constructor
                 * @param {vrp.events.TransactionMetadata.ITransferMetadata=} [p] Properties to set
                 */
                function TransferMetadata(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * TransferMetadata recipientAddress.
                 * @member {Uint8Array} recipientAddress
                 * @memberof vrp.events.TransactionMetadata.TransferMetadata
                 * @instance
                 */
                TransferMetadata.prototype.recipientAddress = $util.newBuffer([]);

                /**
                 * Encodes the specified TransferMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.TransferMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.TransactionMetadata.TransferMetadata
                 * @static
                 * @param {vrp.events.TransactionMetadata.ITransferMetadata} m TransferMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransferMetadata.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.recipientAddress != null && Object.hasOwnProperty.call(m, "recipientAddress"))
                        w.uint32(10).bytes(m.recipientAddress);
                    return w;
                };

                /**
                 * Decodes a TransferMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.TransactionMetadata.TransferMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.TransactionMetadata.TransferMetadata} TransferMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransferMetadata.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.TransferMetadata();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.recipientAddress = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return TransferMetadata;
            })();

            TransactionMetadata.MassTransferMetadata = (function() {

                /**
                 * Properties of a MassTransferMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @interface IMassTransferMetadata
                 * @property {Array.<Uint8Array>|null} [recipientsAddresses] MassTransferMetadata recipientsAddresses
                 */

                /**
                 * Constructs a new MassTransferMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @classdesc Represents a MassTransferMetadata.
                 * @implements IMassTransferMetadata
                 * @constructor
                 * @param {vrp.events.TransactionMetadata.IMassTransferMetadata=} [p] Properties to set
                 */
                function MassTransferMetadata(p) {
                    this.recipientsAddresses = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * MassTransferMetadata recipientsAddresses.
                 * @member {Array.<Uint8Array>} recipientsAddresses
                 * @memberof vrp.events.TransactionMetadata.MassTransferMetadata
                 * @instance
                 */
                MassTransferMetadata.prototype.recipientsAddresses = $util.emptyArray;

                /**
                 * Encodes the specified MassTransferMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.MassTransferMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.TransactionMetadata.MassTransferMetadata
                 * @static
                 * @param {vrp.events.TransactionMetadata.IMassTransferMetadata} m MassTransferMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MassTransferMetadata.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.recipientsAddresses != null && m.recipientsAddresses.length) {
                        for (var i = 0; i < m.recipientsAddresses.length; ++i)
                            w.uint32(10).bytes(m.recipientsAddresses[i]);
                    }
                    return w;
                };

                /**
                 * Decodes a MassTransferMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.TransactionMetadata.MassTransferMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.TransactionMetadata.MassTransferMetadata} MassTransferMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MassTransferMetadata.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.MassTransferMetadata();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            if (!(m.recipientsAddresses && m.recipientsAddresses.length))
                                m.recipientsAddresses = [];
                            m.recipientsAddresses.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return MassTransferMetadata;
            })();

            TransactionMetadata.ExchangeMetadata = (function() {

                /**
                 * Properties of an ExchangeMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @interface IExchangeMetadata
                 * @property {Array.<Uint8Array>|null} [orderIds] ExchangeMetadata orderIds
                 * @property {Array.<Uint8Array>|null} [orderSenderAddresses] ExchangeMetadata orderSenderAddresses
                 * @property {Array.<Uint8Array>|null} [orderSenderPublicKeys] ExchangeMetadata orderSenderPublicKeys
                 */

                /**
                 * Constructs a new ExchangeMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @classdesc Represents an ExchangeMetadata.
                 * @implements IExchangeMetadata
                 * @constructor
                 * @param {vrp.events.TransactionMetadata.IExchangeMetadata=} [p] Properties to set
                 */
                function ExchangeMetadata(p) {
                    this.orderIds = [];
                    this.orderSenderAddresses = [];
                    this.orderSenderPublicKeys = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ExchangeMetadata orderIds.
                 * @member {Array.<Uint8Array>} orderIds
                 * @memberof vrp.events.TransactionMetadata.ExchangeMetadata
                 * @instance
                 */
                ExchangeMetadata.prototype.orderIds = $util.emptyArray;

                /**
                 * ExchangeMetadata orderSenderAddresses.
                 * @member {Array.<Uint8Array>} orderSenderAddresses
                 * @memberof vrp.events.TransactionMetadata.ExchangeMetadata
                 * @instance
                 */
                ExchangeMetadata.prototype.orderSenderAddresses = $util.emptyArray;

                /**
                 * ExchangeMetadata orderSenderPublicKeys.
                 * @member {Array.<Uint8Array>} orderSenderPublicKeys
                 * @memberof vrp.events.TransactionMetadata.ExchangeMetadata
                 * @instance
                 */
                ExchangeMetadata.prototype.orderSenderPublicKeys = $util.emptyArray;

                /**
                 * Encodes the specified ExchangeMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.ExchangeMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.TransactionMetadata.ExchangeMetadata
                 * @static
                 * @param {vrp.events.TransactionMetadata.IExchangeMetadata} m ExchangeMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExchangeMetadata.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.orderIds != null && m.orderIds.length) {
                        for (var i = 0; i < m.orderIds.length; ++i)
                            w.uint32(10).bytes(m.orderIds[i]);
                    }
                    if (m.orderSenderAddresses != null && m.orderSenderAddresses.length) {
                        for (var i = 0; i < m.orderSenderAddresses.length; ++i)
                            w.uint32(18).bytes(m.orderSenderAddresses[i]);
                    }
                    if (m.orderSenderPublicKeys != null && m.orderSenderPublicKeys.length) {
                        for (var i = 0; i < m.orderSenderPublicKeys.length; ++i)
                            w.uint32(26).bytes(m.orderSenderPublicKeys[i]);
                    }
                    return w;
                };

                /**
                 * Decodes an ExchangeMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.TransactionMetadata.ExchangeMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.TransactionMetadata.ExchangeMetadata} ExchangeMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExchangeMetadata.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.ExchangeMetadata();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            if (!(m.orderIds && m.orderIds.length))
                                m.orderIds = [];
                            m.orderIds.push(r.bytes());
                            break;
                        case 2:
                            if (!(m.orderSenderAddresses && m.orderSenderAddresses.length))
                                m.orderSenderAddresses = [];
                            m.orderSenderAddresses.push(r.bytes());
                            break;
                        case 3:
                            if (!(m.orderSenderPublicKeys && m.orderSenderPublicKeys.length))
                                m.orderSenderPublicKeys = [];
                            m.orderSenderPublicKeys.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ExchangeMetadata;
            })();

            TransactionMetadata.InvokeScriptMetadata = (function() {

                /**
                 * Properties of an InvokeScriptMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @interface IInvokeScriptMetadata
                 * @property {Uint8Array|null} [dAppAddress] InvokeScriptMetadata dAppAddress
                 * @property {string|null} [functionName] InvokeScriptMetadata functionName
                 * @property {Array.<vrp.InvokeScriptResult.Call.IArgument>|null} ["arguments"] InvokeScriptMetadata arguments
                 * @property {Array.<vrp.IAmount>|null} [payments] InvokeScriptMetadata payments
                 * @property {vrp.IInvokeScriptResult|null} [result] InvokeScriptMetadata result
                 */

                /**
                 * Constructs a new InvokeScriptMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @classdesc Represents an InvokeScriptMetadata.
                 * @implements IInvokeScriptMetadata
                 * @constructor
                 * @param {vrp.events.TransactionMetadata.IInvokeScriptMetadata=} [p] Properties to set
                 */
                function InvokeScriptMetadata(p) {
                    this["arguments"] = [];
                    this.payments = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * InvokeScriptMetadata dAppAddress.
                 * @member {Uint8Array} dAppAddress
                 * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                 * @instance
                 */
                InvokeScriptMetadata.prototype.dAppAddress = $util.newBuffer([]);

                /**
                 * InvokeScriptMetadata functionName.
                 * @member {string} functionName
                 * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                 * @instance
                 */
                InvokeScriptMetadata.prototype.functionName = "";

                /**
                 * InvokeScriptMetadata arguments.
                 * @member {Array.<vrp.InvokeScriptResult.Call.IArgument>} arguments
                 * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                 * @instance
                 */
                InvokeScriptMetadata.prototype["arguments"] = $util.emptyArray;

                /**
                 * InvokeScriptMetadata payments.
                 * @member {Array.<vrp.IAmount>} payments
                 * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                 * @instance
                 */
                InvokeScriptMetadata.prototype.payments = $util.emptyArray;

                /**
                 * InvokeScriptMetadata result.
                 * @member {vrp.IInvokeScriptResult|null|undefined} result
                 * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                 * @instance
                 */
                InvokeScriptMetadata.prototype.result = null;

                /**
                 * Encodes the specified InvokeScriptMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.InvokeScriptMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                 * @static
                 * @param {vrp.events.TransactionMetadata.IInvokeScriptMetadata} m InvokeScriptMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvokeScriptMetadata.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.dAppAddress != null && Object.hasOwnProperty.call(m, "dAppAddress"))
                        w.uint32(10).bytes(m.dAppAddress);
                    if (m.functionName != null && Object.hasOwnProperty.call(m, "functionName"))
                        w.uint32(18).string(m.functionName);
                    if (m["arguments"] != null && m["arguments"].length) {
                        for (var i = 0; i < m["arguments"].length; ++i)
                            $root.vrp.InvokeScriptResult.Call.Argument.encode(m["arguments"][i], w.uint32(26).fork()).ldelim();
                    }
                    if (m.payments != null && m.payments.length) {
                        for (var i = 0; i < m.payments.length; ++i)
                            $root.vrp.Amount.encode(m.payments[i], w.uint32(34).fork()).ldelim();
                    }
                    if (m.result != null && Object.hasOwnProperty.call(m, "result"))
                        $root.vrp.InvokeScriptResult.encode(m.result, w.uint32(42).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an InvokeScriptMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.TransactionMetadata.InvokeScriptMetadata} InvokeScriptMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvokeScriptMetadata.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.InvokeScriptMetadata();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.dAppAddress = r.bytes();
                            break;
                        case 2:
                            m.functionName = r.string();
                            break;
                        case 3:
                            if (!(m["arguments"] && m["arguments"].length))
                                m["arguments"] = [];
                            m["arguments"].push($root.vrp.InvokeScriptResult.Call.Argument.decode(r, r.uint32()));
                            break;
                        case 4:
                            if (!(m.payments && m.payments.length))
                                m.payments = [];
                            m.payments.push($root.vrp.Amount.decode(r, r.uint32()));
                            break;
                        case 5:
                            m.result = $root.vrp.InvokeScriptResult.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                InvokeScriptMetadata.Argument = (function() {

                    /**
                     * Properties of an Argument.
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                     * @interface IArgument
                     * @property {Long|null} [integerValue] Argument integerValue
                     * @property {Uint8Array|null} [binaryValue] Argument binaryValue
                     * @property {string|null} [stringValue] Argument stringValue
                     * @property {boolean|null} [booleanValue] Argument booleanValue
                     * @property {vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.IList|null} [list] Argument list
                     */

                    /**
                     * Constructs a new Argument.
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata
                     * @classdesc Represents an Argument.
                     * @implements IArgument
                     * @constructor
                     * @param {vrp.events.TransactionMetadata.InvokeScriptMetadata.IArgument=} [p] Properties to set
                     */
                    function Argument(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * Argument integerValue.
                     * @member {Long|null|undefined} integerValue
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @instance
                     */
                    Argument.prototype.integerValue = null;

                    /**
                     * Argument binaryValue.
                     * @member {Uint8Array|null|undefined} binaryValue
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @instance
                     */
                    Argument.prototype.binaryValue = null;

                    /**
                     * Argument stringValue.
                     * @member {string|null|undefined} stringValue
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @instance
                     */
                    Argument.prototype.stringValue = null;

                    /**
                     * Argument booleanValue.
                     * @member {boolean|null|undefined} booleanValue
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @instance
                     */
                    Argument.prototype.booleanValue = null;

                    /**
                     * Argument list.
                     * @member {vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.IList|null|undefined} list
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @instance
                     */
                    Argument.prototype.list = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Argument value.
                     * @member {"integerValue"|"binaryValue"|"stringValue"|"booleanValue"|"list"|undefined} value
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @instance
                     */
                    Object.defineProperty(Argument.prototype, "value", {
                        get: $util.oneOfGetter($oneOfFields = ["integerValue", "binaryValue", "stringValue", "booleanValue", "list"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Encodes the specified Argument message. Does not implicitly {@link vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.verify|verify} messages.
                     * @function encode
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @static
                     * @param {vrp.events.TransactionMetadata.InvokeScriptMetadata.IArgument} m Argument message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Argument.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.integerValue != null && Object.hasOwnProperty.call(m, "integerValue"))
                            w.uint32(8).int64(m.integerValue);
                        if (m.binaryValue != null && Object.hasOwnProperty.call(m, "binaryValue"))
                            w.uint32(18).bytes(m.binaryValue);
                        if (m.stringValue != null && Object.hasOwnProperty.call(m, "stringValue"))
                            w.uint32(26).string(m.stringValue);
                        if (m.booleanValue != null && Object.hasOwnProperty.call(m, "booleanValue"))
                            w.uint32(32).bool(m.booleanValue);
                        if (m.list != null && Object.hasOwnProperty.call(m, "list"))
                            $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.encode(m.list, w.uint32(82).fork()).ldelim();
                        return w;
                    };

                    /**
                     * Decodes an Argument message from the specified reader or buffer.
                     * @function decode
                     * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument} Argument
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Argument.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.integerValue = r.int64();
                                break;
                            case 2:
                                m.binaryValue = r.bytes();
                                break;
                            case 3:
                                m.stringValue = r.string();
                                break;
                            case 4:
                                m.booleanValue = r.bool();
                                break;
                            case 10:
                                m.list = $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    Argument.List = (function() {

                        /**
                         * Properties of a List.
                         * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                         * @interface IList
                         * @property {Array.<vrp.events.TransactionMetadata.InvokeScriptMetadata.IArgument>|null} [items] List items
                         */

                        /**
                         * Constructs a new List.
                         * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument
                         * @classdesc Represents a List.
                         * @implements IList
                         * @constructor
                         * @param {vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.IList=} [p] Properties to set
                         */
                        function List(p) {
                            this.items = [];
                            if (p)
                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                    if (p[ks[i]] != null)
                                        this[ks[i]] = p[ks[i]];
                        }

                        /**
                         * List items.
                         * @member {Array.<vrp.events.TransactionMetadata.InvokeScriptMetadata.IArgument>} items
                         * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List
                         * @instance
                         */
                        List.prototype.items = $util.emptyArray;

                        /**
                         * Encodes the specified List message. Does not implicitly {@link vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.verify|verify} messages.
                         * @function encode
                         * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List
                         * @static
                         * @param {vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.IList} m List message or plain object to encode
                         * @param {$protobuf.Writer} [w] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        List.encode = function encode(m, w) {
                            if (!w)
                                w = $Writer.create();
                            if (m.items != null && m.items.length) {
                                for (var i = 0; i < m.items.length; ++i)
                                    $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.encode(m.items[i], w.uint32(10).fork()).ldelim();
                            }
                            return w;
                        };

                        /**
                         * Decodes a List message from the specified reader or buffer.
                         * @function decode
                         * @memberof vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                         * @param {number} [l] Message length if known beforehand
                         * @returns {vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List} List
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        List.decode = function decode(r, l) {
                            if (!(r instanceof $Reader))
                                r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.List();
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                case 1:
                                    if (!(m.items && m.items.length))
                                        m.items = [];
                                    m.items.push($root.vrp.events.TransactionMetadata.InvokeScriptMetadata.Argument.decode(r, r.uint32()));
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break;
                                }
                            }
                            return m;
                        };

                        return List;
                    })();

                    return Argument;
                })();

                return InvokeScriptMetadata;
            })();

            TransactionMetadata.LeaseMetadata = (function() {

                /**
                 * Properties of a LeaseMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @interface ILeaseMetadata
                 * @property {Uint8Array|null} [recipientAddress] LeaseMetadata recipientAddress
                 */

                /**
                 * Constructs a new LeaseMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @classdesc Represents a LeaseMetadata.
                 * @implements ILeaseMetadata
                 * @constructor
                 * @param {vrp.events.TransactionMetadata.ILeaseMetadata=} [p] Properties to set
                 */
                function LeaseMetadata(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * LeaseMetadata recipientAddress.
                 * @member {Uint8Array} recipientAddress
                 * @memberof vrp.events.TransactionMetadata.LeaseMetadata
                 * @instance
                 */
                LeaseMetadata.prototype.recipientAddress = $util.newBuffer([]);

                /**
                 * Encodes the specified LeaseMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.LeaseMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.TransactionMetadata.LeaseMetadata
                 * @static
                 * @param {vrp.events.TransactionMetadata.ILeaseMetadata} m LeaseMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LeaseMetadata.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.recipientAddress != null && Object.hasOwnProperty.call(m, "recipientAddress"))
                        w.uint32(10).bytes(m.recipientAddress);
                    return w;
                };

                /**
                 * Decodes a LeaseMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.TransactionMetadata.LeaseMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.TransactionMetadata.LeaseMetadata} LeaseMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LeaseMetadata.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.LeaseMetadata();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.recipientAddress = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return LeaseMetadata;
            })();

            TransactionMetadata.EthereumTransferMetadata = (function() {

                /**
                 * Properties of an EthereumTransferMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @interface IEthereumTransferMetadata
                 * @property {Uint8Array|null} [recipientAddress] EthereumTransferMetadata recipientAddress
                 * @property {vrp.IAmount|null} [amount] EthereumTransferMetadata amount
                 */

                /**
                 * Constructs a new EthereumTransferMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @classdesc Represents an EthereumTransferMetadata.
                 * @implements IEthereumTransferMetadata
                 * @constructor
                 * @param {vrp.events.TransactionMetadata.IEthereumTransferMetadata=} [p] Properties to set
                 */
                function EthereumTransferMetadata(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * EthereumTransferMetadata recipientAddress.
                 * @member {Uint8Array} recipientAddress
                 * @memberof vrp.events.TransactionMetadata.EthereumTransferMetadata
                 * @instance
                 */
                EthereumTransferMetadata.prototype.recipientAddress = $util.newBuffer([]);

                /**
                 * EthereumTransferMetadata amount.
                 * @member {vrp.IAmount|null|undefined} amount
                 * @memberof vrp.events.TransactionMetadata.EthereumTransferMetadata
                 * @instance
                 */
                EthereumTransferMetadata.prototype.amount = null;

                /**
                 * Encodes the specified EthereumTransferMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.EthereumTransferMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.TransactionMetadata.EthereumTransferMetadata
                 * @static
                 * @param {vrp.events.TransactionMetadata.IEthereumTransferMetadata} m EthereumTransferMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EthereumTransferMetadata.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.recipientAddress != null && Object.hasOwnProperty.call(m, "recipientAddress"))
                        w.uint32(10).bytes(m.recipientAddress);
                    if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                        $root.vrp.Amount.encode(m.amount, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an EthereumTransferMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.TransactionMetadata.EthereumTransferMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.TransactionMetadata.EthereumTransferMetadata} EthereumTransferMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EthereumTransferMetadata.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.EthereumTransferMetadata();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.recipientAddress = r.bytes();
                            break;
                        case 2:
                            m.amount = $root.vrp.Amount.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return EthereumTransferMetadata;
            })();

            TransactionMetadata.EthereumMetadata = (function() {

                /**
                 * Properties of an EthereumMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @interface IEthereumMetadata
                 * @property {Long|null} [timestamp] EthereumMetadata timestamp
                 * @property {Long|null} [fee] EthereumMetadata fee
                 * @property {Uint8Array|null} [senderPublicKey] EthereumMetadata senderPublicKey
                 * @property {vrp.events.TransactionMetadata.IEthereumTransferMetadata|null} [transfer] EthereumMetadata transfer
                 * @property {vrp.events.TransactionMetadata.IInvokeScriptMetadata|null} [invoke] EthereumMetadata invoke
                 */

                /**
                 * Constructs a new EthereumMetadata.
                 * @memberof vrp.events.TransactionMetadata
                 * @classdesc Represents an EthereumMetadata.
                 * @implements IEthereumMetadata
                 * @constructor
                 * @param {vrp.events.TransactionMetadata.IEthereumMetadata=} [p] Properties to set
                 */
                function EthereumMetadata(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * EthereumMetadata timestamp.
                 * @member {Long} timestamp
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @instance
                 */
                EthereumMetadata.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * EthereumMetadata fee.
                 * @member {Long} fee
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @instance
                 */
                EthereumMetadata.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * EthereumMetadata senderPublicKey.
                 * @member {Uint8Array} senderPublicKey
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @instance
                 */
                EthereumMetadata.prototype.senderPublicKey = $util.newBuffer([]);

                /**
                 * EthereumMetadata transfer.
                 * @member {vrp.events.TransactionMetadata.IEthereumTransferMetadata|null|undefined} transfer
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @instance
                 */
                EthereumMetadata.prototype.transfer = null;

                /**
                 * EthereumMetadata invoke.
                 * @member {vrp.events.TransactionMetadata.IInvokeScriptMetadata|null|undefined} invoke
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @instance
                 */
                EthereumMetadata.prototype.invoke = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * EthereumMetadata Action.
                 * @member {"transfer"|"invoke"|undefined} Action
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @instance
                 */
                Object.defineProperty(EthereumMetadata.prototype, "Action", {
                    get: $util.oneOfGetter($oneOfFields = ["transfer", "invoke"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified EthereumMetadata message. Does not implicitly {@link vrp.events.TransactionMetadata.EthereumMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @static
                 * @param {vrp.events.TransactionMetadata.IEthereumMetadata} m EthereumMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EthereumMetadata.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.timestamp != null && Object.hasOwnProperty.call(m, "timestamp"))
                        w.uint32(16).int64(m.timestamp);
                    if (m.fee != null && Object.hasOwnProperty.call(m, "fee"))
                        w.uint32(24).int64(m.fee);
                    if (m.senderPublicKey != null && Object.hasOwnProperty.call(m, "senderPublicKey"))
                        w.uint32(34).bytes(m.senderPublicKey);
                    if (m.transfer != null && Object.hasOwnProperty.call(m, "transfer"))
                        $root.vrp.events.TransactionMetadata.EthereumTransferMetadata.encode(m.transfer, w.uint32(82).fork()).ldelim();
                    if (m.invoke != null && Object.hasOwnProperty.call(m, "invoke"))
                        $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.encode(m.invoke, w.uint32(90).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an EthereumMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.TransactionMetadata.EthereumMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.TransactionMetadata.EthereumMetadata} EthereumMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EthereumMetadata.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.TransactionMetadata.EthereumMetadata();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 2:
                            m.timestamp = r.int64();
                            break;
                        case 3:
                            m.fee = r.int64();
                            break;
                        case 4:
                            m.senderPublicKey = r.bytes();
                            break;
                        case 10:
                            m.transfer = $root.vrp.events.TransactionMetadata.EthereumTransferMetadata.decode(r, r.uint32());
                            break;
                        case 11:
                            m.invoke = $root.vrp.events.TransactionMetadata.InvokeScriptMetadata.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return EthereumMetadata;
            })();

            return TransactionMetadata;
        })();

        events.grpc = (function() {

            /**
             * Namespace grpc.
             * @memberof vrp.events
             * @namespace
             */
            const grpc = {};

            grpc.BlockchainUpdatesApi = (function() {

                /**
                 * Constructs a new BlockchainUpdatesApi service.
                 * @memberof vrp.events.grpc
                 * @classdesc Represents a BlockchainUpdatesApi
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function BlockchainUpdatesApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (BlockchainUpdatesApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BlockchainUpdatesApi;

                /**
                 * Callback as used by {@link vrp.events.grpc.BlockchainUpdatesApi#getBlockUpdate}.
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @typedef GetBlockUpdateCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.events.grpc.GetBlockUpdateResponse} [response] GetBlockUpdateResponse
                 */

                /**
                 * Calls GetBlockUpdate.
                 * @function getBlockUpdate
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @instance
                 * @param {vrp.events.grpc.IGetBlockUpdateRequest} request GetBlockUpdateRequest message or plain object
                 * @param {vrp.events.grpc.BlockchainUpdatesApi.GetBlockUpdateCallback} callback Node-style callback called with the error, if any, and GetBlockUpdateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlockchainUpdatesApi.prototype.getBlockUpdate = function getBlockUpdate(request, callback) {
                    return this.rpcCall(getBlockUpdate, $root.vrp.events.grpc.GetBlockUpdateRequest, $root.vrp.events.grpc.GetBlockUpdateResponse, request, callback);
                }, "name", { value: "GetBlockUpdate" });

                /**
                 * Calls GetBlockUpdate.
                 * @function getBlockUpdate
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @instance
                 * @param {vrp.events.grpc.IGetBlockUpdateRequest} request GetBlockUpdateRequest message or plain object
                 * @returns {Promise<vrp.events.grpc.GetBlockUpdateResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.events.grpc.BlockchainUpdatesApi#getBlockUpdatesRange}.
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @typedef GetBlockUpdatesRangeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.events.grpc.GetBlockUpdatesRangeResponse} [response] GetBlockUpdatesRangeResponse
                 */

                /**
                 * Calls GetBlockUpdatesRange.
                 * @function getBlockUpdatesRange
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @instance
                 * @param {vrp.events.grpc.IGetBlockUpdatesRangeRequest} request GetBlockUpdatesRangeRequest message or plain object
                 * @param {vrp.events.grpc.BlockchainUpdatesApi.GetBlockUpdatesRangeCallback} callback Node-style callback called with the error, if any, and GetBlockUpdatesRangeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlockchainUpdatesApi.prototype.getBlockUpdatesRange = function getBlockUpdatesRange(request, callback) {
                    return this.rpcCall(getBlockUpdatesRange, $root.vrp.events.grpc.GetBlockUpdatesRangeRequest, $root.vrp.events.grpc.GetBlockUpdatesRangeResponse, request, callback);
                }, "name", { value: "GetBlockUpdatesRange" });

                /**
                 * Calls GetBlockUpdatesRange.
                 * @function getBlockUpdatesRange
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @instance
                 * @param {vrp.events.grpc.IGetBlockUpdatesRangeRequest} request GetBlockUpdatesRangeRequest message or plain object
                 * @returns {Promise<vrp.events.grpc.GetBlockUpdatesRangeResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.events.grpc.BlockchainUpdatesApi#subscribe}.
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @typedef SubscribeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.events.grpc.SubscribeEvent} [response] SubscribeEvent
                 */

                /**
                 * Calls Subscribe.
                 * @function subscribe
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @instance
                 * @param {vrp.events.grpc.ISubscribeRequest} request SubscribeRequest message or plain object
                 * @param {vrp.events.grpc.BlockchainUpdatesApi.SubscribeCallback} callback Node-style callback called with the error, if any, and SubscribeEvent
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlockchainUpdatesApi.prototype.subscribe = function subscribe(request, callback) {
                    return this.rpcCall(subscribe, $root.vrp.events.grpc.SubscribeRequest, $root.vrp.events.grpc.SubscribeEvent, request, callback);
                }, "name", { value: "Subscribe" });

                /**
                 * Calls Subscribe.
                 * @function subscribe
                 * @memberof vrp.events.grpc.BlockchainUpdatesApi
                 * @instance
                 * @param {vrp.events.grpc.ISubscribeRequest} request SubscribeRequest message or plain object
                 * @returns {Promise<vrp.events.grpc.SubscribeEvent>} Promise
                 * @variation 2
                 */

                return BlockchainUpdatesApi;
            })();

            grpc.GetBlockUpdateRequest = (function() {

                /**
                 * Properties of a GetBlockUpdateRequest.
                 * @memberof vrp.events.grpc
                 * @interface IGetBlockUpdateRequest
                 * @property {number|null} [height] GetBlockUpdateRequest height
                 */

                /**
                 * Constructs a new GetBlockUpdateRequest.
                 * @memberof vrp.events.grpc
                 * @classdesc Represents a GetBlockUpdateRequest.
                 * @implements IGetBlockUpdateRequest
                 * @constructor
                 * @param {vrp.events.grpc.IGetBlockUpdateRequest=} [p] Properties to set
                 */
                function GetBlockUpdateRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * GetBlockUpdateRequest height.
                 * @member {number} height
                 * @memberof vrp.events.grpc.GetBlockUpdateRequest
                 * @instance
                 */
                GetBlockUpdateRequest.prototype.height = 0;

                /**
                 * Encodes the specified GetBlockUpdateRequest message. Does not implicitly {@link vrp.events.grpc.GetBlockUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.grpc.GetBlockUpdateRequest
                 * @static
                 * @param {vrp.events.grpc.IGetBlockUpdateRequest} m GetBlockUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlockUpdateRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(8).int32(m.height);
                    return w;
                };

                /**
                 * Decodes a GetBlockUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.grpc.GetBlockUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.grpc.GetBlockUpdateRequest} GetBlockUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlockUpdateRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.grpc.GetBlockUpdateRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.height = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdateRequest;
            })();

            grpc.GetBlockUpdateResponse = (function() {

                /**
                 * Properties of a GetBlockUpdateResponse.
                 * @memberof vrp.events.grpc
                 * @interface IGetBlockUpdateResponse
                 * @property {vrp.events.IBlockchainUpdated|null} [update] GetBlockUpdateResponse update
                 */

                /**
                 * Constructs a new GetBlockUpdateResponse.
                 * @memberof vrp.events.grpc
                 * @classdesc Represents a GetBlockUpdateResponse.
                 * @implements IGetBlockUpdateResponse
                 * @constructor
                 * @param {vrp.events.grpc.IGetBlockUpdateResponse=} [p] Properties to set
                 */
                function GetBlockUpdateResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * GetBlockUpdateResponse update.
                 * @member {vrp.events.IBlockchainUpdated|null|undefined} update
                 * @memberof vrp.events.grpc.GetBlockUpdateResponse
                 * @instance
                 */
                GetBlockUpdateResponse.prototype.update = null;

                /**
                 * Encodes the specified GetBlockUpdateResponse message. Does not implicitly {@link vrp.events.grpc.GetBlockUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.grpc.GetBlockUpdateResponse
                 * @static
                 * @param {vrp.events.grpc.IGetBlockUpdateResponse} m GetBlockUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlockUpdateResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.update != null && Object.hasOwnProperty.call(m, "update"))
                        $root.vrp.events.BlockchainUpdated.encode(m.update, w.uint32(10).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a GetBlockUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.grpc.GetBlockUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.grpc.GetBlockUpdateResponse} GetBlockUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlockUpdateResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.grpc.GetBlockUpdateResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.update = $root.vrp.events.BlockchainUpdated.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdateResponse;
            })();

            grpc.GetBlockUpdatesRangeRequest = (function() {

                /**
                 * Properties of a GetBlockUpdatesRangeRequest.
                 * @memberof vrp.events.grpc
                 * @interface IGetBlockUpdatesRangeRequest
                 * @property {number|null} [fromHeight] GetBlockUpdatesRangeRequest fromHeight
                 * @property {number|null} [toHeight] GetBlockUpdatesRangeRequest toHeight
                 */

                /**
                 * Constructs a new GetBlockUpdatesRangeRequest.
                 * @memberof vrp.events.grpc
                 * @classdesc Represents a GetBlockUpdatesRangeRequest.
                 * @implements IGetBlockUpdatesRangeRequest
                 * @constructor
                 * @param {vrp.events.grpc.IGetBlockUpdatesRangeRequest=} [p] Properties to set
                 */
                function GetBlockUpdatesRangeRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * GetBlockUpdatesRangeRequest fromHeight.
                 * @member {number} fromHeight
                 * @memberof vrp.events.grpc.GetBlockUpdatesRangeRequest
                 * @instance
                 */
                GetBlockUpdatesRangeRequest.prototype.fromHeight = 0;

                /**
                 * GetBlockUpdatesRangeRequest toHeight.
                 * @member {number} toHeight
                 * @memberof vrp.events.grpc.GetBlockUpdatesRangeRequest
                 * @instance
                 */
                GetBlockUpdatesRangeRequest.prototype.toHeight = 0;

                /**
                 * Encodes the specified GetBlockUpdatesRangeRequest message. Does not implicitly {@link vrp.events.grpc.GetBlockUpdatesRangeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.grpc.GetBlockUpdatesRangeRequest
                 * @static
                 * @param {vrp.events.grpc.IGetBlockUpdatesRangeRequest} m GetBlockUpdatesRangeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlockUpdatesRangeRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.fromHeight != null && Object.hasOwnProperty.call(m, "fromHeight"))
                        w.uint32(8).int32(m.fromHeight);
                    if (m.toHeight != null && Object.hasOwnProperty.call(m, "toHeight"))
                        w.uint32(16).int32(m.toHeight);
                    return w;
                };

                /**
                 * Decodes a GetBlockUpdatesRangeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.grpc.GetBlockUpdatesRangeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.grpc.GetBlockUpdatesRangeRequest} GetBlockUpdatesRangeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlockUpdatesRangeRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.grpc.GetBlockUpdatesRangeRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.fromHeight = r.int32();
                            break;
                        case 2:
                            m.toHeight = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdatesRangeRequest;
            })();

            grpc.GetBlockUpdatesRangeResponse = (function() {

                /**
                 * Properties of a GetBlockUpdatesRangeResponse.
                 * @memberof vrp.events.grpc
                 * @interface IGetBlockUpdatesRangeResponse
                 * @property {Array.<vrp.events.IBlockchainUpdated>|null} [updates] GetBlockUpdatesRangeResponse updates
                 */

                /**
                 * Constructs a new GetBlockUpdatesRangeResponse.
                 * @memberof vrp.events.grpc
                 * @classdesc Represents a GetBlockUpdatesRangeResponse.
                 * @implements IGetBlockUpdatesRangeResponse
                 * @constructor
                 * @param {vrp.events.grpc.IGetBlockUpdatesRangeResponse=} [p] Properties to set
                 */
                function GetBlockUpdatesRangeResponse(p) {
                    this.updates = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * GetBlockUpdatesRangeResponse updates.
                 * @member {Array.<vrp.events.IBlockchainUpdated>} updates
                 * @memberof vrp.events.grpc.GetBlockUpdatesRangeResponse
                 * @instance
                 */
                GetBlockUpdatesRangeResponse.prototype.updates = $util.emptyArray;

                /**
                 * Encodes the specified GetBlockUpdatesRangeResponse message. Does not implicitly {@link vrp.events.grpc.GetBlockUpdatesRangeResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.grpc.GetBlockUpdatesRangeResponse
                 * @static
                 * @param {vrp.events.grpc.IGetBlockUpdatesRangeResponse} m GetBlockUpdatesRangeResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlockUpdatesRangeResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.updates != null && m.updates.length) {
                        for (var i = 0; i < m.updates.length; ++i)
                            $root.vrp.events.BlockchainUpdated.encode(m.updates[i], w.uint32(10).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes a GetBlockUpdatesRangeResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.grpc.GetBlockUpdatesRangeResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.grpc.GetBlockUpdatesRangeResponse} GetBlockUpdatesRangeResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlockUpdatesRangeResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.grpc.GetBlockUpdatesRangeResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            if (!(m.updates && m.updates.length))
                                m.updates = [];
                            m.updates.push($root.vrp.events.BlockchainUpdated.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return GetBlockUpdatesRangeResponse;
            })();

            grpc.SubscribeRequest = (function() {

                /**
                 * Properties of a SubscribeRequest.
                 * @memberof vrp.events.grpc
                 * @interface ISubscribeRequest
                 * @property {number|null} [fromHeight] SubscribeRequest fromHeight
                 * @property {number|null} [toHeight] SubscribeRequest toHeight
                 */

                /**
                 * Constructs a new SubscribeRequest.
                 * @memberof vrp.events.grpc
                 * @classdesc Represents a SubscribeRequest.
                 * @implements ISubscribeRequest
                 * @constructor
                 * @param {vrp.events.grpc.ISubscribeRequest=} [p] Properties to set
                 */
                function SubscribeRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * SubscribeRequest fromHeight.
                 * @member {number} fromHeight
                 * @memberof vrp.events.grpc.SubscribeRequest
                 * @instance
                 */
                SubscribeRequest.prototype.fromHeight = 0;

                /**
                 * SubscribeRequest toHeight.
                 * @member {number} toHeight
                 * @memberof vrp.events.grpc.SubscribeRequest
                 * @instance
                 */
                SubscribeRequest.prototype.toHeight = 0;

                /**
                 * Encodes the specified SubscribeRequest message. Does not implicitly {@link vrp.events.grpc.SubscribeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.grpc.SubscribeRequest
                 * @static
                 * @param {vrp.events.grpc.ISubscribeRequest} m SubscribeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscribeRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.fromHeight != null && Object.hasOwnProperty.call(m, "fromHeight"))
                        w.uint32(8).int32(m.fromHeight);
                    if (m.toHeight != null && Object.hasOwnProperty.call(m, "toHeight"))
                        w.uint32(16).int32(m.toHeight);
                    return w;
                };

                /**
                 * Decodes a SubscribeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.grpc.SubscribeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.grpc.SubscribeRequest} SubscribeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscribeRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.grpc.SubscribeRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.fromHeight = r.int32();
                            break;
                        case 2:
                            m.toHeight = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return SubscribeRequest;
            })();

            grpc.SubscribeEvent = (function() {

                /**
                 * Properties of a SubscribeEvent.
                 * @memberof vrp.events.grpc
                 * @interface ISubscribeEvent
                 * @property {vrp.events.IBlockchainUpdated|null} [update] SubscribeEvent update
                 */

                /**
                 * Constructs a new SubscribeEvent.
                 * @memberof vrp.events.grpc
                 * @classdesc Represents a SubscribeEvent.
                 * @implements ISubscribeEvent
                 * @constructor
                 * @param {vrp.events.grpc.ISubscribeEvent=} [p] Properties to set
                 */
                function SubscribeEvent(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * SubscribeEvent update.
                 * @member {vrp.events.IBlockchainUpdated|null|undefined} update
                 * @memberof vrp.events.grpc.SubscribeEvent
                 * @instance
                 */
                SubscribeEvent.prototype.update = null;

                /**
                 * Encodes the specified SubscribeEvent message. Does not implicitly {@link vrp.events.grpc.SubscribeEvent.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.events.grpc.SubscribeEvent
                 * @static
                 * @param {vrp.events.grpc.ISubscribeEvent} m SubscribeEvent message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscribeEvent.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.update != null && Object.hasOwnProperty.call(m, "update"))
                        $root.vrp.events.BlockchainUpdated.encode(m.update, w.uint32(10).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a SubscribeEvent message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.events.grpc.SubscribeEvent
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.events.grpc.SubscribeEvent} SubscribeEvent
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscribeEvent.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.events.grpc.SubscribeEvent();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.update = $root.vrp.events.BlockchainUpdated.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return SubscribeEvent;
            })();

            return grpc;
        })();

        return events;
    })();

    vrp.InvokeScriptResult = (function() {

        /**
         * Properties of an InvokeScriptResult.
         * @memberof vrp
         * @interface IInvokeScriptResult
         * @property {Array.<vrp.DataTransactionData.IDataEntry>|null} [data] InvokeScriptResult data
         * @property {Array.<vrp.InvokeScriptResult.IPayment>|null} [transfers] InvokeScriptResult transfers
         * @property {Array.<vrp.InvokeScriptResult.IIssue>|null} [issues] InvokeScriptResult issues
         * @property {Array.<vrp.InvokeScriptResult.IReissue>|null} [reissues] InvokeScriptResult reissues
         * @property {Array.<vrp.InvokeScriptResult.IBurn>|null} [burns] InvokeScriptResult burns
         * @property {vrp.InvokeScriptResult.IErrorMessage|null} [errorMessage] InvokeScriptResult errorMessage
         * @property {Array.<vrp.InvokeScriptResult.ISponsorFee>|null} [sponsorFees] InvokeScriptResult sponsorFees
         * @property {Array.<vrp.InvokeScriptResult.ILease>|null} [leases] InvokeScriptResult leases
         * @property {Array.<vrp.InvokeScriptResult.ILeaseCancel>|null} [leaseCancels] InvokeScriptResult leaseCancels
         * @property {Array.<vrp.InvokeScriptResult.IInvocation>|null} [invokes] InvokeScriptResult invokes
         * @property {Array.<vrp.InvokeScriptResult.IPrivatePayment>|null} [privatePayment] InvokeScriptResult privatePayment
         */

        /**
         * Constructs a new InvokeScriptResult.
         * @memberof vrp
         * @classdesc Represents an InvokeScriptResult.
         * @implements IInvokeScriptResult
         * @constructor
         * @param {vrp.IInvokeScriptResult=} [p] Properties to set
         */
        function InvokeScriptResult(p) {
            this.data = [];
            this.transfers = [];
            this.issues = [];
            this.reissues = [];
            this.burns = [];
            this.sponsorFees = [];
            this.leases = [];
            this.leaseCancels = [];
            this.invokes = [];
            this.privatePayment = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * InvokeScriptResult data.
         * @member {Array.<vrp.DataTransactionData.IDataEntry>} data
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.data = $util.emptyArray;

        /**
         * InvokeScriptResult transfers.
         * @member {Array.<vrp.InvokeScriptResult.IPayment>} transfers
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.transfers = $util.emptyArray;

        /**
         * InvokeScriptResult issues.
         * @member {Array.<vrp.InvokeScriptResult.IIssue>} issues
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.issues = $util.emptyArray;

        /**
         * InvokeScriptResult reissues.
         * @member {Array.<vrp.InvokeScriptResult.IReissue>} reissues
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.reissues = $util.emptyArray;

        /**
         * InvokeScriptResult burns.
         * @member {Array.<vrp.InvokeScriptResult.IBurn>} burns
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.burns = $util.emptyArray;

        /**
         * InvokeScriptResult errorMessage.
         * @member {vrp.InvokeScriptResult.IErrorMessage|null|undefined} errorMessage
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.errorMessage = null;

        /**
         * InvokeScriptResult sponsorFees.
         * @member {Array.<vrp.InvokeScriptResult.ISponsorFee>} sponsorFees
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.sponsorFees = $util.emptyArray;

        /**
         * InvokeScriptResult leases.
         * @member {Array.<vrp.InvokeScriptResult.ILease>} leases
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.leases = $util.emptyArray;

        /**
         * InvokeScriptResult leaseCancels.
         * @member {Array.<vrp.InvokeScriptResult.ILeaseCancel>} leaseCancels
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.leaseCancels = $util.emptyArray;

        /**
         * InvokeScriptResult invokes.
         * @member {Array.<vrp.InvokeScriptResult.IInvocation>} invokes
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.invokes = $util.emptyArray;

        /**
         * InvokeScriptResult privatePayment.
         * @member {Array.<vrp.InvokeScriptResult.IPrivatePayment>} privatePayment
         * @memberof vrp.InvokeScriptResult
         * @instance
         */
        InvokeScriptResult.prototype.privatePayment = $util.emptyArray;

        /**
         * Encodes the specified InvokeScriptResult message. Does not implicitly {@link vrp.InvokeScriptResult.verify|verify} messages.
         * @function encode
         * @memberof vrp.InvokeScriptResult
         * @static
         * @param {vrp.IInvokeScriptResult} m InvokeScriptResult message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvokeScriptResult.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.data != null && m.data.length) {
                for (var i = 0; i < m.data.length; ++i)
                    $root.vrp.DataTransactionData.DataEntry.encode(m.data[i], w.uint32(10).fork()).ldelim();
            }
            if (m.transfers != null && m.transfers.length) {
                for (var i = 0; i < m.transfers.length; ++i)
                    $root.vrp.InvokeScriptResult.Payment.encode(m.transfers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.issues != null && m.issues.length) {
                for (var i = 0; i < m.issues.length; ++i)
                    $root.vrp.InvokeScriptResult.Issue.encode(m.issues[i], w.uint32(26).fork()).ldelim();
            }
            if (m.reissues != null && m.reissues.length) {
                for (var i = 0; i < m.reissues.length; ++i)
                    $root.vrp.InvokeScriptResult.Reissue.encode(m.reissues[i], w.uint32(34).fork()).ldelim();
            }
            if (m.burns != null && m.burns.length) {
                for (var i = 0; i < m.burns.length; ++i)
                    $root.vrp.InvokeScriptResult.Burn.encode(m.burns[i], w.uint32(42).fork()).ldelim();
            }
            if (m.errorMessage != null && Object.hasOwnProperty.call(m, "errorMessage"))
                $root.vrp.InvokeScriptResult.ErrorMessage.encode(m.errorMessage, w.uint32(50).fork()).ldelim();
            if (m.sponsorFees != null && m.sponsorFees.length) {
                for (var i = 0; i < m.sponsorFees.length; ++i)
                    $root.vrp.InvokeScriptResult.SponsorFee.encode(m.sponsorFees[i], w.uint32(58).fork()).ldelim();
            }
            if (m.leases != null && m.leases.length) {
                for (var i = 0; i < m.leases.length; ++i)
                    $root.vrp.InvokeScriptResult.Lease.encode(m.leases[i], w.uint32(66).fork()).ldelim();
            }
            if (m.leaseCancels != null && m.leaseCancels.length) {
                for (var i = 0; i < m.leaseCancels.length; ++i)
                    $root.vrp.InvokeScriptResult.LeaseCancel.encode(m.leaseCancels[i], w.uint32(74).fork()).ldelim();
            }
            if (m.invokes != null && m.invokes.length) {
                for (var i = 0; i < m.invokes.length; ++i)
                    $root.vrp.InvokeScriptResult.Invocation.encode(m.invokes[i], w.uint32(82).fork()).ldelim();
            }
            if (m.privatePayment != null && m.privatePayment.length) {
                for (var i = 0; i < m.privatePayment.length; ++i)
                    $root.vrp.InvokeScriptResult.PrivatePayment.encode(m.privatePayment[i], w.uint32(90).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an InvokeScriptResult message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.InvokeScriptResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.InvokeScriptResult} InvokeScriptResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvokeScriptResult.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.data && m.data.length))
                        m.data = [];
                    m.data.push($root.vrp.DataTransactionData.DataEntry.decode(r, r.uint32()));
                    break;
                case 2:
                    if (!(m.transfers && m.transfers.length))
                        m.transfers = [];
                    m.transfers.push($root.vrp.InvokeScriptResult.Payment.decode(r, r.uint32()));
                    break;
                case 3:
                    if (!(m.issues && m.issues.length))
                        m.issues = [];
                    m.issues.push($root.vrp.InvokeScriptResult.Issue.decode(r, r.uint32()));
                    break;
                case 4:
                    if (!(m.reissues && m.reissues.length))
                        m.reissues = [];
                    m.reissues.push($root.vrp.InvokeScriptResult.Reissue.decode(r, r.uint32()));
                    break;
                case 5:
                    if (!(m.burns && m.burns.length))
                        m.burns = [];
                    m.burns.push($root.vrp.InvokeScriptResult.Burn.decode(r, r.uint32()));
                    break;
                case 6:
                    m.errorMessage = $root.vrp.InvokeScriptResult.ErrorMessage.decode(r, r.uint32());
                    break;
                case 7:
                    if (!(m.sponsorFees && m.sponsorFees.length))
                        m.sponsorFees = [];
                    m.sponsorFees.push($root.vrp.InvokeScriptResult.SponsorFee.decode(r, r.uint32()));
                    break;
                case 8:
                    if (!(m.leases && m.leases.length))
                        m.leases = [];
                    m.leases.push($root.vrp.InvokeScriptResult.Lease.decode(r, r.uint32()));
                    break;
                case 9:
                    if (!(m.leaseCancels && m.leaseCancels.length))
                        m.leaseCancels = [];
                    m.leaseCancels.push($root.vrp.InvokeScriptResult.LeaseCancel.decode(r, r.uint32()));
                    break;
                case 10:
                    if (!(m.invokes && m.invokes.length))
                        m.invokes = [];
                    m.invokes.push($root.vrp.InvokeScriptResult.Invocation.decode(r, r.uint32()));
                    break;
                case 11:
                    if (!(m.privatePayment && m.privatePayment.length))
                        m.privatePayment = [];
                    m.privatePayment.push($root.vrp.InvokeScriptResult.PrivatePayment.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        InvokeScriptResult.Payment = (function() {

            /**
             * Properties of a Payment.
             * @memberof vrp.InvokeScriptResult
             * @interface IPayment
             * @property {Uint8Array|null} [address] Payment address
             * @property {vrp.IAmount|null} [amount] Payment amount
             */

            /**
             * Constructs a new Payment.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a Payment.
             * @implements IPayment
             * @constructor
             * @param {vrp.InvokeScriptResult.IPayment=} [p] Properties to set
             */
            function Payment(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Payment address.
             * @member {Uint8Array} address
             * @memberof vrp.InvokeScriptResult.Payment
             * @instance
             */
            Payment.prototype.address = $util.newBuffer([]);

            /**
             * Payment amount.
             * @member {vrp.IAmount|null|undefined} amount
             * @memberof vrp.InvokeScriptResult.Payment
             * @instance
             */
            Payment.prototype.amount = null;

            /**
             * Encodes the specified Payment message. Does not implicitly {@link vrp.InvokeScriptResult.Payment.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.Payment
             * @static
             * @param {vrp.InvokeScriptResult.IPayment} m Payment message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payment.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                    w.uint32(10).bytes(m.address);
                if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                    $root.vrp.Amount.encode(m.amount, w.uint32(18).fork()).ldelim();
                return w;
            };

            /**
             * Decodes a Payment message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.Payment
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.Payment} Payment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payment.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Payment();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.address = r.bytes();
                        break;
                    case 2:
                        m.amount = $root.vrp.Amount.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Payment;
        })();

        InvokeScriptResult.PrivatePayment = (function() {

            /**
             * Properties of a PrivatePayment.
             * @memberof vrp.InvokeScriptResult
             * @interface IPrivatePayment
             * @property {Uint8Array|null} [address] PrivatePayment address
             * @property {vrp.IAmount|null} [amount] PrivatePayment amount
             */

            /**
             * Constructs a new PrivatePayment.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a PrivatePayment.
             * @implements IPrivatePayment
             * @constructor
             * @param {vrp.InvokeScriptResult.IPrivatePayment=} [p] Properties to set
             */
            function PrivatePayment(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * PrivatePayment address.
             * @member {Uint8Array} address
             * @memberof vrp.InvokeScriptResult.PrivatePayment
             * @instance
             */
            PrivatePayment.prototype.address = $util.newBuffer([]);

            /**
             * PrivatePayment amount.
             * @member {vrp.IAmount|null|undefined} amount
             * @memberof vrp.InvokeScriptResult.PrivatePayment
             * @instance
             */
            PrivatePayment.prototype.amount = null;

            /**
             * Encodes the specified PrivatePayment message. Does not implicitly {@link vrp.InvokeScriptResult.PrivatePayment.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.PrivatePayment
             * @static
             * @param {vrp.InvokeScriptResult.IPrivatePayment} m PrivatePayment message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivatePayment.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                    w.uint32(10).bytes(m.address);
                if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                    $root.vrp.Amount.encode(m.amount, w.uint32(18).fork()).ldelim();
                return w;
            };

            /**
             * Decodes a PrivatePayment message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.PrivatePayment
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.PrivatePayment} PrivatePayment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivatePayment.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.PrivatePayment();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.address = r.bytes();
                        break;
                    case 2:
                        m.amount = $root.vrp.Amount.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return PrivatePayment;
        })();

        InvokeScriptResult.Issue = (function() {

            /**
             * Properties of an Issue.
             * @memberof vrp.InvokeScriptResult
             * @interface IIssue
             * @property {Uint8Array|null} [assetId] Issue assetId
             * @property {string|null} [name] Issue name
             * @property {string|null} [description] Issue description
             * @property {string|null} [image] Issue image
             * @property {Long|null} [amount] Issue amount
             * @property {number|null} [decimals] Issue decimals
             * @property {boolean|null} [reissuable] Issue reissuable
             * @property {Uint8Array|null} [script] Issue script
             * @property {Long|null} [nonce] Issue nonce
             */

            /**
             * Constructs a new Issue.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents an Issue.
             * @implements IIssue
             * @constructor
             * @param {vrp.InvokeScriptResult.IIssue=} [p] Properties to set
             */
            function Issue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Issue assetId.
             * @member {Uint8Array} assetId
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.assetId = $util.newBuffer([]);

            /**
             * Issue name.
             * @member {string} name
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.name = "";

            /**
             * Issue description.
             * @member {string} description
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.description = "";

            /**
             * Issue image.
             * @member {string} image
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.image = "";

            /**
             * Issue amount.
             * @member {Long} amount
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Issue decimals.
             * @member {number} decimals
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.decimals = 0;

            /**
             * Issue reissuable.
             * @member {boolean} reissuable
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.reissuable = false;

            /**
             * Issue script.
             * @member {Uint8Array} script
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.script = $util.newBuffer([]);

            /**
             * Issue nonce.
             * @member {Long} nonce
             * @memberof vrp.InvokeScriptResult.Issue
             * @instance
             */
            Issue.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Encodes the specified Issue message. Does not implicitly {@link vrp.InvokeScriptResult.Issue.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.Issue
             * @static
             * @param {vrp.InvokeScriptResult.IIssue} m Issue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Issue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                    w.uint32(10).bytes(m.assetId);
                if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                    w.uint32(18).string(m.name);
                if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                    w.uint32(26).string(m.description);
                if (m.image != null && Object.hasOwnProperty.call(m, "image"))
                    w.uint32(34).string(m.image);
                if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                    w.uint32(40).int64(m.amount);
                if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                    w.uint32(48).int32(m.decimals);
                if (m.reissuable != null && Object.hasOwnProperty.call(m, "reissuable"))
                    w.uint32(56).bool(m.reissuable);
                if (m.script != null && Object.hasOwnProperty.call(m, "script"))
                    w.uint32(66).bytes(m.script);
                if (m.nonce != null && Object.hasOwnProperty.call(m, "nonce"))
                    w.uint32(72).int64(m.nonce);
                return w;
            };

            /**
             * Decodes an Issue message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.Issue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.Issue} Issue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Issue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Issue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.assetId = r.bytes();
                        break;
                    case 2:
                        m.name = r.string();
                        break;
                    case 3:
                        m.description = r.string();
                        break;
                    case 4:
                        m.image = r.string();
                        break;
                    case 5:
                        m.amount = r.int64();
                        break;
                    case 6:
                        m.decimals = r.int32();
                        break;
                    case 7:
                        m.reissuable = r.bool();
                        break;
                    case 8:
                        m.script = r.bytes();
                        break;
                    case 9:
                        m.nonce = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Issue;
        })();

        InvokeScriptResult.Reissue = (function() {

            /**
             * Properties of a Reissue.
             * @memberof vrp.InvokeScriptResult
             * @interface IReissue
             * @property {Uint8Array|null} [assetId] Reissue assetId
             * @property {Long|null} [amount] Reissue amount
             * @property {boolean|null} [isReissuable] Reissue isReissuable
             */

            /**
             * Constructs a new Reissue.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a Reissue.
             * @implements IReissue
             * @constructor
             * @param {vrp.InvokeScriptResult.IReissue=} [p] Properties to set
             */
            function Reissue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Reissue assetId.
             * @member {Uint8Array} assetId
             * @memberof vrp.InvokeScriptResult.Reissue
             * @instance
             */
            Reissue.prototype.assetId = $util.newBuffer([]);

            /**
             * Reissue amount.
             * @member {Long} amount
             * @memberof vrp.InvokeScriptResult.Reissue
             * @instance
             */
            Reissue.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Reissue isReissuable.
             * @member {boolean} isReissuable
             * @memberof vrp.InvokeScriptResult.Reissue
             * @instance
             */
            Reissue.prototype.isReissuable = false;

            /**
             * Encodes the specified Reissue message. Does not implicitly {@link vrp.InvokeScriptResult.Reissue.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.Reissue
             * @static
             * @param {vrp.InvokeScriptResult.IReissue} m Reissue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Reissue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                    w.uint32(10).bytes(m.assetId);
                if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                    w.uint32(16).int64(m.amount);
                if (m.isReissuable != null && Object.hasOwnProperty.call(m, "isReissuable"))
                    w.uint32(24).bool(m.isReissuable);
                return w;
            };

            /**
             * Decodes a Reissue message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.Reissue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.Reissue} Reissue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Reissue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Reissue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.assetId = r.bytes();
                        break;
                    case 2:
                        m.amount = r.int64();
                        break;
                    case 3:
                        m.isReissuable = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Reissue;
        })();

        InvokeScriptResult.Burn = (function() {

            /**
             * Properties of a Burn.
             * @memberof vrp.InvokeScriptResult
             * @interface IBurn
             * @property {Uint8Array|null} [assetId] Burn assetId
             * @property {Long|null} [amount] Burn amount
             */

            /**
             * Constructs a new Burn.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a Burn.
             * @implements IBurn
             * @constructor
             * @param {vrp.InvokeScriptResult.IBurn=} [p] Properties to set
             */
            function Burn(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Burn assetId.
             * @member {Uint8Array} assetId
             * @memberof vrp.InvokeScriptResult.Burn
             * @instance
             */
            Burn.prototype.assetId = $util.newBuffer([]);

            /**
             * Burn amount.
             * @member {Long} amount
             * @memberof vrp.InvokeScriptResult.Burn
             * @instance
             */
            Burn.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Encodes the specified Burn message. Does not implicitly {@link vrp.InvokeScriptResult.Burn.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.Burn
             * @static
             * @param {vrp.InvokeScriptResult.IBurn} m Burn message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Burn.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                    w.uint32(10).bytes(m.assetId);
                if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                    w.uint32(16).int64(m.amount);
                return w;
            };

            /**
             * Decodes a Burn message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.Burn
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.Burn} Burn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Burn.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Burn();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.assetId = r.bytes();
                        break;
                    case 2:
                        m.amount = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Burn;
        })();

        InvokeScriptResult.SponsorFee = (function() {

            /**
             * Properties of a SponsorFee.
             * @memberof vrp.InvokeScriptResult
             * @interface ISponsorFee
             * @property {vrp.IAmount|null} [minFee] SponsorFee minFee
             */

            /**
             * Constructs a new SponsorFee.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a SponsorFee.
             * @implements ISponsorFee
             * @constructor
             * @param {vrp.InvokeScriptResult.ISponsorFee=} [p] Properties to set
             */
            function SponsorFee(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * SponsorFee minFee.
             * @member {vrp.IAmount|null|undefined} minFee
             * @memberof vrp.InvokeScriptResult.SponsorFee
             * @instance
             */
            SponsorFee.prototype.minFee = null;

            /**
             * Encodes the specified SponsorFee message. Does not implicitly {@link vrp.InvokeScriptResult.SponsorFee.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.SponsorFee
             * @static
             * @param {vrp.InvokeScriptResult.ISponsorFee} m SponsorFee message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SponsorFee.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.minFee != null && Object.hasOwnProperty.call(m, "minFee"))
                    $root.vrp.Amount.encode(m.minFee, w.uint32(10).fork()).ldelim();
                return w;
            };

            /**
             * Decodes a SponsorFee message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.SponsorFee
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.SponsorFee} SponsorFee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SponsorFee.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.SponsorFee();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.minFee = $root.vrp.Amount.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return SponsorFee;
        })();

        InvokeScriptResult.Lease = (function() {

            /**
             * Properties of a Lease.
             * @memberof vrp.InvokeScriptResult
             * @interface ILease
             * @property {vrp.IRecipient|null} [recipient] Lease recipient
             * @property {Long|null} [amount] Lease amount
             * @property {Long|null} [nonce] Lease nonce
             * @property {Uint8Array|null} [leaseId] Lease leaseId
             */

            /**
             * Constructs a new Lease.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a Lease.
             * @implements ILease
             * @constructor
             * @param {vrp.InvokeScriptResult.ILease=} [p] Properties to set
             */
            function Lease(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Lease recipient.
             * @member {vrp.IRecipient|null|undefined} recipient
             * @memberof vrp.InvokeScriptResult.Lease
             * @instance
             */
            Lease.prototype.recipient = null;

            /**
             * Lease amount.
             * @member {Long} amount
             * @memberof vrp.InvokeScriptResult.Lease
             * @instance
             */
            Lease.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Lease nonce.
             * @member {Long} nonce
             * @memberof vrp.InvokeScriptResult.Lease
             * @instance
             */
            Lease.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Lease leaseId.
             * @member {Uint8Array} leaseId
             * @memberof vrp.InvokeScriptResult.Lease
             * @instance
             */
            Lease.prototype.leaseId = $util.newBuffer([]);

            /**
             * Encodes the specified Lease message. Does not implicitly {@link vrp.InvokeScriptResult.Lease.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.Lease
             * @static
             * @param {vrp.InvokeScriptResult.ILease} m Lease message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Lease.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.recipient != null && Object.hasOwnProperty.call(m, "recipient"))
                    $root.vrp.Recipient.encode(m.recipient, w.uint32(10).fork()).ldelim();
                if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                    w.uint32(16).int64(m.amount);
                if (m.nonce != null && Object.hasOwnProperty.call(m, "nonce"))
                    w.uint32(24).int64(m.nonce);
                if (m.leaseId != null && Object.hasOwnProperty.call(m, "leaseId"))
                    w.uint32(34).bytes(m.leaseId);
                return w;
            };

            /**
             * Decodes a Lease message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.Lease
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.Lease} Lease
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Lease.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Lease();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.recipient = $root.vrp.Recipient.decode(r, r.uint32());
                        break;
                    case 2:
                        m.amount = r.int64();
                        break;
                    case 3:
                        m.nonce = r.int64();
                        break;
                    case 4:
                        m.leaseId = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Lease;
        })();

        InvokeScriptResult.LeaseCancel = (function() {

            /**
             * Properties of a LeaseCancel.
             * @memberof vrp.InvokeScriptResult
             * @interface ILeaseCancel
             * @property {Uint8Array|null} [leaseId] LeaseCancel leaseId
             */

            /**
             * Constructs a new LeaseCancel.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a LeaseCancel.
             * @implements ILeaseCancel
             * @constructor
             * @param {vrp.InvokeScriptResult.ILeaseCancel=} [p] Properties to set
             */
            function LeaseCancel(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * LeaseCancel leaseId.
             * @member {Uint8Array} leaseId
             * @memberof vrp.InvokeScriptResult.LeaseCancel
             * @instance
             */
            LeaseCancel.prototype.leaseId = $util.newBuffer([]);

            /**
             * Encodes the specified LeaseCancel message. Does not implicitly {@link vrp.InvokeScriptResult.LeaseCancel.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.LeaseCancel
             * @static
             * @param {vrp.InvokeScriptResult.ILeaseCancel} m LeaseCancel message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaseCancel.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.leaseId != null && Object.hasOwnProperty.call(m, "leaseId"))
                    w.uint32(10).bytes(m.leaseId);
                return w;
            };

            /**
             * Decodes a LeaseCancel message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.LeaseCancel
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.LeaseCancel} LeaseCancel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaseCancel.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.LeaseCancel();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.leaseId = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return LeaseCancel;
        })();

        InvokeScriptResult.ErrorMessage = (function() {

            /**
             * Properties of an ErrorMessage.
             * @memberof vrp.InvokeScriptResult
             * @interface IErrorMessage
             * @property {number|null} [code] ErrorMessage code
             * @property {string|null} [text] ErrorMessage text
             */

            /**
             * Constructs a new ErrorMessage.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents an ErrorMessage.
             * @implements IErrorMessage
             * @constructor
             * @param {vrp.InvokeScriptResult.IErrorMessage=} [p] Properties to set
             */
            function ErrorMessage(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * ErrorMessage code.
             * @member {number} code
             * @memberof vrp.InvokeScriptResult.ErrorMessage
             * @instance
             */
            ErrorMessage.prototype.code = 0;

            /**
             * ErrorMessage text.
             * @member {string} text
             * @memberof vrp.InvokeScriptResult.ErrorMessage
             * @instance
             */
            ErrorMessage.prototype.text = "";

            /**
             * Encodes the specified ErrorMessage message. Does not implicitly {@link vrp.InvokeScriptResult.ErrorMessage.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.ErrorMessage
             * @static
             * @param {vrp.InvokeScriptResult.IErrorMessage} m ErrorMessage message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorMessage.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.code != null && Object.hasOwnProperty.call(m, "code"))
                    w.uint32(8).int32(m.code);
                if (m.text != null && Object.hasOwnProperty.call(m, "text"))
                    w.uint32(18).string(m.text);
                return w;
            };

            /**
             * Decodes an ErrorMessage message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.ErrorMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.ErrorMessage} ErrorMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorMessage.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.ErrorMessage();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.code = r.int32();
                        break;
                    case 2:
                        m.text = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ErrorMessage;
        })();

        InvokeScriptResult.Call = (function() {

            /**
             * Properties of a Call.
             * @memberof vrp.InvokeScriptResult
             * @interface ICall
             * @property {string|null} ["function"] Call function
             * @property {Array.<Uint8Array>|null} [argsBytes] Call argsBytes
             * @property {Array.<vrp.InvokeScriptResult.Call.IArgument>|null} [args] Call args
             */

            /**
             * Constructs a new Call.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents a Call.
             * @implements ICall
             * @constructor
             * @param {vrp.InvokeScriptResult.ICall=} [p] Properties to set
             */
            function Call(p) {
                this.argsBytes = [];
                this.args = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Call function.
             * @member {string} function
             * @memberof vrp.InvokeScriptResult.Call
             * @instance
             */
            Call.prototype["function"] = "";

            /**
             * Call argsBytes.
             * @member {Array.<Uint8Array>} argsBytes
             * @memberof vrp.InvokeScriptResult.Call
             * @instance
             */
            Call.prototype.argsBytes = $util.emptyArray;

            /**
             * Call args.
             * @member {Array.<vrp.InvokeScriptResult.Call.IArgument>} args
             * @memberof vrp.InvokeScriptResult.Call
             * @instance
             */
            Call.prototype.args = $util.emptyArray;

            /**
             * Encodes the specified Call message. Does not implicitly {@link vrp.InvokeScriptResult.Call.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.Call
             * @static
             * @param {vrp.InvokeScriptResult.ICall} m Call message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Call.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m["function"] != null && Object.hasOwnProperty.call(m, "function"))
                    w.uint32(10).string(m["function"]);
                if (m.argsBytes != null && m.argsBytes.length) {
                    for (var i = 0; i < m.argsBytes.length; ++i)
                        w.uint32(18).bytes(m.argsBytes[i]);
                }
                if (m.args != null && m.args.length) {
                    for (var i = 0; i < m.args.length; ++i)
                        $root.vrp.InvokeScriptResult.Call.Argument.encode(m.args[i], w.uint32(26).fork()).ldelim();
                }
                return w;
            };

            /**
             * Decodes a Call message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.Call
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.Call} Call
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Call.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Call();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m["function"] = r.string();
                        break;
                    case 2:
                        if (!(m.argsBytes && m.argsBytes.length))
                            m.argsBytes = [];
                        m.argsBytes.push(r.bytes());
                        break;
                    case 3:
                        if (!(m.args && m.args.length))
                            m.args = [];
                        m.args.push($root.vrp.InvokeScriptResult.Call.Argument.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            Call.Argument = (function() {

                /**
                 * Properties of an Argument.
                 * @memberof vrp.InvokeScriptResult.Call
                 * @interface IArgument
                 * @property {Long|null} [integerValue] Argument integerValue
                 * @property {Uint8Array|null} [binaryValue] Argument binaryValue
                 * @property {string|null} [stringValue] Argument stringValue
                 * @property {boolean|null} [booleanValue] Argument booleanValue
                 * @property {Uint8Array|null} [caseObj] Argument caseObj
                 * @property {vrp.InvokeScriptResult.Call.Argument.IList|null} [list] Argument list
                 */

                /**
                 * Constructs a new Argument.
                 * @memberof vrp.InvokeScriptResult.Call
                 * @classdesc Represents an Argument.
                 * @implements IArgument
                 * @constructor
                 * @param {vrp.InvokeScriptResult.Call.IArgument=} [p] Properties to set
                 */
                function Argument(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * Argument integerValue.
                 * @member {Long|null|undefined} integerValue
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @instance
                 */
                Argument.prototype.integerValue = null;

                /**
                 * Argument binaryValue.
                 * @member {Uint8Array|null|undefined} binaryValue
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @instance
                 */
                Argument.prototype.binaryValue = null;

                /**
                 * Argument stringValue.
                 * @member {string|null|undefined} stringValue
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @instance
                 */
                Argument.prototype.stringValue = null;

                /**
                 * Argument booleanValue.
                 * @member {boolean|null|undefined} booleanValue
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @instance
                 */
                Argument.prototype.booleanValue = null;

                /**
                 * Argument caseObj.
                 * @member {Uint8Array|null|undefined} caseObj
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @instance
                 */
                Argument.prototype.caseObj = null;

                /**
                 * Argument list.
                 * @member {vrp.InvokeScriptResult.Call.Argument.IList|null|undefined} list
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @instance
                 */
                Argument.prototype.list = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Argument value.
                 * @member {"integerValue"|"binaryValue"|"stringValue"|"booleanValue"|"caseObj"|"list"|undefined} value
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @instance
                 */
                Object.defineProperty(Argument.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["integerValue", "binaryValue", "stringValue", "booleanValue", "caseObj", "list"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified Argument message. Does not implicitly {@link vrp.InvokeScriptResult.Call.Argument.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @static
                 * @param {vrp.InvokeScriptResult.Call.IArgument} m Argument message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Argument.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.integerValue != null && Object.hasOwnProperty.call(m, "integerValue"))
                        w.uint32(8).int64(m.integerValue);
                    if (m.binaryValue != null && Object.hasOwnProperty.call(m, "binaryValue"))
                        w.uint32(18).bytes(m.binaryValue);
                    if (m.stringValue != null && Object.hasOwnProperty.call(m, "stringValue"))
                        w.uint32(26).string(m.stringValue);
                    if (m.booleanValue != null && Object.hasOwnProperty.call(m, "booleanValue"))
                        w.uint32(32).bool(m.booleanValue);
                    if (m.caseObj != null && Object.hasOwnProperty.call(m, "caseObj"))
                        w.uint32(42).bytes(m.caseObj);
                    if (m.list != null && Object.hasOwnProperty.call(m, "list"))
                        $root.vrp.InvokeScriptResult.Call.Argument.List.encode(m.list, w.uint32(82).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an Argument message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.InvokeScriptResult.Call.Argument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.InvokeScriptResult.Call.Argument} Argument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Argument.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Call.Argument();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.integerValue = r.int64();
                            break;
                        case 2:
                            m.binaryValue = r.bytes();
                            break;
                        case 3:
                            m.stringValue = r.string();
                            break;
                        case 4:
                            m.booleanValue = r.bool();
                            break;
                        case 5:
                            m.caseObj = r.bytes();
                            break;
                        case 10:
                            m.list = $root.vrp.InvokeScriptResult.Call.Argument.List.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                Argument.List = (function() {

                    /**
                     * Properties of a List.
                     * @memberof vrp.InvokeScriptResult.Call.Argument
                     * @interface IList
                     * @property {Array.<vrp.InvokeScriptResult.Call.IArgument>|null} [items] List items
                     */

                    /**
                     * Constructs a new List.
                     * @memberof vrp.InvokeScriptResult.Call.Argument
                     * @classdesc Represents a List.
                     * @implements IList
                     * @constructor
                     * @param {vrp.InvokeScriptResult.Call.Argument.IList=} [p] Properties to set
                     */
                    function List(p) {
                        this.items = [];
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * List items.
                     * @member {Array.<vrp.InvokeScriptResult.Call.IArgument>} items
                     * @memberof vrp.InvokeScriptResult.Call.Argument.List
                     * @instance
                     */
                    List.prototype.items = $util.emptyArray;

                    /**
                     * Encodes the specified List message. Does not implicitly {@link vrp.InvokeScriptResult.Call.Argument.List.verify|verify} messages.
                     * @function encode
                     * @memberof vrp.InvokeScriptResult.Call.Argument.List
                     * @static
                     * @param {vrp.InvokeScriptResult.Call.Argument.IList} m List message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    List.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.items != null && m.items.length) {
                            for (var i = 0; i < m.items.length; ++i)
                                $root.vrp.InvokeScriptResult.Call.Argument.encode(m.items[i], w.uint32(10).fork()).ldelim();
                        }
                        return w;
                    };

                    /**
                     * Decodes a List message from the specified reader or buffer.
                     * @function decode
                     * @memberof vrp.InvokeScriptResult.Call.Argument.List
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {vrp.InvokeScriptResult.Call.Argument.List} List
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    List.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Call.Argument.List();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                if (!(m.items && m.items.length))
                                    m.items = [];
                                m.items.push($root.vrp.InvokeScriptResult.Call.Argument.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return List;
                })();

                return Argument;
            })();

            return Call;
        })();

        InvokeScriptResult.Invocation = (function() {

            /**
             * Properties of an Invocation.
             * @memberof vrp.InvokeScriptResult
             * @interface IInvocation
             * @property {Uint8Array|null} [dApp] Invocation dApp
             * @property {vrp.InvokeScriptResult.ICall|null} [call] Invocation call
             * @property {Array.<vrp.IAmount>|null} [payments] Invocation payments
             * @property {vrp.IInvokeScriptResult|null} [stateChanges] Invocation stateChanges
             */

            /**
             * Constructs a new Invocation.
             * @memberof vrp.InvokeScriptResult
             * @classdesc Represents an Invocation.
             * @implements IInvocation
             * @constructor
             * @param {vrp.InvokeScriptResult.IInvocation=} [p] Properties to set
             */
            function Invocation(p) {
                this.payments = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Invocation dApp.
             * @member {Uint8Array} dApp
             * @memberof vrp.InvokeScriptResult.Invocation
             * @instance
             */
            Invocation.prototype.dApp = $util.newBuffer([]);

            /**
             * Invocation call.
             * @member {vrp.InvokeScriptResult.ICall|null|undefined} call
             * @memberof vrp.InvokeScriptResult.Invocation
             * @instance
             */
            Invocation.prototype.call = null;

            /**
             * Invocation payments.
             * @member {Array.<vrp.IAmount>} payments
             * @memberof vrp.InvokeScriptResult.Invocation
             * @instance
             */
            Invocation.prototype.payments = $util.emptyArray;

            /**
             * Invocation stateChanges.
             * @member {vrp.IInvokeScriptResult|null|undefined} stateChanges
             * @memberof vrp.InvokeScriptResult.Invocation
             * @instance
             */
            Invocation.prototype.stateChanges = null;

            /**
             * Encodes the specified Invocation message. Does not implicitly {@link vrp.InvokeScriptResult.Invocation.verify|verify} messages.
             * @function encode
             * @memberof vrp.InvokeScriptResult.Invocation
             * @static
             * @param {vrp.InvokeScriptResult.IInvocation} m Invocation message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Invocation.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.dApp != null && Object.hasOwnProperty.call(m, "dApp"))
                    w.uint32(10).bytes(m.dApp);
                if (m.call != null && Object.hasOwnProperty.call(m, "call"))
                    $root.vrp.InvokeScriptResult.Call.encode(m.call, w.uint32(18).fork()).ldelim();
                if (m.payments != null && m.payments.length) {
                    for (var i = 0; i < m.payments.length; ++i)
                        $root.vrp.Amount.encode(m.payments[i], w.uint32(26).fork()).ldelim();
                }
                if (m.stateChanges != null && Object.hasOwnProperty.call(m, "stateChanges"))
                    $root.vrp.InvokeScriptResult.encode(m.stateChanges, w.uint32(34).fork()).ldelim();
                return w;
            };

            /**
             * Decodes an Invocation message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.InvokeScriptResult.Invocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.InvokeScriptResult.Invocation} Invocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Invocation.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptResult.Invocation();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.dApp = r.bytes();
                        break;
                    case 2:
                        m.call = $root.vrp.InvokeScriptResult.Call.decode(r, r.uint32());
                        break;
                    case 3:
                        if (!(m.payments && m.payments.length))
                            m.payments = [];
                        m.payments.push($root.vrp.Amount.decode(r, r.uint32()));
                        break;
                    case 4:
                        m.stateChanges = $root.vrp.InvokeScriptResult.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Invocation;
        })();

        return InvokeScriptResult;
    })();

    vrp.node = (function() {

        /**
         * Namespace node.
         * @memberof vrp
         * @namespace
         */
        const node = {};

        node.grpc = (function() {

            /**
             * Namespace grpc.
             * @memberof vrp.node
             * @namespace
             */
            const grpc = {};

            grpc.AccountsApi = (function() {

                /**
                 * Constructs a new AccountsApi service.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an AccountsApi
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AccountsApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AccountsApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AccountsApi;

                /**
                 * Callback as used by {@link vrp.node.grpc.AccountsApi#getBalances}.
                 * @memberof vrp.node.grpc.AccountsApi
                 * @typedef GetBalancesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.BalanceResponse} [response] BalanceResponse
                 */

                /**
                 * Calls GetBalances.
                 * @function getBalances
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IBalancesRequest} request BalancesRequest message or plain object
                 * @param {vrp.node.grpc.AccountsApi.GetBalancesCallback} callback Node-style callback called with the error, if any, and BalanceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AccountsApi.prototype.getBalances = function getBalances(request, callback) {
                    return this.rpcCall(getBalances, $root.vrp.node.grpc.BalancesRequest, $root.vrp.node.grpc.BalanceResponse, request, callback);
                }, "name", { value: "GetBalances" });

                /**
                 * Calls GetBalances.
                 * @function getBalances
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IBalancesRequest} request BalancesRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.BalanceResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.AccountsApi#getScript}.
                 * @memberof vrp.node.grpc.AccountsApi
                 * @typedef GetScriptCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.ScriptData} [response] ScriptData
                 */

                /**
                 * Calls GetScript.
                 * @function getScript
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IAccountRequest} request AccountRequest message or plain object
                 * @param {vrp.node.grpc.AccountsApi.GetScriptCallback} callback Node-style callback called with the error, if any, and ScriptData
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AccountsApi.prototype.getScript = function getScript(request, callback) {
                    return this.rpcCall(getScript, $root.vrp.node.grpc.AccountRequest, $root.vrp.node.grpc.ScriptData, request, callback);
                }, "name", { value: "GetScript" });

                /**
                 * Calls GetScript.
                 * @function getScript
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IAccountRequest} request AccountRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.ScriptData>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.AccountsApi#getActiveLeases}.
                 * @memberof vrp.node.grpc.AccountsApi
                 * @typedef GetActiveLeasesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.LeaseResponse} [response] LeaseResponse
                 */

                /**
                 * Calls GetActiveLeases.
                 * @function getActiveLeases
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IAccountRequest} request AccountRequest message or plain object
                 * @param {vrp.node.grpc.AccountsApi.GetActiveLeasesCallback} callback Node-style callback called with the error, if any, and LeaseResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AccountsApi.prototype.getActiveLeases = function getActiveLeases(request, callback) {
                    return this.rpcCall(getActiveLeases, $root.vrp.node.grpc.AccountRequest, $root.vrp.node.grpc.LeaseResponse, request, callback);
                }, "name", { value: "GetActiveLeases" });

                /**
                 * Calls GetActiveLeases.
                 * @function getActiveLeases
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IAccountRequest} request AccountRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.LeaseResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.AccountsApi#getDataEntries}.
                 * @memberof vrp.node.grpc.AccountsApi
                 * @typedef GetDataEntriesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.DataEntryResponse} [response] DataEntryResponse
                 */

                /**
                 * Calls GetDataEntries.
                 * @function getDataEntries
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IDataRequest} request DataRequest message or plain object
                 * @param {vrp.node.grpc.AccountsApi.GetDataEntriesCallback} callback Node-style callback called with the error, if any, and DataEntryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AccountsApi.prototype.getDataEntries = function getDataEntries(request, callback) {
                    return this.rpcCall(getDataEntries, $root.vrp.node.grpc.DataRequest, $root.vrp.node.grpc.DataEntryResponse, request, callback);
                }, "name", { value: "GetDataEntries" });

                /**
                 * Calls GetDataEntries.
                 * @function getDataEntries
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {vrp.node.grpc.IDataRequest} request DataRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.DataEntryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.AccountsApi#resolveAlias}.
                 * @memberof vrp.node.grpc.AccountsApi
                 * @typedef ResolveAliasCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {google.protobuf.BytesValue} [response] BytesValue
                 */

                /**
                 * Calls ResolveAlias.
                 * @function resolveAlias
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {google.protobuf.IStringValue} request StringValue message or plain object
                 * @param {vrp.node.grpc.AccountsApi.ResolveAliasCallback} callback Node-style callback called with the error, if any, and BytesValue
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AccountsApi.prototype.resolveAlias = function resolveAlias(request, callback) {
                    return this.rpcCall(resolveAlias, $root.google.protobuf.StringValue, $root.google.protobuf.BytesValue, request, callback);
                }, "name", { value: "ResolveAlias" });

                /**
                 * Calls ResolveAlias.
                 * @function resolveAlias
                 * @memberof vrp.node.grpc.AccountsApi
                 * @instance
                 * @param {google.protobuf.IStringValue} request StringValue message or plain object
                 * @returns {Promise<google.protobuf.BytesValue>} Promise
                 * @variation 2
                 */

                return AccountsApi;
            })();

            grpc.AccountRequest = (function() {

                /**
                 * Properties of an AccountRequest.
                 * @memberof vrp.node.grpc
                 * @interface IAccountRequest
                 * @property {Uint8Array|null} [address] AccountRequest address
                 */

                /**
                 * Constructs a new AccountRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an AccountRequest.
                 * @implements IAccountRequest
                 * @constructor
                 * @param {vrp.node.grpc.IAccountRequest=} [p] Properties to set
                 */
                function AccountRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * AccountRequest address.
                 * @member {Uint8Array} address
                 * @memberof vrp.node.grpc.AccountRequest
                 * @instance
                 */
                AccountRequest.prototype.address = $util.newBuffer([]);

                /**
                 * Encodes the specified AccountRequest message. Does not implicitly {@link vrp.node.grpc.AccountRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.AccountRequest
                 * @static
                 * @param {vrp.node.grpc.IAccountRequest} m AccountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    return w;
                };

                /**
                 * Decodes an AccountRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.AccountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.AccountRequest} AccountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.AccountRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AccountRequest;
            })();

            grpc.DataRequest = (function() {

                /**
                 * Properties of a DataRequest.
                 * @memberof vrp.node.grpc
                 * @interface IDataRequest
                 * @property {Uint8Array|null} [address] DataRequest address
                 * @property {string|null} [key] DataRequest key
                 */

                /**
                 * Constructs a new DataRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a DataRequest.
                 * @implements IDataRequest
                 * @constructor
                 * @param {vrp.node.grpc.IDataRequest=} [p] Properties to set
                 */
                function DataRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * DataRequest address.
                 * @member {Uint8Array} address
                 * @memberof vrp.node.grpc.DataRequest
                 * @instance
                 */
                DataRequest.prototype.address = $util.newBuffer([]);

                /**
                 * DataRequest key.
                 * @member {string} key
                 * @memberof vrp.node.grpc.DataRequest
                 * @instance
                 */
                DataRequest.prototype.key = "";

                /**
                 * Encodes the specified DataRequest message. Does not implicitly {@link vrp.node.grpc.DataRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.DataRequest
                 * @static
                 * @param {vrp.node.grpc.IDataRequest} m DataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                        w.uint32(18).string(m.key);
                    return w;
                };

                /**
                 * Decodes a DataRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.DataRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.DataRequest} DataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.DataRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.key = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return DataRequest;
            })();

            grpc.BalancesRequest = (function() {

                /**
                 * Properties of a BalancesRequest.
                 * @memberof vrp.node.grpc
                 * @interface IBalancesRequest
                 * @property {Uint8Array|null} [address] BalancesRequest address
                 * @property {Array.<Uint8Array>|null} [assets] BalancesRequest assets
                 */

                /**
                 * Constructs a new BalancesRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BalancesRequest.
                 * @implements IBalancesRequest
                 * @constructor
                 * @param {vrp.node.grpc.IBalancesRequest=} [p] Properties to set
                 */
                function BalancesRequest(p) {
                    this.assets = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BalancesRequest address.
                 * @member {Uint8Array} address
                 * @memberof vrp.node.grpc.BalancesRequest
                 * @instance
                 */
                BalancesRequest.prototype.address = $util.newBuffer([]);

                /**
                 * BalancesRequest assets.
                 * @member {Array.<Uint8Array>} assets
                 * @memberof vrp.node.grpc.BalancesRequest
                 * @instance
                 */
                BalancesRequest.prototype.assets = $util.emptyArray;

                /**
                 * Encodes the specified BalancesRequest message. Does not implicitly {@link vrp.node.grpc.BalancesRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.BalancesRequest
                 * @static
                 * @param {vrp.node.grpc.IBalancesRequest} m BalancesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BalancesRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    if (m.assets != null && m.assets.length) {
                        for (var i = 0; i < m.assets.length; ++i)
                            w.uint32(34).bytes(m.assets[i]);
                    }
                    return w;
                };

                /**
                 * Decodes a BalancesRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.BalancesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.BalancesRequest} BalancesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BalancesRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.BalancesRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 4:
                            if (!(m.assets && m.assets.length))
                                m.assets = [];
                            m.assets.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BalancesRequest;
            })();

            grpc.BalanceResponse = (function() {

                /**
                 * Properties of a BalanceResponse.
                 * @memberof vrp.node.grpc
                 * @interface IBalanceResponse
                 * @property {vrp.node.grpc.BalanceResponse.IVRPBalances|null} [vrp] BalanceResponse vrp
                 * @property {vrp.IAmount|null} [asset] BalanceResponse asset
                 */

                /**
                 * Constructs a new BalanceResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BalanceResponse.
                 * @implements IBalanceResponse
                 * @constructor
                 * @param {vrp.node.grpc.IBalanceResponse=} [p] Properties to set
                 */
                function BalanceResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BalanceResponse vrp.
                 * @member {vrp.node.grpc.BalanceResponse.IVRPBalances|null|undefined} vrp
                 * @memberof vrp.node.grpc.BalanceResponse
                 * @instance
                 */
                BalanceResponse.prototype.vrp = null;

                /**
                 * BalanceResponse asset.
                 * @member {vrp.IAmount|null|undefined} asset
                 * @memberof vrp.node.grpc.BalanceResponse
                 * @instance
                 */
                BalanceResponse.prototype.asset = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * BalanceResponse balance.
                 * @member {"vrp"|"asset"|undefined} balance
                 * @memberof vrp.node.grpc.BalanceResponse
                 * @instance
                 */
                Object.defineProperty(BalanceResponse.prototype, "balance", {
                    get: $util.oneOfGetter($oneOfFields = ["vrp", "asset"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified BalanceResponse message. Does not implicitly {@link vrp.node.grpc.BalanceResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.BalanceResponse
                 * @static
                 * @param {vrp.node.grpc.IBalanceResponse} m BalanceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BalanceResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.vrp != null && Object.hasOwnProperty.call(m, "vrp"))
                        $root.vrp.node.grpc.BalanceResponse.VRPBalances.encode(m.vrp, w.uint32(10).fork()).ldelim();
                    if (m.asset != null && Object.hasOwnProperty.call(m, "asset"))
                        $root.vrp.Amount.encode(m.asset, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a BalanceResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.BalanceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.BalanceResponse} BalanceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BalanceResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.BalanceResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.vrp = $root.vrp.node.grpc.BalanceResponse.VRPBalances.decode(r, r.uint32());
                            break;
                        case 2:
                            m.asset = $root.vrp.Amount.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                BalanceResponse.VRPBalances = (function() {

                    /**
                     * Properties of a VRPBalances.
                     * @memberof vrp.node.grpc.BalanceResponse
                     * @interface IVRPBalances
                     * @property {Long|null} [regular] VRPBalances regular
                     * @property {Long|null} [generating] VRPBalances generating
                     * @property {Long|null} [available] VRPBalances available
                     * @property {Long|null} [effective] VRPBalances effective
                     * @property {Long|null} [leaseIn] VRPBalances leaseIn
                     * @property {Long|null} [leaseOut] VRPBalances leaseOut
                     */

                    /**
                     * Constructs a new VRPBalances.
                     * @memberof vrp.node.grpc.BalanceResponse
                     * @classdesc Represents a VRPBalances.
                     * @implements IVRPBalances
                     * @constructor
                     * @param {vrp.node.grpc.BalanceResponse.IVRPBalances=} [p] Properties to set
                     */
                    function VRPBalances(p) {
                        if (p)
                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                                if (p[ks[i]] != null)
                                    this[ks[i]] = p[ks[i]];
                    }

                    /**
                     * VRPBalances regular.
                     * @member {Long} regular
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @instance
                     */
                    VRPBalances.prototype.regular = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * VRPBalances generating.
                     * @member {Long} generating
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @instance
                     */
                    VRPBalances.prototype.generating = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * VRPBalances available.
                     * @member {Long} available
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @instance
                     */
                    VRPBalances.prototype.available = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * VRPBalances effective.
                     * @member {Long} effective
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @instance
                     */
                    VRPBalances.prototype.effective = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * VRPBalances leaseIn.
                     * @member {Long} leaseIn
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @instance
                     */
                    VRPBalances.prototype.leaseIn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * VRPBalances leaseOut.
                     * @member {Long} leaseOut
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @instance
                     */
                    VRPBalances.prototype.leaseOut = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Encodes the specified VRPBalances message. Does not implicitly {@link vrp.node.grpc.BalanceResponse.VRPBalances.verify|verify} messages.
                     * @function encode
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @static
                     * @param {vrp.node.grpc.BalanceResponse.IVRPBalances} m VRPBalances message or plain object to encode
                     * @param {$protobuf.Writer} [w] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    VRPBalances.encode = function encode(m, w) {
                        if (!w)
                            w = $Writer.create();
                        if (m.regular != null && Object.hasOwnProperty.call(m, "regular"))
                            w.uint32(8).int64(m.regular);
                        if (m.generating != null && Object.hasOwnProperty.call(m, "generating"))
                            w.uint32(16).int64(m.generating);
                        if (m.available != null && Object.hasOwnProperty.call(m, "available"))
                            w.uint32(24).int64(m.available);
                        if (m.effective != null && Object.hasOwnProperty.call(m, "effective"))
                            w.uint32(32).int64(m.effective);
                        if (m.leaseIn != null && Object.hasOwnProperty.call(m, "leaseIn"))
                            w.uint32(40).int64(m.leaseIn);
                        if (m.leaseOut != null && Object.hasOwnProperty.call(m, "leaseOut"))
                            w.uint32(48).int64(m.leaseOut);
                        return w;
                    };

                    /**
                     * Decodes a VRPBalances message from the specified reader or buffer.
                     * @function decode
                     * @memberof vrp.node.grpc.BalanceResponse.VRPBalances
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                     * @param {number} [l] Message length if known beforehand
                     * @returns {vrp.node.grpc.BalanceResponse.VRPBalances} VRPBalances
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    VRPBalances.decode = function decode(r, l) {
                        if (!(r instanceof $Reader))
                            r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.BalanceResponse.VRPBalances();
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                            case 1:
                                m.regular = r.int64();
                                break;
                            case 2:
                                m.generating = r.int64();
                                break;
                            case 3:
                                m.available = r.int64();
                                break;
                            case 4:
                                m.effective = r.int64();
                                break;
                            case 5:
                                m.leaseIn = r.int64();
                                break;
                            case 6:
                                m.leaseOut = r.int64();
                                break;
                            default:
                                r.skipType(t & 7);
                                break;
                            }
                        }
                        return m;
                    };

                    return VRPBalances;
                })();

                return BalanceResponse;
            })();

            grpc.DataEntryResponse = (function() {

                /**
                 * Properties of a DataEntryResponse.
                 * @memberof vrp.node.grpc
                 * @interface IDataEntryResponse
                 * @property {Uint8Array|null} [address] DataEntryResponse address
                 * @property {vrp.DataTransactionData.IDataEntry|null} [entry] DataEntryResponse entry
                 */

                /**
                 * Constructs a new DataEntryResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a DataEntryResponse.
                 * @implements IDataEntryResponse
                 * @constructor
                 * @param {vrp.node.grpc.IDataEntryResponse=} [p] Properties to set
                 */
                function DataEntryResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * DataEntryResponse address.
                 * @member {Uint8Array} address
                 * @memberof vrp.node.grpc.DataEntryResponse
                 * @instance
                 */
                DataEntryResponse.prototype.address = $util.newBuffer([]);

                /**
                 * DataEntryResponse entry.
                 * @member {vrp.DataTransactionData.IDataEntry|null|undefined} entry
                 * @memberof vrp.node.grpc.DataEntryResponse
                 * @instance
                 */
                DataEntryResponse.prototype.entry = null;

                /**
                 * Encodes the specified DataEntryResponse message. Does not implicitly {@link vrp.node.grpc.DataEntryResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.DataEntryResponse
                 * @static
                 * @param {vrp.node.grpc.IDataEntryResponse} m DataEntryResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataEntryResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    if (m.entry != null && Object.hasOwnProperty.call(m, "entry"))
                        $root.vrp.DataTransactionData.DataEntry.encode(m.entry, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a DataEntryResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.DataEntryResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.DataEntryResponse} DataEntryResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataEntryResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.DataEntryResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.entry = $root.vrp.DataTransactionData.DataEntry.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return DataEntryResponse;
            })();

            grpc.ScriptData = (function() {

                /**
                 * Properties of a ScriptData.
                 * @memberof vrp.node.grpc
                 * @interface IScriptData
                 * @property {Uint8Array|null} [scriptBytes] ScriptData scriptBytes
                 * @property {string|null} [scriptText] ScriptData scriptText
                 * @property {Long|null} [complexity] ScriptData complexity
                 */

                /**
                 * Constructs a new ScriptData.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a ScriptData.
                 * @implements IScriptData
                 * @constructor
                 * @param {vrp.node.grpc.IScriptData=} [p] Properties to set
                 */
                function ScriptData(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ScriptData scriptBytes.
                 * @member {Uint8Array} scriptBytes
                 * @memberof vrp.node.grpc.ScriptData
                 * @instance
                 */
                ScriptData.prototype.scriptBytes = $util.newBuffer([]);

                /**
                 * ScriptData scriptText.
                 * @member {string} scriptText
                 * @memberof vrp.node.grpc.ScriptData
                 * @instance
                 */
                ScriptData.prototype.scriptText = "";

                /**
                 * ScriptData complexity.
                 * @member {Long} complexity
                 * @memberof vrp.node.grpc.ScriptData
                 * @instance
                 */
                ScriptData.prototype.complexity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Encodes the specified ScriptData message. Does not implicitly {@link vrp.node.grpc.ScriptData.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.ScriptData
                 * @static
                 * @param {vrp.node.grpc.IScriptData} m ScriptData message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ScriptData.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.scriptBytes != null && Object.hasOwnProperty.call(m, "scriptBytes"))
                        w.uint32(10).bytes(m.scriptBytes);
                    if (m.scriptText != null && Object.hasOwnProperty.call(m, "scriptText"))
                        w.uint32(18).string(m.scriptText);
                    if (m.complexity != null && Object.hasOwnProperty.call(m, "complexity"))
                        w.uint32(24).int64(m.complexity);
                    return w;
                };

                /**
                 * Decodes a ScriptData message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.ScriptData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.ScriptData} ScriptData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ScriptData.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.ScriptData();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.scriptBytes = r.bytes();
                            break;
                        case 2:
                            m.scriptText = r.string();
                            break;
                        case 3:
                            m.complexity = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ScriptData;
            })();

            grpc.LeaseResponse = (function() {

                /**
                 * Properties of a LeaseResponse.
                 * @memberof vrp.node.grpc
                 * @interface ILeaseResponse
                 * @property {Uint8Array|null} [leaseId] LeaseResponse leaseId
                 * @property {Uint8Array|null} [originTransactionId] LeaseResponse originTransactionId
                 * @property {Uint8Array|null} [sender] LeaseResponse sender
                 * @property {vrp.IRecipient|null} [recipient] LeaseResponse recipient
                 * @property {Long|null} [amount] LeaseResponse amount
                 * @property {Long|null} [height] LeaseResponse height
                 */

                /**
                 * Constructs a new LeaseResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a LeaseResponse.
                 * @implements ILeaseResponse
                 * @constructor
                 * @param {vrp.node.grpc.ILeaseResponse=} [p] Properties to set
                 */
                function LeaseResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * LeaseResponse leaseId.
                 * @member {Uint8Array} leaseId
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @instance
                 */
                LeaseResponse.prototype.leaseId = $util.newBuffer([]);

                /**
                 * LeaseResponse originTransactionId.
                 * @member {Uint8Array} originTransactionId
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @instance
                 */
                LeaseResponse.prototype.originTransactionId = $util.newBuffer([]);

                /**
                 * LeaseResponse sender.
                 * @member {Uint8Array} sender
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @instance
                 */
                LeaseResponse.prototype.sender = $util.newBuffer([]);

                /**
                 * LeaseResponse recipient.
                 * @member {vrp.IRecipient|null|undefined} recipient
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @instance
                 */
                LeaseResponse.prototype.recipient = null;

                /**
                 * LeaseResponse amount.
                 * @member {Long} amount
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @instance
                 */
                LeaseResponse.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * LeaseResponse height.
                 * @member {Long} height
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @instance
                 */
                LeaseResponse.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Encodes the specified LeaseResponse message. Does not implicitly {@link vrp.node.grpc.LeaseResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @static
                 * @param {vrp.node.grpc.ILeaseResponse} m LeaseResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LeaseResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.leaseId != null && Object.hasOwnProperty.call(m, "leaseId"))
                        w.uint32(10).bytes(m.leaseId);
                    if (m.originTransactionId != null && Object.hasOwnProperty.call(m, "originTransactionId"))
                        w.uint32(18).bytes(m.originTransactionId);
                    if (m.sender != null && Object.hasOwnProperty.call(m, "sender"))
                        w.uint32(26).bytes(m.sender);
                    if (m.recipient != null && Object.hasOwnProperty.call(m, "recipient"))
                        $root.vrp.Recipient.encode(m.recipient, w.uint32(34).fork()).ldelim();
                    if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                        w.uint32(40).int64(m.amount);
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(48).int64(m.height);
                    return w;
                };

                /**
                 * Decodes a LeaseResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.LeaseResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.LeaseResponse} LeaseResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LeaseResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.LeaseResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.leaseId = r.bytes();
                            break;
                        case 2:
                            m.originTransactionId = r.bytes();
                            break;
                        case 3:
                            m.sender = r.bytes();
                            break;
                        case 4:
                            m.recipient = $root.vrp.Recipient.decode(r, r.uint32());
                            break;
                        case 5:
                            m.amount = r.int64();
                            break;
                        case 6:
                            m.height = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return LeaseResponse;
            })();

            grpc.AssetsApi = (function() {

                /**
                 * Constructs a new AssetsApi service.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an AssetsApi
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AssetsApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AssetsApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AssetsApi;

                /**
                 * Callback as used by {@link vrp.node.grpc.AssetsApi#getInfo}.
                 * @memberof vrp.node.grpc.AssetsApi
                 * @typedef GetInfoCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.AssetInfoResponse} [response] AssetInfoResponse
                 */

                /**
                 * Calls GetInfo.
                 * @function getInfo
                 * @memberof vrp.node.grpc.AssetsApi
                 * @instance
                 * @param {vrp.node.grpc.IAssetRequest} request AssetRequest message or plain object
                 * @param {vrp.node.grpc.AssetsApi.GetInfoCallback} callback Node-style callback called with the error, if any, and AssetInfoResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AssetsApi.prototype.getInfo = function getInfo(request, callback) {
                    return this.rpcCall(getInfo, $root.vrp.node.grpc.AssetRequest, $root.vrp.node.grpc.AssetInfoResponse, request, callback);
                }, "name", { value: "GetInfo" });

                /**
                 * Calls GetInfo.
                 * @function getInfo
                 * @memberof vrp.node.grpc.AssetsApi
                 * @instance
                 * @param {vrp.node.grpc.IAssetRequest} request AssetRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.AssetInfoResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.AssetsApi#getNFTList}.
                 * @memberof vrp.node.grpc.AssetsApi
                 * @typedef GetNFTListCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.NFTResponse} [response] NFTResponse
                 */

                /**
                 * Calls GetNFTList.
                 * @function getNFTList
                 * @memberof vrp.node.grpc.AssetsApi
                 * @instance
                 * @param {vrp.node.grpc.INFTRequest} request NFTRequest message or plain object
                 * @param {vrp.node.grpc.AssetsApi.GetNFTListCallback} callback Node-style callback called with the error, if any, and NFTResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AssetsApi.prototype.getNFTList = function getNFTList(request, callback) {
                    return this.rpcCall(getNFTList, $root.vrp.node.grpc.NFTRequest, $root.vrp.node.grpc.NFTResponse, request, callback);
                }, "name", { value: "GetNFTList" });

                /**
                 * Calls GetNFTList.
                 * @function getNFTList
                 * @memberof vrp.node.grpc.AssetsApi
                 * @instance
                 * @param {vrp.node.grpc.INFTRequest} request NFTRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.NFTResponse>} Promise
                 * @variation 2
                 */

                return AssetsApi;
            })();

            grpc.AssetRequest = (function() {

                /**
                 * Properties of an AssetRequest.
                 * @memberof vrp.node.grpc
                 * @interface IAssetRequest
                 * @property {Uint8Array|null} [assetId] AssetRequest assetId
                 */

                /**
                 * Constructs a new AssetRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an AssetRequest.
                 * @implements IAssetRequest
                 * @constructor
                 * @param {vrp.node.grpc.IAssetRequest=} [p] Properties to set
                 */
                function AssetRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * AssetRequest assetId.
                 * @member {Uint8Array} assetId
                 * @memberof vrp.node.grpc.AssetRequest
                 * @instance
                 */
                AssetRequest.prototype.assetId = $util.newBuffer([]);

                /**
                 * Encodes the specified AssetRequest message. Does not implicitly {@link vrp.node.grpc.AssetRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.AssetRequest
                 * @static
                 * @param {vrp.node.grpc.IAssetRequest} m AssetRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AssetRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                        w.uint32(10).bytes(m.assetId);
                    return w;
                };

                /**
                 * Decodes an AssetRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.AssetRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.AssetRequest} AssetRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AssetRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.AssetRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AssetRequest;
            })();

            grpc.NFTRequest = (function() {

                /**
                 * Properties of a NFTRequest.
                 * @memberof vrp.node.grpc
                 * @interface INFTRequest
                 * @property {Uint8Array|null} [address] NFTRequest address
                 * @property {number|null} [limit] NFTRequest limit
                 * @property {Uint8Array|null} [afterAssetId] NFTRequest afterAssetId
                 */

                /**
                 * Constructs a new NFTRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a NFTRequest.
                 * @implements INFTRequest
                 * @constructor
                 * @param {vrp.node.grpc.INFTRequest=} [p] Properties to set
                 */
                function NFTRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * NFTRequest address.
                 * @member {Uint8Array} address
                 * @memberof vrp.node.grpc.NFTRequest
                 * @instance
                 */
                NFTRequest.prototype.address = $util.newBuffer([]);

                /**
                 * NFTRequest limit.
                 * @member {number} limit
                 * @memberof vrp.node.grpc.NFTRequest
                 * @instance
                 */
                NFTRequest.prototype.limit = 0;

                /**
                 * NFTRequest afterAssetId.
                 * @member {Uint8Array} afterAssetId
                 * @memberof vrp.node.grpc.NFTRequest
                 * @instance
                 */
                NFTRequest.prototype.afterAssetId = $util.newBuffer([]);

                /**
                 * Encodes the specified NFTRequest message. Does not implicitly {@link vrp.node.grpc.NFTRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.NFTRequest
                 * @static
                 * @param {vrp.node.grpc.INFTRequest} m NFTRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NFTRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.address != null && Object.hasOwnProperty.call(m, "address"))
                        w.uint32(10).bytes(m.address);
                    if (m.limit != null && Object.hasOwnProperty.call(m, "limit"))
                        w.uint32(16).int32(m.limit);
                    if (m.afterAssetId != null && Object.hasOwnProperty.call(m, "afterAssetId"))
                        w.uint32(26).bytes(m.afterAssetId);
                    return w;
                };

                /**
                 * Decodes a NFTRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.NFTRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.NFTRequest} NFTRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NFTRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.NFTRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.address = r.bytes();
                            break;
                        case 2:
                            m.limit = r.int32();
                            break;
                        case 3:
                            m.afterAssetId = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return NFTRequest;
            })();

            grpc.NFTResponse = (function() {

                /**
                 * Properties of a NFTResponse.
                 * @memberof vrp.node.grpc
                 * @interface INFTResponse
                 * @property {Uint8Array|null} [assetId] NFTResponse assetId
                 * @property {vrp.node.grpc.IAssetInfoResponse|null} [assetInfo] NFTResponse assetInfo
                 */

                /**
                 * Constructs a new NFTResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a NFTResponse.
                 * @implements INFTResponse
                 * @constructor
                 * @param {vrp.node.grpc.INFTResponse=} [p] Properties to set
                 */
                function NFTResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * NFTResponse assetId.
                 * @member {Uint8Array} assetId
                 * @memberof vrp.node.grpc.NFTResponse
                 * @instance
                 */
                NFTResponse.prototype.assetId = $util.newBuffer([]);

                /**
                 * NFTResponse assetInfo.
                 * @member {vrp.node.grpc.IAssetInfoResponse|null|undefined} assetInfo
                 * @memberof vrp.node.grpc.NFTResponse
                 * @instance
                 */
                NFTResponse.prototype.assetInfo = null;

                /**
                 * Encodes the specified NFTResponse message. Does not implicitly {@link vrp.node.grpc.NFTResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.NFTResponse
                 * @static
                 * @param {vrp.node.grpc.INFTResponse} m NFTResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NFTResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                        w.uint32(10).bytes(m.assetId);
                    if (m.assetInfo != null && Object.hasOwnProperty.call(m, "assetInfo"))
                        $root.vrp.node.grpc.AssetInfoResponse.encode(m.assetInfo, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a NFTResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.NFTResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.NFTResponse} NFTResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NFTResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.NFTResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        case 2:
                            m.assetInfo = $root.vrp.node.grpc.AssetInfoResponse.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return NFTResponse;
            })();

            grpc.AssetInfoResponse = (function() {

                /**
                 * Properties of an AssetInfoResponse.
                 * @memberof vrp.node.grpc
                 * @interface IAssetInfoResponse
                 * @property {Uint8Array|null} [issuer] AssetInfoResponse issuer
                 * @property {string|null} [name] AssetInfoResponse name
                 * @property {string|null} [description] AssetInfoResponse description
                 * @property {number|null} [decimals] AssetInfoResponse decimals
                 * @property {boolean|null} [reissuable] AssetInfoResponse reissuable
                 * @property {Long|null} [totalVolume] AssetInfoResponse totalVolume
                 * @property {vrp.node.grpc.IScriptData|null} [script] AssetInfoResponse script
                 * @property {Long|null} [sponsorship] AssetInfoResponse sponsorship
                 * @property {vrp.ISignedTransaction|null} [issueTransaction] AssetInfoResponse issueTransaction
                 * @property {Long|null} [sponsorBalance] AssetInfoResponse sponsorBalance
                 * @property {string|null} [image] AssetInfoResponse image
                 */

                /**
                 * Constructs a new AssetInfoResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an AssetInfoResponse.
                 * @implements IAssetInfoResponse
                 * @constructor
                 * @param {vrp.node.grpc.IAssetInfoResponse=} [p] Properties to set
                 */
                function AssetInfoResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * AssetInfoResponse issuer.
                 * @member {Uint8Array} issuer
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.issuer = $util.newBuffer([]);

                /**
                 * AssetInfoResponse name.
                 * @member {string} name
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.name = "";

                /**
                 * AssetInfoResponse description.
                 * @member {string} description
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.description = "";

                /**
                 * AssetInfoResponse decimals.
                 * @member {number} decimals
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.decimals = 0;

                /**
                 * AssetInfoResponse reissuable.
                 * @member {boolean} reissuable
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.reissuable = false;

                /**
                 * AssetInfoResponse totalVolume.
                 * @member {Long} totalVolume
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.totalVolume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * AssetInfoResponse script.
                 * @member {vrp.node.grpc.IScriptData|null|undefined} script
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.script = null;

                /**
                 * AssetInfoResponse sponsorship.
                 * @member {Long} sponsorship
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.sponsorship = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * AssetInfoResponse issueTransaction.
                 * @member {vrp.ISignedTransaction|null|undefined} issueTransaction
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.issueTransaction = null;

                /**
                 * AssetInfoResponse sponsorBalance.
                 * @member {Long} sponsorBalance
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.sponsorBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * AssetInfoResponse image.
                 * @member {string} image
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @instance
                 */
                AssetInfoResponse.prototype.image = "";

                /**
                 * Encodes the specified AssetInfoResponse message. Does not implicitly {@link vrp.node.grpc.AssetInfoResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @static
                 * @param {vrp.node.grpc.IAssetInfoResponse} m AssetInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AssetInfoResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.issuer != null && Object.hasOwnProperty.call(m, "issuer"))
                        w.uint32(10).bytes(m.issuer);
                    if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                        w.uint32(18).string(m.name);
                    if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                        w.uint32(26).string(m.description);
                    if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                        w.uint32(32).int32(m.decimals);
                    if (m.reissuable != null && Object.hasOwnProperty.call(m, "reissuable"))
                        w.uint32(40).bool(m.reissuable);
                    if (m.totalVolume != null && Object.hasOwnProperty.call(m, "totalVolume"))
                        w.uint32(48).int64(m.totalVolume);
                    if (m.script != null && Object.hasOwnProperty.call(m, "script"))
                        $root.vrp.node.grpc.ScriptData.encode(m.script, w.uint32(58).fork()).ldelim();
                    if (m.sponsorship != null && Object.hasOwnProperty.call(m, "sponsorship"))
                        w.uint32(64).int64(m.sponsorship);
                    if (m.sponsorBalance != null && Object.hasOwnProperty.call(m, "sponsorBalance"))
                        w.uint32(80).int64(m.sponsorBalance);
                    if (m.issueTransaction != null && Object.hasOwnProperty.call(m, "issueTransaction"))
                        $root.vrp.SignedTransaction.encode(m.issueTransaction, w.uint32(90).fork()).ldelim();
                    if (m.image != null && Object.hasOwnProperty.call(m, "image"))
                        w.uint32(98).string(m.image);
                    return w;
                };

                /**
                 * Decodes an AssetInfoResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.AssetInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.AssetInfoResponse} AssetInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AssetInfoResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.AssetInfoResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.issuer = r.bytes();
                            break;
                        case 2:
                            m.name = r.string();
                            break;
                        case 3:
                            m.description = r.string();
                            break;
                        case 4:
                            m.decimals = r.int32();
                            break;
                        case 5:
                            m.reissuable = r.bool();
                            break;
                        case 6:
                            m.totalVolume = r.int64();
                            break;
                        case 7:
                            m.script = $root.vrp.node.grpc.ScriptData.decode(r, r.uint32());
                            break;
                        case 8:
                            m.sponsorship = r.int64();
                            break;
                        case 11:
                            m.issueTransaction = $root.vrp.SignedTransaction.decode(r, r.uint32());
                            break;
                        case 10:
                            m.sponsorBalance = r.int64();
                            break;
                        case 12:
                            m.image = r.string();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return AssetInfoResponse;
            })();

            grpc.BlockchainApi = (function() {

                /**
                 * Constructs a new BlockchainApi service.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BlockchainApi
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function BlockchainApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (BlockchainApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BlockchainApi;

                /**
                 * Callback as used by {@link vrp.node.grpc.BlockchainApi#getActivationStatus}.
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @typedef GetActivationStatusCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.ActivationStatusResponse} [response] ActivationStatusResponse
                 */

                /**
                 * Calls GetActivationStatus.
                 * @function getActivationStatus
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @instance
                 * @param {vrp.node.grpc.IActivationStatusRequest} request ActivationStatusRequest message or plain object
                 * @param {vrp.node.grpc.BlockchainApi.GetActivationStatusCallback} callback Node-style callback called with the error, if any, and ActivationStatusResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlockchainApi.prototype.getActivationStatus = function getActivationStatus(request, callback) {
                    return this.rpcCall(getActivationStatus, $root.vrp.node.grpc.ActivationStatusRequest, $root.vrp.node.grpc.ActivationStatusResponse, request, callback);
                }, "name", { value: "GetActivationStatus" });

                /**
                 * Calls GetActivationStatus.
                 * @function getActivationStatus
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @instance
                 * @param {vrp.node.grpc.IActivationStatusRequest} request ActivationStatusRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.ActivationStatusResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.BlockchainApi#getBaseTarget}.
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @typedef GetBaseTargetCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.BaseTargetResponse} [response] BaseTargetResponse
                 */

                /**
                 * Calls GetBaseTarget.
                 * @function getBaseTarget
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @instance
                 * @param {google.protobuf.IEmpty} request Empty message or plain object
                 * @param {vrp.node.grpc.BlockchainApi.GetBaseTargetCallback} callback Node-style callback called with the error, if any, and BaseTargetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlockchainApi.prototype.getBaseTarget = function getBaseTarget(request, callback) {
                    return this.rpcCall(getBaseTarget, $root.google.protobuf.Empty, $root.vrp.node.grpc.BaseTargetResponse, request, callback);
                }, "name", { value: "GetBaseTarget" });

                /**
                 * Calls GetBaseTarget.
                 * @function getBaseTarget
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @instance
                 * @param {google.protobuf.IEmpty} request Empty message or plain object
                 * @returns {Promise<vrp.node.grpc.BaseTargetResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.BlockchainApi#getCumulativeScore}.
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @typedef GetCumulativeScoreCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.ScoreResponse} [response] ScoreResponse
                 */

                /**
                 * Calls GetCumulativeScore.
                 * @function getCumulativeScore
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @instance
                 * @param {google.protobuf.IEmpty} request Empty message or plain object
                 * @param {vrp.node.grpc.BlockchainApi.GetCumulativeScoreCallback} callback Node-style callback called with the error, if any, and ScoreResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlockchainApi.prototype.getCumulativeScore = function getCumulativeScore(request, callback) {
                    return this.rpcCall(getCumulativeScore, $root.google.protobuf.Empty, $root.vrp.node.grpc.ScoreResponse, request, callback);
                }, "name", { value: "GetCumulativeScore" });

                /**
                 * Calls GetCumulativeScore.
                 * @function getCumulativeScore
                 * @memberof vrp.node.grpc.BlockchainApi
                 * @instance
                 * @param {google.protobuf.IEmpty} request Empty message or plain object
                 * @returns {Promise<vrp.node.grpc.ScoreResponse>} Promise
                 * @variation 2
                 */

                return BlockchainApi;
            })();

            grpc.ActivationStatusRequest = (function() {

                /**
                 * Properties of an ActivationStatusRequest.
                 * @memberof vrp.node.grpc
                 * @interface IActivationStatusRequest
                 * @property {number|null} [height] ActivationStatusRequest height
                 */

                /**
                 * Constructs a new ActivationStatusRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an ActivationStatusRequest.
                 * @implements IActivationStatusRequest
                 * @constructor
                 * @param {vrp.node.grpc.IActivationStatusRequest=} [p] Properties to set
                 */
                function ActivationStatusRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ActivationStatusRequest height.
                 * @member {number} height
                 * @memberof vrp.node.grpc.ActivationStatusRequest
                 * @instance
                 */
                ActivationStatusRequest.prototype.height = 0;

                /**
                 * Encodes the specified ActivationStatusRequest message. Does not implicitly {@link vrp.node.grpc.ActivationStatusRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.ActivationStatusRequest
                 * @static
                 * @param {vrp.node.grpc.IActivationStatusRequest} m ActivationStatusRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationStatusRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(8).int32(m.height);
                    return w;
                };

                /**
                 * Decodes an ActivationStatusRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.ActivationStatusRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.ActivationStatusRequest} ActivationStatusRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationStatusRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.ActivationStatusRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.height = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ActivationStatusRequest;
            })();

            grpc.ActivationStatusResponse = (function() {

                /**
                 * Properties of an ActivationStatusResponse.
                 * @memberof vrp.node.grpc
                 * @interface IActivationStatusResponse
                 * @property {number|null} [height] ActivationStatusResponse height
                 * @property {number|null} [votingInterval] ActivationStatusResponse votingInterval
                 * @property {number|null} [votingThreshold] ActivationStatusResponse votingThreshold
                 * @property {number|null} [nextCheck] ActivationStatusResponse nextCheck
                 * @property {Array.<vrp.node.grpc.IFeatureActivationStatus>|null} [features] ActivationStatusResponse features
                 */

                /**
                 * Constructs a new ActivationStatusResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an ActivationStatusResponse.
                 * @implements IActivationStatusResponse
                 * @constructor
                 * @param {vrp.node.grpc.IActivationStatusResponse=} [p] Properties to set
                 */
                function ActivationStatusResponse(p) {
                    this.features = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ActivationStatusResponse height.
                 * @member {number} height
                 * @memberof vrp.node.grpc.ActivationStatusResponse
                 * @instance
                 */
                ActivationStatusResponse.prototype.height = 0;

                /**
                 * ActivationStatusResponse votingInterval.
                 * @member {number} votingInterval
                 * @memberof vrp.node.grpc.ActivationStatusResponse
                 * @instance
                 */
                ActivationStatusResponse.prototype.votingInterval = 0;

                /**
                 * ActivationStatusResponse votingThreshold.
                 * @member {number} votingThreshold
                 * @memberof vrp.node.grpc.ActivationStatusResponse
                 * @instance
                 */
                ActivationStatusResponse.prototype.votingThreshold = 0;

                /**
                 * ActivationStatusResponse nextCheck.
                 * @member {number} nextCheck
                 * @memberof vrp.node.grpc.ActivationStatusResponse
                 * @instance
                 */
                ActivationStatusResponse.prototype.nextCheck = 0;

                /**
                 * ActivationStatusResponse features.
                 * @member {Array.<vrp.node.grpc.IFeatureActivationStatus>} features
                 * @memberof vrp.node.grpc.ActivationStatusResponse
                 * @instance
                 */
                ActivationStatusResponse.prototype.features = $util.emptyArray;

                /**
                 * Encodes the specified ActivationStatusResponse message. Does not implicitly {@link vrp.node.grpc.ActivationStatusResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.ActivationStatusResponse
                 * @static
                 * @param {vrp.node.grpc.IActivationStatusResponse} m ActivationStatusResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationStatusResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(8).int32(m.height);
                    if (m.votingInterval != null && Object.hasOwnProperty.call(m, "votingInterval"))
                        w.uint32(16).int32(m.votingInterval);
                    if (m.votingThreshold != null && Object.hasOwnProperty.call(m, "votingThreshold"))
                        w.uint32(24).int32(m.votingThreshold);
                    if (m.nextCheck != null && Object.hasOwnProperty.call(m, "nextCheck"))
                        w.uint32(32).int32(m.nextCheck);
                    if (m.features != null && m.features.length) {
                        for (var i = 0; i < m.features.length; ++i)
                            $root.vrp.node.grpc.FeatureActivationStatus.encode(m.features[i], w.uint32(42).fork()).ldelim();
                    }
                    return w;
                };

                /**
                 * Decodes an ActivationStatusResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.ActivationStatusResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.ActivationStatusResponse} ActivationStatusResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationStatusResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.ActivationStatusResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.height = r.int32();
                            break;
                        case 2:
                            m.votingInterval = r.int32();
                            break;
                        case 3:
                            m.votingThreshold = r.int32();
                            break;
                        case 4:
                            m.nextCheck = r.int32();
                            break;
                        case 5:
                            if (!(m.features && m.features.length))
                                m.features = [];
                            m.features.push($root.vrp.node.grpc.FeatureActivationStatus.decode(r, r.uint32()));
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ActivationStatusResponse;
            })();

            grpc.FeatureActivationStatus = (function() {

                /**
                 * Properties of a FeatureActivationStatus.
                 * @memberof vrp.node.grpc
                 * @interface IFeatureActivationStatus
                 * @property {number|null} [id] FeatureActivationStatus id
                 * @property {string|null} [description] FeatureActivationStatus description
                 * @property {vrp.node.grpc.FeatureActivationStatus.BlockchainFeatureStatus|null} [blockchainStatus] FeatureActivationStatus blockchainStatus
                 * @property {vrp.node.grpc.FeatureActivationStatus.NodeFeatureStatus|null} [nodeStatus] FeatureActivationStatus nodeStatus
                 * @property {number|null} [activationHeight] FeatureActivationStatus activationHeight
                 * @property {number|null} [supportingBlocks] FeatureActivationStatus supportingBlocks
                 */

                /**
                 * Constructs a new FeatureActivationStatus.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a FeatureActivationStatus.
                 * @implements IFeatureActivationStatus
                 * @constructor
                 * @param {vrp.node.grpc.IFeatureActivationStatus=} [p] Properties to set
                 */
                function FeatureActivationStatus(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * FeatureActivationStatus id.
                 * @member {number} id
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @instance
                 */
                FeatureActivationStatus.prototype.id = 0;

                /**
                 * FeatureActivationStatus description.
                 * @member {string} description
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @instance
                 */
                FeatureActivationStatus.prototype.description = "";

                /**
                 * FeatureActivationStatus blockchainStatus.
                 * @member {vrp.node.grpc.FeatureActivationStatus.BlockchainFeatureStatus} blockchainStatus
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @instance
                 */
                FeatureActivationStatus.prototype.blockchainStatus = 0;

                /**
                 * FeatureActivationStatus nodeStatus.
                 * @member {vrp.node.grpc.FeatureActivationStatus.NodeFeatureStatus} nodeStatus
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @instance
                 */
                FeatureActivationStatus.prototype.nodeStatus = 0;

                /**
                 * FeatureActivationStatus activationHeight.
                 * @member {number} activationHeight
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @instance
                 */
                FeatureActivationStatus.prototype.activationHeight = 0;

                /**
                 * FeatureActivationStatus supportingBlocks.
                 * @member {number} supportingBlocks
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @instance
                 */
                FeatureActivationStatus.prototype.supportingBlocks = 0;

                /**
                 * Encodes the specified FeatureActivationStatus message. Does not implicitly {@link vrp.node.grpc.FeatureActivationStatus.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @static
                 * @param {vrp.node.grpc.IFeatureActivationStatus} m FeatureActivationStatus message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureActivationStatus.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && Object.hasOwnProperty.call(m, "id"))
                        w.uint32(8).int32(m.id);
                    if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                        w.uint32(18).string(m.description);
                    if (m.blockchainStatus != null && Object.hasOwnProperty.call(m, "blockchainStatus"))
                        w.uint32(24).int32(m.blockchainStatus);
                    if (m.nodeStatus != null && Object.hasOwnProperty.call(m, "nodeStatus"))
                        w.uint32(32).int32(m.nodeStatus);
                    if (m.activationHeight != null && Object.hasOwnProperty.call(m, "activationHeight"))
                        w.uint32(40).int32(m.activationHeight);
                    if (m.supportingBlocks != null && Object.hasOwnProperty.call(m, "supportingBlocks"))
                        w.uint32(48).int32(m.supportingBlocks);
                    return w;
                };

                /**
                 * Decodes a FeatureActivationStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.FeatureActivationStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.FeatureActivationStatus} FeatureActivationStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureActivationStatus.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.FeatureActivationStatus();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.int32();
                            break;
                        case 2:
                            m.description = r.string();
                            break;
                        case 3:
                            m.blockchainStatus = r.int32();
                            break;
                        case 4:
                            m.nodeStatus = r.int32();
                            break;
                        case 5:
                            m.activationHeight = r.int32();
                            break;
                        case 6:
                            m.supportingBlocks = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * BlockchainFeatureStatus enum.
                 * @name vrp.node.grpc.FeatureActivationStatus.BlockchainFeatureStatus
                 * @enum {number}
                 * @property {number} UNDEFINED=0 UNDEFINED value
                 * @property {number} APPROVED=1 APPROVED value
                 * @property {number} ACTIVATED=2 ACTIVATED value
                 */
                FeatureActivationStatus.BlockchainFeatureStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNDEFINED"] = 0;
                    values[valuesById[1] = "APPROVED"] = 1;
                    values[valuesById[2] = "ACTIVATED"] = 2;
                    return values;
                })();

                /**
                 * NodeFeatureStatus enum.
                 * @name vrp.node.grpc.FeatureActivationStatus.NodeFeatureStatus
                 * @enum {number}
                 * @property {number} NOT_IMPLEMENTED=0 NOT_IMPLEMENTED value
                 * @property {number} IMPLEMENTED=1 IMPLEMENTED value
                 * @property {number} VOTED=2 VOTED value
                 */
                FeatureActivationStatus.NodeFeatureStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NOT_IMPLEMENTED"] = 0;
                    values[valuesById[1] = "IMPLEMENTED"] = 1;
                    values[valuesById[2] = "VOTED"] = 2;
                    return values;
                })();

                return FeatureActivationStatus;
            })();

            grpc.BaseTargetResponse = (function() {

                /**
                 * Properties of a BaseTargetResponse.
                 * @memberof vrp.node.grpc
                 * @interface IBaseTargetResponse
                 * @property {Long|null} [baseTarget] BaseTargetResponse baseTarget
                 */

                /**
                 * Constructs a new BaseTargetResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BaseTargetResponse.
                 * @implements IBaseTargetResponse
                 * @constructor
                 * @param {vrp.node.grpc.IBaseTargetResponse=} [p] Properties to set
                 */
                function BaseTargetResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BaseTargetResponse baseTarget.
                 * @member {Long} baseTarget
                 * @memberof vrp.node.grpc.BaseTargetResponse
                 * @instance
                 */
                BaseTargetResponse.prototype.baseTarget = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Encodes the specified BaseTargetResponse message. Does not implicitly {@link vrp.node.grpc.BaseTargetResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.BaseTargetResponse
                 * @static
                 * @param {vrp.node.grpc.IBaseTargetResponse} m BaseTargetResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BaseTargetResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.baseTarget != null && Object.hasOwnProperty.call(m, "baseTarget"))
                        w.uint32(8).int64(m.baseTarget);
                    return w;
                };

                /**
                 * Decodes a BaseTargetResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.BaseTargetResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.BaseTargetResponse} BaseTargetResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BaseTargetResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.BaseTargetResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.baseTarget = r.int64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BaseTargetResponse;
            })();

            grpc.ScoreResponse = (function() {

                /**
                 * Properties of a ScoreResponse.
                 * @memberof vrp.node.grpc
                 * @interface IScoreResponse
                 * @property {Uint8Array|null} [score] ScoreResponse score
                 */

                /**
                 * Constructs a new ScoreResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a ScoreResponse.
                 * @implements IScoreResponse
                 * @constructor
                 * @param {vrp.node.grpc.IScoreResponse=} [p] Properties to set
                 */
                function ScoreResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * ScoreResponse score.
                 * @member {Uint8Array} score
                 * @memberof vrp.node.grpc.ScoreResponse
                 * @instance
                 */
                ScoreResponse.prototype.score = $util.newBuffer([]);

                /**
                 * Encodes the specified ScoreResponse message. Does not implicitly {@link vrp.node.grpc.ScoreResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.ScoreResponse
                 * @static
                 * @param {vrp.node.grpc.IScoreResponse} m ScoreResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ScoreResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.score != null && Object.hasOwnProperty.call(m, "score"))
                        w.uint32(10).bytes(m.score);
                    return w;
                };

                /**
                 * Decodes a ScoreResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.ScoreResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.ScoreResponse} ScoreResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ScoreResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.ScoreResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.score = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return ScoreResponse;
            })();

            grpc.BlocksApi = (function() {

                /**
                 * Constructs a new BlocksApi service.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BlocksApi
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function BlocksApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (BlocksApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BlocksApi;

                /**
                 * Callback as used by {@link vrp.node.grpc.BlocksApi#getBlock}.
                 * @memberof vrp.node.grpc.BlocksApi
                 * @typedef GetBlockCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.BlockWithHeight} [response] BlockWithHeight
                 */

                /**
                 * Calls GetBlock.
                 * @function getBlock
                 * @memberof vrp.node.grpc.BlocksApi
                 * @instance
                 * @param {vrp.node.grpc.IBlockRequest} request BlockRequest message or plain object
                 * @param {vrp.node.grpc.BlocksApi.GetBlockCallback} callback Node-style callback called with the error, if any, and BlockWithHeight
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlocksApi.prototype.getBlock = function getBlock(request, callback) {
                    return this.rpcCall(getBlock, $root.vrp.node.grpc.BlockRequest, $root.vrp.node.grpc.BlockWithHeight, request, callback);
                }, "name", { value: "GetBlock" });

                /**
                 * Calls GetBlock.
                 * @function getBlock
                 * @memberof vrp.node.grpc.BlocksApi
                 * @instance
                 * @param {vrp.node.grpc.IBlockRequest} request BlockRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.BlockWithHeight>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.BlocksApi#getBlockRange}.
                 * @memberof vrp.node.grpc.BlocksApi
                 * @typedef GetBlockRangeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.BlockWithHeight} [response] BlockWithHeight
                 */

                /**
                 * Calls GetBlockRange.
                 * @function getBlockRange
                 * @memberof vrp.node.grpc.BlocksApi
                 * @instance
                 * @param {vrp.node.grpc.IBlockRangeRequest} request BlockRangeRequest message or plain object
                 * @param {vrp.node.grpc.BlocksApi.GetBlockRangeCallback} callback Node-style callback called with the error, if any, and BlockWithHeight
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlocksApi.prototype.getBlockRange = function getBlockRange(request, callback) {
                    return this.rpcCall(getBlockRange, $root.vrp.node.grpc.BlockRangeRequest, $root.vrp.node.grpc.BlockWithHeight, request, callback);
                }, "name", { value: "GetBlockRange" });

                /**
                 * Calls GetBlockRange.
                 * @function getBlockRange
                 * @memberof vrp.node.grpc.BlocksApi
                 * @instance
                 * @param {vrp.node.grpc.IBlockRangeRequest} request BlockRangeRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.BlockWithHeight>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.BlocksApi#getCurrentHeight}.
                 * @memberof vrp.node.grpc.BlocksApi
                 * @typedef GetCurrentHeightCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {google.protobuf.UInt32Value} [response] UInt32Value
                 */

                /**
                 * Calls GetCurrentHeight.
                 * @function getCurrentHeight
                 * @memberof vrp.node.grpc.BlocksApi
                 * @instance
                 * @param {google.protobuf.IEmpty} request Empty message or plain object
                 * @param {vrp.node.grpc.BlocksApi.GetCurrentHeightCallback} callback Node-style callback called with the error, if any, and UInt32Value
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(BlocksApi.prototype.getCurrentHeight = function getCurrentHeight(request, callback) {
                    return this.rpcCall(getCurrentHeight, $root.google.protobuf.Empty, $root.google.protobuf.UInt32Value, request, callback);
                }, "name", { value: "GetCurrentHeight" });

                /**
                 * Calls GetCurrentHeight.
                 * @function getCurrentHeight
                 * @memberof vrp.node.grpc.BlocksApi
                 * @instance
                 * @param {google.protobuf.IEmpty} request Empty message or plain object
                 * @returns {Promise<google.protobuf.UInt32Value>} Promise
                 * @variation 2
                 */

                return BlocksApi;
            })();

            grpc.BlockRequest = (function() {

                /**
                 * Properties of a BlockRequest.
                 * @memberof vrp.node.grpc
                 * @interface IBlockRequest
                 * @property {Uint8Array|null} [blockId] BlockRequest blockId
                 * @property {number|null} [height] BlockRequest height
                 * @property {Uint8Array|null} [reference] BlockRequest reference
                 * @property {boolean|null} [includeTransactions] BlockRequest includeTransactions
                 */

                /**
                 * Constructs a new BlockRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BlockRequest.
                 * @implements IBlockRequest
                 * @constructor
                 * @param {vrp.node.grpc.IBlockRequest=} [p] Properties to set
                 */
                function BlockRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BlockRequest blockId.
                 * @member {Uint8Array|null|undefined} blockId
                 * @memberof vrp.node.grpc.BlockRequest
                 * @instance
                 */
                BlockRequest.prototype.blockId = null;

                /**
                 * BlockRequest height.
                 * @member {number|null|undefined} height
                 * @memberof vrp.node.grpc.BlockRequest
                 * @instance
                 */
                BlockRequest.prototype.height = null;

                /**
                 * BlockRequest reference.
                 * @member {Uint8Array|null|undefined} reference
                 * @memberof vrp.node.grpc.BlockRequest
                 * @instance
                 */
                BlockRequest.prototype.reference = null;

                /**
                 * BlockRequest includeTransactions.
                 * @member {boolean} includeTransactions
                 * @memberof vrp.node.grpc.BlockRequest
                 * @instance
                 */
                BlockRequest.prototype.includeTransactions = false;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * BlockRequest request.
                 * @member {"blockId"|"height"|"reference"|undefined} request
                 * @memberof vrp.node.grpc.BlockRequest
                 * @instance
                 */
                Object.defineProperty(BlockRequest.prototype, "request", {
                    get: $util.oneOfGetter($oneOfFields = ["blockId", "height", "reference"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified BlockRequest message. Does not implicitly {@link vrp.node.grpc.BlockRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.BlockRequest
                 * @static
                 * @param {vrp.node.grpc.IBlockRequest} m BlockRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.blockId != null && Object.hasOwnProperty.call(m, "blockId"))
                        w.uint32(10).bytes(m.blockId);
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(16).int32(m.height);
                    if (m.reference != null && Object.hasOwnProperty.call(m, "reference"))
                        w.uint32(26).bytes(m.reference);
                    if (m.includeTransactions != null && Object.hasOwnProperty.call(m, "includeTransactions"))
                        w.uint32(8000).bool(m.includeTransactions);
                    return w;
                };

                /**
                 * Decodes a BlockRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.BlockRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.BlockRequest} BlockRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.BlockRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.blockId = r.bytes();
                            break;
                        case 2:
                            m.height = r.int32();
                            break;
                        case 3:
                            m.reference = r.bytes();
                            break;
                        case 1000:
                            m.includeTransactions = r.bool();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BlockRequest;
            })();

            grpc.BlockRangeRequest = (function() {

                /**
                 * Properties of a BlockRangeRequest.
                 * @memberof vrp.node.grpc
                 * @interface IBlockRangeRequest
                 * @property {number|null} [fromHeight] BlockRangeRequest fromHeight
                 * @property {number|null} [toHeight] BlockRangeRequest toHeight
                 * @property {Uint8Array|null} [generatorPublicKey] BlockRangeRequest generatorPublicKey
                 * @property {Uint8Array|null} [generatorAddress] BlockRangeRequest generatorAddress
                 * @property {boolean|null} [includeTransactions] BlockRangeRequest includeTransactions
                 */

                /**
                 * Constructs a new BlockRangeRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BlockRangeRequest.
                 * @implements IBlockRangeRequest
                 * @constructor
                 * @param {vrp.node.grpc.IBlockRangeRequest=} [p] Properties to set
                 */
                function BlockRangeRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BlockRangeRequest fromHeight.
                 * @member {number} fromHeight
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @instance
                 */
                BlockRangeRequest.prototype.fromHeight = 0;

                /**
                 * BlockRangeRequest toHeight.
                 * @member {number} toHeight
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @instance
                 */
                BlockRangeRequest.prototype.toHeight = 0;

                /**
                 * BlockRangeRequest generatorPublicKey.
                 * @member {Uint8Array|null|undefined} generatorPublicKey
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @instance
                 */
                BlockRangeRequest.prototype.generatorPublicKey = null;

                /**
                 * BlockRangeRequest generatorAddress.
                 * @member {Uint8Array|null|undefined} generatorAddress
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @instance
                 */
                BlockRangeRequest.prototype.generatorAddress = null;

                /**
                 * BlockRangeRequest includeTransactions.
                 * @member {boolean} includeTransactions
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @instance
                 */
                BlockRangeRequest.prototype.includeTransactions = false;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * BlockRangeRequest filter.
                 * @member {"generatorPublicKey"|"generatorAddress"|undefined} filter
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @instance
                 */
                Object.defineProperty(BlockRangeRequest.prototype, "filter", {
                    get: $util.oneOfGetter($oneOfFields = ["generatorPublicKey", "generatorAddress"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Encodes the specified BlockRangeRequest message. Does not implicitly {@link vrp.node.grpc.BlockRangeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @static
                 * @param {vrp.node.grpc.IBlockRangeRequest} m BlockRangeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockRangeRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.fromHeight != null && Object.hasOwnProperty.call(m, "fromHeight"))
                        w.uint32(8).uint32(m.fromHeight);
                    if (m.toHeight != null && Object.hasOwnProperty.call(m, "toHeight"))
                        w.uint32(16).uint32(m.toHeight);
                    if (m.generatorPublicKey != null && Object.hasOwnProperty.call(m, "generatorPublicKey"))
                        w.uint32(26).bytes(m.generatorPublicKey);
                    if (m.generatorAddress != null && Object.hasOwnProperty.call(m, "generatorAddress"))
                        w.uint32(34).bytes(m.generatorAddress);
                    if (m.includeTransactions != null && Object.hasOwnProperty.call(m, "includeTransactions"))
                        w.uint32(8000).bool(m.includeTransactions);
                    return w;
                };

                /**
                 * Decodes a BlockRangeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.BlockRangeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.BlockRangeRequest} BlockRangeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockRangeRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.BlockRangeRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.fromHeight = r.uint32();
                            break;
                        case 2:
                            m.toHeight = r.uint32();
                            break;
                        case 3:
                            m.generatorPublicKey = r.bytes();
                            break;
                        case 4:
                            m.generatorAddress = r.bytes();
                            break;
                        case 1000:
                            m.includeTransactions = r.bool();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BlockRangeRequest;
            })();

            grpc.BlockWithHeight = (function() {

                /**
                 * Properties of a BlockWithHeight.
                 * @memberof vrp.node.grpc
                 * @interface IBlockWithHeight
                 * @property {vrp.IBlock|null} [block] BlockWithHeight block
                 * @property {number|null} [height] BlockWithHeight height
                 */

                /**
                 * Constructs a new BlockWithHeight.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a BlockWithHeight.
                 * @implements IBlockWithHeight
                 * @constructor
                 * @param {vrp.node.grpc.IBlockWithHeight=} [p] Properties to set
                 */
                function BlockWithHeight(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * BlockWithHeight block.
                 * @member {vrp.IBlock|null|undefined} block
                 * @memberof vrp.node.grpc.BlockWithHeight
                 * @instance
                 */
                BlockWithHeight.prototype.block = null;

                /**
                 * BlockWithHeight height.
                 * @member {number} height
                 * @memberof vrp.node.grpc.BlockWithHeight
                 * @instance
                 */
                BlockWithHeight.prototype.height = 0;

                /**
                 * Encodes the specified BlockWithHeight message. Does not implicitly {@link vrp.node.grpc.BlockWithHeight.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.BlockWithHeight
                 * @static
                 * @param {vrp.node.grpc.IBlockWithHeight} m BlockWithHeight message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockWithHeight.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.block != null && Object.hasOwnProperty.call(m, "block"))
                        $root.vrp.Block.encode(m.block, w.uint32(10).fork()).ldelim();
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(16).uint32(m.height);
                    return w;
                };

                /**
                 * Decodes a BlockWithHeight message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.BlockWithHeight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.BlockWithHeight} BlockWithHeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockWithHeight.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.BlockWithHeight();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.block = $root.vrp.Block.decode(r, r.uint32());
                            break;
                        case 2:
                            m.height = r.uint32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return BlockWithHeight;
            })();

            grpc.TransactionsApi = (function() {

                /**
                 * Constructs a new TransactionsApi service.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a TransactionsApi
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function TransactionsApi(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (TransactionsApi.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TransactionsApi;

                /**
                 * Callback as used by {@link vrp.node.grpc.TransactionsApi#getTransactions}.
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @typedef GetTransactionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.TransactionResponse} [response] TransactionResponse
                 */

                /**
                 * Calls GetTransactions.
                 * @function getTransactions
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsRequest} request TransactionsRequest message or plain object
                 * @param {vrp.node.grpc.TransactionsApi.GetTransactionsCallback} callback Node-style callback called with the error, if any, and TransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TransactionsApi.prototype.getTransactions = function getTransactions(request, callback) {
                    return this.rpcCall(getTransactions, $root.vrp.node.grpc.TransactionsRequest, $root.vrp.node.grpc.TransactionResponse, request, callback);
                }, "name", { value: "GetTransactions" });

                /**
                 * Calls GetTransactions.
                 * @function getTransactions
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsRequest} request TransactionsRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.TransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.TransactionsApi#getStateChanges}.
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @typedef GetStateChangesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.InvokeScriptResultResponse} [response] InvokeScriptResultResponse
                 */

                /**
                 * Calls GetStateChanges.
                 * @function getStateChanges
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsRequest} request TransactionsRequest message or plain object
                 * @param {vrp.node.grpc.TransactionsApi.GetStateChangesCallback} callback Node-style callback called with the error, if any, and InvokeScriptResultResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TransactionsApi.prototype.getStateChanges = function getStateChanges(request, callback) {
                    return this.rpcCall(getStateChanges, $root.vrp.node.grpc.TransactionsRequest, $root.vrp.node.grpc.InvokeScriptResultResponse, request, callback);
                }, "name", { value: "GetStateChanges" });

                /**
                 * Calls GetStateChanges.
                 * @function getStateChanges
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsRequest} request TransactionsRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.InvokeScriptResultResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.TransactionsApi#getStatuses}.
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @typedef GetStatusesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.TransactionStatus} [response] TransactionStatus
                 */

                /**
                 * Calls GetStatuses.
                 * @function getStatuses
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsByIdRequest} request TransactionsByIdRequest message or plain object
                 * @param {vrp.node.grpc.TransactionsApi.GetStatusesCallback} callback Node-style callback called with the error, if any, and TransactionStatus
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TransactionsApi.prototype.getStatuses = function getStatuses(request, callback) {
                    return this.rpcCall(getStatuses, $root.vrp.node.grpc.TransactionsByIdRequest, $root.vrp.node.grpc.TransactionStatus, request, callback);
                }, "name", { value: "GetStatuses" });

                /**
                 * Calls GetStatuses.
                 * @function getStatuses
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsByIdRequest} request TransactionsByIdRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.TransactionStatus>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.TransactionsApi#getUnconfirmed}.
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @typedef GetUnconfirmedCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.node.grpc.TransactionResponse} [response] TransactionResponse
                 */

                /**
                 * Calls GetUnconfirmed.
                 * @function getUnconfirmed
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsRequest} request TransactionsRequest message or plain object
                 * @param {vrp.node.grpc.TransactionsApi.GetUnconfirmedCallback} callback Node-style callback called with the error, if any, and TransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TransactionsApi.prototype.getUnconfirmed = function getUnconfirmed(request, callback) {
                    return this.rpcCall(getUnconfirmed, $root.vrp.node.grpc.TransactionsRequest, $root.vrp.node.grpc.TransactionResponse, request, callback);
                }, "name", { value: "GetUnconfirmed" });

                /**
                 * Calls GetUnconfirmed.
                 * @function getUnconfirmed
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ITransactionsRequest} request TransactionsRequest message or plain object
                 * @returns {Promise<vrp.node.grpc.TransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.TransactionsApi#sign}.
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @typedef SignCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.SignedTransaction} [response] SignedTransaction
                 */

                /**
                 * Calls Sign.
                 * @function sign
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ISignRequest} request SignRequest message or plain object
                 * @param {vrp.node.grpc.TransactionsApi.SignCallback} callback Node-style callback called with the error, if any, and SignedTransaction
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TransactionsApi.prototype.sign = function sign(request, callback) {
                    return this.rpcCall(sign, $root.vrp.node.grpc.SignRequest, $root.vrp.SignedTransaction, request, callback);
                }, "name", { value: "Sign" });

                /**
                 * Calls Sign.
                 * @function sign
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.node.grpc.ISignRequest} request SignRequest message or plain object
                 * @returns {Promise<vrp.SignedTransaction>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link vrp.node.grpc.TransactionsApi#broadcast}.
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @typedef BroadcastCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {vrp.SignedTransaction} [response] SignedTransaction
                 */

                /**
                 * Calls Broadcast.
                 * @function broadcast
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.ISignedTransaction} request SignedTransaction message or plain object
                 * @param {vrp.node.grpc.TransactionsApi.BroadcastCallback} callback Node-style callback called with the error, if any, and SignedTransaction
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TransactionsApi.prototype.broadcast = function broadcast(request, callback) {
                    return this.rpcCall(broadcast, $root.vrp.SignedTransaction, $root.vrp.SignedTransaction, request, callback);
                }, "name", { value: "Broadcast" });

                /**
                 * Calls Broadcast.
                 * @function broadcast
                 * @memberof vrp.node.grpc.TransactionsApi
                 * @instance
                 * @param {vrp.ISignedTransaction} request SignedTransaction message or plain object
                 * @returns {Promise<vrp.SignedTransaction>} Promise
                 * @variation 2
                 */

                return TransactionsApi;
            })();

            /**
             * ApplicationStatus enum.
             * @name vrp.node.grpc.ApplicationStatus
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SUCCEEDED=1 SUCCEEDED value
             * @property {number} SCRIPT_EXECUTION_FAILED=2 SCRIPT_EXECUTION_FAILED value
             */
            grpc.ApplicationStatus = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SUCCEEDED"] = 1;
                values[valuesById[2] = "SCRIPT_EXECUTION_FAILED"] = 2;
                return values;
            })();

            grpc.TransactionStatus = (function() {

                /**
                 * Properties of a TransactionStatus.
                 * @memberof vrp.node.grpc
                 * @interface ITransactionStatus
                 * @property {Uint8Array|null} [id] TransactionStatus id
                 * @property {vrp.node.grpc.TransactionStatus.Status|null} [status] TransactionStatus status
                 * @property {Long|null} [height] TransactionStatus height
                 * @property {vrp.node.grpc.ApplicationStatus|null} [applicationStatus] TransactionStatus applicationStatus
                 */

                /**
                 * Constructs a new TransactionStatus.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a TransactionStatus.
                 * @implements ITransactionStatus
                 * @constructor
                 * @param {vrp.node.grpc.ITransactionStatus=} [p] Properties to set
                 */
                function TransactionStatus(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * TransactionStatus id.
                 * @member {Uint8Array} id
                 * @memberof vrp.node.grpc.TransactionStatus
                 * @instance
                 */
                TransactionStatus.prototype.id = $util.newBuffer([]);

                /**
                 * TransactionStatus status.
                 * @member {vrp.node.grpc.TransactionStatus.Status} status
                 * @memberof vrp.node.grpc.TransactionStatus
                 * @instance
                 */
                TransactionStatus.prototype.status = 0;

                /**
                 * TransactionStatus height.
                 * @member {Long} height
                 * @memberof vrp.node.grpc.TransactionStatus
                 * @instance
                 */
                TransactionStatus.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TransactionStatus applicationStatus.
                 * @member {vrp.node.grpc.ApplicationStatus} applicationStatus
                 * @memberof vrp.node.grpc.TransactionStatus
                 * @instance
                 */
                TransactionStatus.prototype.applicationStatus = 0;

                /**
                 * Encodes the specified TransactionStatus message. Does not implicitly {@link vrp.node.grpc.TransactionStatus.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.TransactionStatus
                 * @static
                 * @param {vrp.node.grpc.ITransactionStatus} m TransactionStatus message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionStatus.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && Object.hasOwnProperty.call(m, "id"))
                        w.uint32(10).bytes(m.id);
                    if (m.status != null && Object.hasOwnProperty.call(m, "status"))
                        w.uint32(16).int32(m.status);
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(24).int64(m.height);
                    if (m.applicationStatus != null && Object.hasOwnProperty.call(m, "applicationStatus"))
                        w.uint32(32).int32(m.applicationStatus);
                    return w;
                };

                /**
                 * Decodes a TransactionStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.TransactionStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.TransactionStatus} TransactionStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionStatus.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.TransactionStatus();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.bytes();
                            break;
                        case 2:
                            m.status = r.int32();
                            break;
                        case 3:
                            m.height = r.int64();
                            break;
                        case 4:
                            m.applicationStatus = r.int32();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                /**
                 * Status enum.
                 * @name vrp.node.grpc.TransactionStatus.Status
                 * @enum {number}
                 * @property {number} NOT_EXISTS=0 NOT_EXISTS value
                 * @property {number} UNCONFIRMED=1 UNCONFIRMED value
                 * @property {number} CONFIRMED=2 CONFIRMED value
                 */
                TransactionStatus.Status = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NOT_EXISTS"] = 0;
                    values[valuesById[1] = "UNCONFIRMED"] = 1;
                    values[valuesById[2] = "CONFIRMED"] = 2;
                    return values;
                })();

                return TransactionStatus;
            })();

            grpc.TransactionResponse = (function() {

                /**
                 * Properties of a TransactionResponse.
                 * @memberof vrp.node.grpc
                 * @interface ITransactionResponse
                 * @property {Uint8Array|null} [id] TransactionResponse id
                 * @property {Long|null} [height] TransactionResponse height
                 * @property {vrp.ISignedTransaction|null} [transaction] TransactionResponse transaction
                 * @property {vrp.node.grpc.ApplicationStatus|null} [applicationStatus] TransactionResponse applicationStatus
                 * @property {vrp.IInvokeScriptResult|null} [invokeScriptResult] TransactionResponse invokeScriptResult
                 */

                /**
                 * Constructs a new TransactionResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a TransactionResponse.
                 * @implements ITransactionResponse
                 * @constructor
                 * @param {vrp.node.grpc.ITransactionResponse=} [p] Properties to set
                 */
                function TransactionResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * TransactionResponse id.
                 * @member {Uint8Array} id
                 * @memberof vrp.node.grpc.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.id = $util.newBuffer([]);

                /**
                 * TransactionResponse height.
                 * @member {Long} height
                 * @memberof vrp.node.grpc.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TransactionResponse transaction.
                 * @member {vrp.ISignedTransaction|null|undefined} transaction
                 * @memberof vrp.node.grpc.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.transaction = null;

                /**
                 * TransactionResponse applicationStatus.
                 * @member {vrp.node.grpc.ApplicationStatus} applicationStatus
                 * @memberof vrp.node.grpc.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.applicationStatus = 0;

                /**
                 * TransactionResponse invokeScriptResult.
                 * @member {vrp.IInvokeScriptResult|null|undefined} invokeScriptResult
                 * @memberof vrp.node.grpc.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.invokeScriptResult = null;

                /**
                 * Encodes the specified TransactionResponse message. Does not implicitly {@link vrp.node.grpc.TransactionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.TransactionResponse
                 * @static
                 * @param {vrp.node.grpc.ITransactionResponse} m TransactionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.id != null && Object.hasOwnProperty.call(m, "id"))
                        w.uint32(10).bytes(m.id);
                    if (m.height != null && Object.hasOwnProperty.call(m, "height"))
                        w.uint32(16).int64(m.height);
                    if (m.transaction != null && Object.hasOwnProperty.call(m, "transaction"))
                        $root.vrp.SignedTransaction.encode(m.transaction, w.uint32(26).fork()).ldelim();
                    if (m.applicationStatus != null && Object.hasOwnProperty.call(m, "applicationStatus"))
                        w.uint32(32).int32(m.applicationStatus);
                    if (m.invokeScriptResult != null && Object.hasOwnProperty.call(m, "invokeScriptResult"))
                        $root.vrp.InvokeScriptResult.encode(m.invokeScriptResult, w.uint32(42).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes a TransactionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.TransactionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.TransactionResponse} TransactionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.TransactionResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.id = r.bytes();
                            break;
                        case 2:
                            m.height = r.int64();
                            break;
                        case 3:
                            m.transaction = $root.vrp.SignedTransaction.decode(r, r.uint32());
                            break;
                        case 4:
                            m.applicationStatus = r.int32();
                            break;
                        case 5:
                            m.invokeScriptResult = $root.vrp.InvokeScriptResult.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return TransactionResponse;
            })();

            grpc.TransactionsRequest = (function() {

                /**
                 * Properties of a TransactionsRequest.
                 * @memberof vrp.node.grpc
                 * @interface ITransactionsRequest
                 * @property {Uint8Array|null} [sender] TransactionsRequest sender
                 * @property {vrp.IRecipient|null} [recipient] TransactionsRequest recipient
                 * @property {Array.<Uint8Array>|null} [transactionIds] TransactionsRequest transactionIds
                 */

                /**
                 * Constructs a new TransactionsRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a TransactionsRequest.
                 * @implements ITransactionsRequest
                 * @constructor
                 * @param {vrp.node.grpc.ITransactionsRequest=} [p] Properties to set
                 */
                function TransactionsRequest(p) {
                    this.transactionIds = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * TransactionsRequest sender.
                 * @member {Uint8Array} sender
                 * @memberof vrp.node.grpc.TransactionsRequest
                 * @instance
                 */
                TransactionsRequest.prototype.sender = $util.newBuffer([]);

                /**
                 * TransactionsRequest recipient.
                 * @member {vrp.IRecipient|null|undefined} recipient
                 * @memberof vrp.node.grpc.TransactionsRequest
                 * @instance
                 */
                TransactionsRequest.prototype.recipient = null;

                /**
                 * TransactionsRequest transactionIds.
                 * @member {Array.<Uint8Array>} transactionIds
                 * @memberof vrp.node.grpc.TransactionsRequest
                 * @instance
                 */
                TransactionsRequest.prototype.transactionIds = $util.emptyArray;

                /**
                 * Encodes the specified TransactionsRequest message. Does not implicitly {@link vrp.node.grpc.TransactionsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.TransactionsRequest
                 * @static
                 * @param {vrp.node.grpc.ITransactionsRequest} m TransactionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionsRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.sender != null && Object.hasOwnProperty.call(m, "sender"))
                        w.uint32(10).bytes(m.sender);
                    if (m.recipient != null && Object.hasOwnProperty.call(m, "recipient"))
                        $root.vrp.Recipient.encode(m.recipient, w.uint32(18).fork()).ldelim();
                    if (m.transactionIds != null && m.transactionIds.length) {
                        for (var i = 0; i < m.transactionIds.length; ++i)
                            w.uint32(26).bytes(m.transactionIds[i]);
                    }
                    return w;
                };

                /**
                 * Decodes a TransactionsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.TransactionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.TransactionsRequest} TransactionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionsRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.TransactionsRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.sender = r.bytes();
                            break;
                        case 2:
                            m.recipient = $root.vrp.Recipient.decode(r, r.uint32());
                            break;
                        case 3:
                            if (!(m.transactionIds && m.transactionIds.length))
                                m.transactionIds = [];
                            m.transactionIds.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return TransactionsRequest;
            })();

            grpc.TransactionsByIdRequest = (function() {

                /**
                 * Properties of a TransactionsByIdRequest.
                 * @memberof vrp.node.grpc
                 * @interface ITransactionsByIdRequest
                 * @property {Array.<Uint8Array>|null} [transactionIds] TransactionsByIdRequest transactionIds
                 */

                /**
                 * Constructs a new TransactionsByIdRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a TransactionsByIdRequest.
                 * @implements ITransactionsByIdRequest
                 * @constructor
                 * @param {vrp.node.grpc.ITransactionsByIdRequest=} [p] Properties to set
                 */
                function TransactionsByIdRequest(p) {
                    this.transactionIds = [];
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * TransactionsByIdRequest transactionIds.
                 * @member {Array.<Uint8Array>} transactionIds
                 * @memberof vrp.node.grpc.TransactionsByIdRequest
                 * @instance
                 */
                TransactionsByIdRequest.prototype.transactionIds = $util.emptyArray;

                /**
                 * Encodes the specified TransactionsByIdRequest message. Does not implicitly {@link vrp.node.grpc.TransactionsByIdRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.TransactionsByIdRequest
                 * @static
                 * @param {vrp.node.grpc.ITransactionsByIdRequest} m TransactionsByIdRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionsByIdRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.transactionIds != null && m.transactionIds.length) {
                        for (var i = 0; i < m.transactionIds.length; ++i)
                            w.uint32(26).bytes(m.transactionIds[i]);
                    }
                    return w;
                };

                /**
                 * Decodes a TransactionsByIdRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.TransactionsByIdRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.TransactionsByIdRequest} TransactionsByIdRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionsByIdRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.TransactionsByIdRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 3:
                            if (!(m.transactionIds && m.transactionIds.length))
                                m.transactionIds = [];
                            m.transactionIds.push(r.bytes());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return TransactionsByIdRequest;
            })();

            grpc.CalculateFeeResponse = (function() {

                /**
                 * Properties of a CalculateFeeResponse.
                 * @memberof vrp.node.grpc
                 * @interface ICalculateFeeResponse
                 * @property {Uint8Array|null} [assetId] CalculateFeeResponse assetId
                 * @property {Long|null} [amount] CalculateFeeResponse amount
                 */

                /**
                 * Constructs a new CalculateFeeResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a CalculateFeeResponse.
                 * @implements ICalculateFeeResponse
                 * @constructor
                 * @param {vrp.node.grpc.ICalculateFeeResponse=} [p] Properties to set
                 */
                function CalculateFeeResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * CalculateFeeResponse assetId.
                 * @member {Uint8Array} assetId
                 * @memberof vrp.node.grpc.CalculateFeeResponse
                 * @instance
                 */
                CalculateFeeResponse.prototype.assetId = $util.newBuffer([]);

                /**
                 * CalculateFeeResponse amount.
                 * @member {Long} amount
                 * @memberof vrp.node.grpc.CalculateFeeResponse
                 * @instance
                 */
                CalculateFeeResponse.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Encodes the specified CalculateFeeResponse message. Does not implicitly {@link vrp.node.grpc.CalculateFeeResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.CalculateFeeResponse
                 * @static
                 * @param {vrp.node.grpc.ICalculateFeeResponse} m CalculateFeeResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CalculateFeeResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                        w.uint32(10).bytes(m.assetId);
                    if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                        w.uint32(16).uint64(m.amount);
                    return w;
                };

                /**
                 * Decodes a CalculateFeeResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.CalculateFeeResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.CalculateFeeResponse} CalculateFeeResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CalculateFeeResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.CalculateFeeResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.assetId = r.bytes();
                            break;
                        case 2:
                            m.amount = r.uint64();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return CalculateFeeResponse;
            })();

            grpc.SignRequest = (function() {

                /**
                 * Properties of a SignRequest.
                 * @memberof vrp.node.grpc
                 * @interface ISignRequest
                 * @property {vrp.ITransaction|null} [transaction] SignRequest transaction
                 * @property {Uint8Array|null} [signerPublicKey] SignRequest signerPublicKey
                 */

                /**
                 * Constructs a new SignRequest.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents a SignRequest.
                 * @implements ISignRequest
                 * @constructor
                 * @param {vrp.node.grpc.ISignRequest=} [p] Properties to set
                 */
                function SignRequest(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * SignRequest transaction.
                 * @member {vrp.ITransaction|null|undefined} transaction
                 * @memberof vrp.node.grpc.SignRequest
                 * @instance
                 */
                SignRequest.prototype.transaction = null;

                /**
                 * SignRequest signerPublicKey.
                 * @member {Uint8Array} signerPublicKey
                 * @memberof vrp.node.grpc.SignRequest
                 * @instance
                 */
                SignRequest.prototype.signerPublicKey = $util.newBuffer([]);

                /**
                 * Encodes the specified SignRequest message. Does not implicitly {@link vrp.node.grpc.SignRequest.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.SignRequest
                 * @static
                 * @param {vrp.node.grpc.ISignRequest} m SignRequest message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SignRequest.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.transaction != null && Object.hasOwnProperty.call(m, "transaction"))
                        $root.vrp.Transaction.encode(m.transaction, w.uint32(10).fork()).ldelim();
                    if (m.signerPublicKey != null && Object.hasOwnProperty.call(m, "signerPublicKey"))
                        w.uint32(18).bytes(m.signerPublicKey);
                    return w;
                };

                /**
                 * Decodes a SignRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.SignRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.SignRequest} SignRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SignRequest.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.SignRequest();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.transaction = $root.vrp.Transaction.decode(r, r.uint32());
                            break;
                        case 2:
                            m.signerPublicKey = r.bytes();
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return SignRequest;
            })();

            grpc.InvokeScriptResultResponse = (function() {

                /**
                 * Properties of an InvokeScriptResultResponse.
                 * @memberof vrp.node.grpc
                 * @interface IInvokeScriptResultResponse
                 * @property {vrp.ISignedTransaction|null} [transaction] InvokeScriptResultResponse transaction
                 * @property {vrp.IInvokeScriptResult|null} [result] InvokeScriptResultResponse result
                 */

                /**
                 * Constructs a new InvokeScriptResultResponse.
                 * @memberof vrp.node.grpc
                 * @classdesc Represents an InvokeScriptResultResponse.
                 * @implements IInvokeScriptResultResponse
                 * @constructor
                 * @param {vrp.node.grpc.IInvokeScriptResultResponse=} [p] Properties to set
                 */
                function InvokeScriptResultResponse(p) {
                    if (p)
                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                            if (p[ks[i]] != null)
                                this[ks[i]] = p[ks[i]];
                }

                /**
                 * InvokeScriptResultResponse transaction.
                 * @member {vrp.ISignedTransaction|null|undefined} transaction
                 * @memberof vrp.node.grpc.InvokeScriptResultResponse
                 * @instance
                 */
                InvokeScriptResultResponse.prototype.transaction = null;

                /**
                 * InvokeScriptResultResponse result.
                 * @member {vrp.IInvokeScriptResult|null|undefined} result
                 * @memberof vrp.node.grpc.InvokeScriptResultResponse
                 * @instance
                 */
                InvokeScriptResultResponse.prototype.result = null;

                /**
                 * Encodes the specified InvokeScriptResultResponse message. Does not implicitly {@link vrp.node.grpc.InvokeScriptResultResponse.verify|verify} messages.
                 * @function encode
                 * @memberof vrp.node.grpc.InvokeScriptResultResponse
                 * @static
                 * @param {vrp.node.grpc.IInvokeScriptResultResponse} m InvokeScriptResultResponse message or plain object to encode
                 * @param {$protobuf.Writer} [w] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvokeScriptResultResponse.encode = function encode(m, w) {
                    if (!w)
                        w = $Writer.create();
                    if (m.transaction != null && Object.hasOwnProperty.call(m, "transaction"))
                        $root.vrp.SignedTransaction.encode(m.transaction, w.uint32(10).fork()).ldelim();
                    if (m.result != null && Object.hasOwnProperty.call(m, "result"))
                        $root.vrp.InvokeScriptResult.encode(m.result, w.uint32(18).fork()).ldelim();
                    return w;
                };

                /**
                 * Decodes an InvokeScriptResultResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof vrp.node.grpc.InvokeScriptResultResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
                 * @param {number} [l] Message length if known beforehand
                 * @returns {vrp.node.grpc.InvokeScriptResultResponse} InvokeScriptResultResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvokeScriptResultResponse.decode = function decode(r, l) {
                    if (!(r instanceof $Reader))
                        r = $Reader.create(r);
                    var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.node.grpc.InvokeScriptResultResponse();
                    while (r.pos < c) {
                        var t = r.uint32();
                        switch (t >>> 3) {
                        case 1:
                            m.transaction = $root.vrp.SignedTransaction.decode(r, r.uint32());
                            break;
                        case 2:
                            m.result = $root.vrp.InvokeScriptResult.decode(r, r.uint32());
                            break;
                        default:
                            r.skipType(t & 7);
                            break;
                        }
                    }
                    return m;
                };

                return InvokeScriptResultResponse;
            })();

            return grpc;
        })();

        return node;
    })();

    vrp.AssetPair = (function() {

        /**
         * Properties of an AssetPair.
         * @memberof vrp
         * @interface IAssetPair
         * @property {Uint8Array|null} [amountAssetId] AssetPair amountAssetId
         * @property {Uint8Array|null} [priceAssetId] AssetPair priceAssetId
         */

        /**
         * Constructs a new AssetPair.
         * @memberof vrp
         * @classdesc Represents an AssetPair.
         * @implements IAssetPair
         * @constructor
         * @param {vrp.IAssetPair=} [p] Properties to set
         */
        function AssetPair(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * AssetPair amountAssetId.
         * @member {Uint8Array} amountAssetId
         * @memberof vrp.AssetPair
         * @instance
         */
        AssetPair.prototype.amountAssetId = $util.newBuffer([]);

        /**
         * AssetPair priceAssetId.
         * @member {Uint8Array} priceAssetId
         * @memberof vrp.AssetPair
         * @instance
         */
        AssetPair.prototype.priceAssetId = $util.newBuffer([]);

        /**
         * Encodes the specified AssetPair message. Does not implicitly {@link vrp.AssetPair.verify|verify} messages.
         * @function encode
         * @memberof vrp.AssetPair
         * @static
         * @param {vrp.IAssetPair} m AssetPair message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetPair.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amountAssetId != null && Object.hasOwnProperty.call(m, "amountAssetId"))
                w.uint32(10).bytes(m.amountAssetId);
            if (m.priceAssetId != null && Object.hasOwnProperty.call(m, "priceAssetId"))
                w.uint32(18).bytes(m.priceAssetId);
            return w;
        };

        /**
         * Decodes an AssetPair message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.AssetPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.AssetPair} AssetPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetPair.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.AssetPair();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.amountAssetId = r.bytes();
                    break;
                case 2:
                    m.priceAssetId = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AssetPair;
    })();

    vrp.Order = (function() {

        /**
         * Properties of an Order.
         * @memberof vrp
         * @interface IOrder
         * @property {Long|null} [chainId] Order chainId
         * @property {Uint8Array|null} [matcherPublicKey] Order matcherPublicKey
         * @property {vrp.IAssetPair|null} [assetPair] Order assetPair
         * @property {vrp.Order.Side|null} [orderSide] Order orderSide
         * @property {Long|null} [amount] Order amount
         * @property {Long|null} [price] Order price
         * @property {Long|null} [timestamp] Order timestamp
         * @property {Long|null} [expiration] Order expiration
         * @property {vrp.IAmount|null} [matcherFee] Order matcherFee
         * @property {number|null} [version] Order version
         * @property {Array.<Uint8Array>|null} [proofs] Order proofs
         * @property {vrp.Order.PriceMode|null} [priceMode] Order priceMode
         * @property {Uint8Array|null} [senderPublicKey] Order senderPublicKey
         * @property {Uint8Array|null} [eip712Signature] Order eip712Signature
         */

        /**
         * Constructs a new Order.
         * @memberof vrp
         * @classdesc Represents an Order.
         * @implements IOrder
         * @constructor
         * @param {vrp.IOrder=} [p] Properties to set
         */
        function Order(p) {
            this.proofs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Order chainId.
         * @member {Long} chainId
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.chainId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Order matcherPublicKey.
         * @member {Uint8Array} matcherPublicKey
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.matcherPublicKey = $util.newBuffer([]);

        /**
         * Order assetPair.
         * @member {vrp.IAssetPair|null|undefined} assetPair
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.assetPair = null;

        /**
         * Order orderSide.
         * @member {vrp.Order.Side} orderSide
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.orderSide = 0;

        /**
         * Order amount.
         * @member {Long} amount
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Order price.
         * @member {Long} price
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.price = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Order timestamp.
         * @member {Long} timestamp
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Order expiration.
         * @member {Long} expiration
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Order matcherFee.
         * @member {vrp.IAmount|null|undefined} matcherFee
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.matcherFee = null;

        /**
         * Order version.
         * @member {number} version
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.version = 0;

        /**
         * Order proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.proofs = $util.emptyArray;

        /**
         * Order priceMode.
         * @member {vrp.Order.PriceMode} priceMode
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.priceMode = 0;

        /**
         * Order senderPublicKey.
         * @member {Uint8Array|null|undefined} senderPublicKey
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.senderPublicKey = null;

        /**
         * Order eip712Signature.
         * @member {Uint8Array|null|undefined} eip712Signature
         * @memberof vrp.Order
         * @instance
         */
        Order.prototype.eip712Signature = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Order sender.
         * @member {"senderPublicKey"|"eip712Signature"|undefined} sender
         * @memberof vrp.Order
         * @instance
         */
        Object.defineProperty(Order.prototype, "sender", {
            get: $util.oneOfGetter($oneOfFields = ["senderPublicKey", "eip712Signature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified Order message. Does not implicitly {@link vrp.Order.verify|verify} messages.
         * @function encode
         * @memberof vrp.Order
         * @static
         * @param {vrp.IOrder} m Order message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.chainId != null && Object.hasOwnProperty.call(m, "chainId"))
                w.uint32(8).int64(m.chainId);
            if (m.senderPublicKey != null && Object.hasOwnProperty.call(m, "senderPublicKey"))
                w.uint32(18).bytes(m.senderPublicKey);
            if (m.matcherPublicKey != null && Object.hasOwnProperty.call(m, "matcherPublicKey"))
                w.uint32(26).bytes(m.matcherPublicKey);
            if (m.assetPair != null && Object.hasOwnProperty.call(m, "assetPair"))
                $root.vrp.AssetPair.encode(m.assetPair, w.uint32(34).fork()).ldelim();
            if (m.orderSide != null && Object.hasOwnProperty.call(m, "orderSide"))
                w.uint32(40).int32(m.orderSide);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(48).int64(m.amount);
            if (m.price != null && Object.hasOwnProperty.call(m, "price"))
                w.uint32(56).int64(m.price);
            if (m.timestamp != null && Object.hasOwnProperty.call(m, "timestamp"))
                w.uint32(64).int64(m.timestamp);
            if (m.expiration != null && Object.hasOwnProperty.call(m, "expiration"))
                w.uint32(72).int64(m.expiration);
            if (m.matcherFee != null && Object.hasOwnProperty.call(m, "matcherFee"))
                $root.vrp.Amount.encode(m.matcherFee, w.uint32(82).fork()).ldelim();
            if (m.version != null && Object.hasOwnProperty.call(m, "version"))
                w.uint32(88).int32(m.version);
            if (m.proofs != null && m.proofs.length) {
                for (var i = 0; i < m.proofs.length; ++i)
                    w.uint32(98).bytes(m.proofs[i]);
            }
            if (m.eip712Signature != null && Object.hasOwnProperty.call(m, "eip712Signature"))
                w.uint32(106).bytes(m.eip712Signature);
            if (m.priceMode != null && Object.hasOwnProperty.call(m, "priceMode"))
                w.uint32(112).int32(m.priceMode);
            return w;
        };

        /**
         * Decodes an Order message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.Order();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.chainId = r.int64();
                    break;
                case 3:
                    m.matcherPublicKey = r.bytes();
                    break;
                case 4:
                    m.assetPair = $root.vrp.AssetPair.decode(r, r.uint32());
                    break;
                case 5:
                    m.orderSide = r.int32();
                    break;
                case 6:
                    m.amount = r.int64();
                    break;
                case 7:
                    m.price = r.int64();
                    break;
                case 8:
                    m.timestamp = r.int64();
                    break;
                case 9:
                    m.expiration = r.int64();
                    break;
                case 10:
                    m.matcherFee = $root.vrp.Amount.decode(r, r.uint32());
                    break;
                case 11:
                    m.version = r.int32();
                    break;
                case 12:
                    if (!(m.proofs && m.proofs.length))
                        m.proofs = [];
                    m.proofs.push(r.bytes());
                    break;
                case 14:
                    m.priceMode = r.int32();
                    break;
                case 2:
                    m.senderPublicKey = r.bytes();
                    break;
                case 13:
                    m.eip712Signature = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        /**
         * Side enum.
         * @name vrp.Order.Side
         * @enum {number}
         * @property {number} BUY=0 BUY value
         * @property {number} SELL=1 SELL value
         */
        Order.Side = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BUY"] = 0;
            values[valuesById[1] = "SELL"] = 1;
            return values;
        })();

        /**
         * PriceMode enum.
         * @name vrp.Order.PriceMode
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} FIXED_DECIMALS=1 FIXED_DECIMALS value
         * @property {number} ASSET_DECIMALS=2 ASSET_DECIMALS value
         */
        Order.PriceMode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "FIXED_DECIMALS"] = 1;
            values[valuesById[2] = "ASSET_DECIMALS"] = 2;
            return values;
        })();

        return Order;
    })();

    vrp.Recipient = (function() {

        /**
         * Properties of a Recipient.
         * @memberof vrp
         * @interface IRecipient
         * @property {Uint8Array|null} [publicKeyHash] Recipient publicKeyHash
         * @property {string|null} [alias] Recipient alias
         */

        /**
         * Constructs a new Recipient.
         * @memberof vrp
         * @classdesc Represents a Recipient.
         * @implements IRecipient
         * @constructor
         * @param {vrp.IRecipient=} [p] Properties to set
         */
        function Recipient(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Recipient publicKeyHash.
         * @member {Uint8Array|null|undefined} publicKeyHash
         * @memberof vrp.Recipient
         * @instance
         */
        Recipient.prototype.publicKeyHash = null;

        /**
         * Recipient alias.
         * @member {string|null|undefined} alias
         * @memberof vrp.Recipient
         * @instance
         */
        Recipient.prototype.alias = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Recipient recipient.
         * @member {"publicKeyHash"|"alias"|undefined} recipient
         * @memberof vrp.Recipient
         * @instance
         */
        Object.defineProperty(Recipient.prototype, "recipient", {
            get: $util.oneOfGetter($oneOfFields = ["publicKeyHash", "alias"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified Recipient message. Does not implicitly {@link vrp.Recipient.verify|verify} messages.
         * @function encode
         * @memberof vrp.Recipient
         * @static
         * @param {vrp.IRecipient} m Recipient message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Recipient.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.publicKeyHash != null && Object.hasOwnProperty.call(m, "publicKeyHash"))
                w.uint32(10).bytes(m.publicKeyHash);
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                w.uint32(18).string(m.alias);
            return w;
        };

        /**
         * Decodes a Recipient message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.Recipient
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.Recipient} Recipient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Recipient.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.Recipient();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.publicKeyHash = r.bytes();
                    break;
                case 2:
                    m.alias = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Recipient;
    })();

    vrp.SignedTransaction = (function() {

        /**
         * Properties of a SignedTransaction.
         * @memberof vrp
         * @interface ISignedTransaction
         * @property {vrp.ITransaction|null} [vrpTransaction] SignedTransaction vrpTransaction
         * @property {Uint8Array|null} [ethereumTransaction] SignedTransaction ethereumTransaction
         * @property {Array.<Uint8Array>|null} [proofs] SignedTransaction proofs
         */

        /**
         * Constructs a new SignedTransaction.
         * @memberof vrp
         * @classdesc Represents a SignedTransaction.
         * @implements ISignedTransaction
         * @constructor
         * @param {vrp.ISignedTransaction=} [p] Properties to set
         */
        function SignedTransaction(p) {
            this.proofs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SignedTransaction vrpTransaction.
         * @member {vrp.ITransaction|null|undefined} vrpTransaction
         * @memberof vrp.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.vrpTransaction = null;

        /**
         * SignedTransaction ethereumTransaction.
         * @member {Uint8Array|null|undefined} ethereumTransaction
         * @memberof vrp.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.ethereumTransaction = null;

        /**
         * SignedTransaction proofs.
         * @member {Array.<Uint8Array>} proofs
         * @memberof vrp.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.proofs = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SignedTransaction transaction.
         * @member {"vrpTransaction"|"ethereumTransaction"|undefined} transaction
         * @memberof vrp.SignedTransaction
         * @instance
         */
        Object.defineProperty(SignedTransaction.prototype, "transaction", {
            get: $util.oneOfGetter($oneOfFields = ["vrpTransaction", "ethereumTransaction"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified SignedTransaction message. Does not implicitly {@link vrp.SignedTransaction.verify|verify} messages.
         * @function encode
         * @memberof vrp.SignedTransaction
         * @static
         * @param {vrp.ISignedTransaction} m SignedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedTransaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.vrpTransaction != null && Object.hasOwnProperty.call(m, "vrpTransaction"))
                $root.vrp.Transaction.encode(m.vrpTransaction, w.uint32(10).fork()).ldelim();
            if (m.proofs != null && m.proofs.length) {
                for (var i = 0; i < m.proofs.length; ++i)
                    w.uint32(18).bytes(m.proofs[i]);
            }
            if (m.ethereumTransaction != null && Object.hasOwnProperty.call(m, "ethereumTransaction"))
                w.uint32(26).bytes(m.ethereumTransaction);
            return w;
        };

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.SignedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.SignedTransaction} SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedTransaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.SignedTransaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.vrpTransaction = $root.vrp.Transaction.decode(r, r.uint32());
                    break;
                case 3:
                    m.ethereumTransaction = r.bytes();
                    break;
                case 2:
                    if (!(m.proofs && m.proofs.length))
                        m.proofs = [];
                    m.proofs.push(r.bytes());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignedTransaction;
    })();

    vrp.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof vrp
         * @interface ITransaction
         * @property {number|null} [chainId] Transaction chainId
         * @property {Uint8Array|null} [senderPublicKey] Transaction senderPublicKey
         * @property {vrp.IAmount|null} [fee] Transaction fee
         * @property {Long|null} [timestamp] Transaction timestamp
         * @property {number|null} [version] Transaction version
         * @property {vrp.IGenesisTransactionData|null} [genesis] Transaction genesis
         * @property {vrp.IPaymentTransactionData|null} [payment] Transaction payment
         * @property {vrp.IIssueTransactionData|null} [issue] Transaction issue
         * @property {vrp.ITransferTransactionData|null} [transfer] Transaction transfer
         * @property {vrp.IReissueTransactionData|null} [reissue] Transaction reissue
         * @property {vrp.IBurnTransactionData|null} [burn] Transaction burn
         * @property {vrp.IExchangeTransactionData|null} [exchange] Transaction exchange
         * @property {vrp.ILeaseTransactionData|null} [lease] Transaction lease
         * @property {vrp.ILeaseCancelTransactionData|null} [leaseCancel] Transaction leaseCancel
         * @property {vrp.ICreateAliasTransactionData|null} [createAlias] Transaction createAlias
         * @property {vrp.IMassTransferTransactionData|null} [massTransfer] Transaction massTransfer
         * @property {vrp.IDataTransactionData|null} [dataTransaction] Transaction dataTransaction
         * @property {vrp.ISetScriptTransactionData|null} [setScript] Transaction setScript
         * @property {vrp.ISponsorFeeTransactionData|null} [sponsorFee] Transaction sponsorFee
         * @property {vrp.ISetAssetScriptTransactionData|null} [setAssetScript] Transaction setAssetScript
         * @property {vrp.IInvokeScriptTransactionData|null} [invokeScript] Transaction invokeScript
         * @property {vrp.IUpdateAssetInfoTransactionData|null} [updateAssetInfo] Transaction updateAssetInfo
         * @property {vrp.IPrivatePaymentTransactionData|null} [anonymousTx] Transaction anonymousTx
         */

        /**
         * Constructs a new Transaction.
         * @memberof vrp
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {vrp.ITransaction=} [p] Properties to set
         */
        function Transaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Transaction chainId.
         * @member {number} chainId
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.chainId = 0;

        /**
         * Transaction senderPublicKey.
         * @member {Uint8Array} senderPublicKey
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.senderPublicKey = $util.newBuffer([]);

        /**
         * Transaction fee.
         * @member {vrp.IAmount|null|undefined} fee
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.fee = null;

        /**
         * Transaction timestamp.
         * @member {Long} timestamp
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Transaction version.
         * @member {number} version
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.version = 0;

        /**
         * Transaction genesis.
         * @member {vrp.IGenesisTransactionData|null|undefined} genesis
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.genesis = null;

        /**
         * Transaction payment.
         * @member {vrp.IPaymentTransactionData|null|undefined} payment
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.payment = null;

        /**
         * Transaction issue.
         * @member {vrp.IIssueTransactionData|null|undefined} issue
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.issue = null;

        /**
         * Transaction transfer.
         * @member {vrp.ITransferTransactionData|null|undefined} transfer
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.transfer = null;

        /**
         * Transaction reissue.
         * @member {vrp.IReissueTransactionData|null|undefined} reissue
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.reissue = null;

        /**
         * Transaction burn.
         * @member {vrp.IBurnTransactionData|null|undefined} burn
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.burn = null;

        /**
         * Transaction exchange.
         * @member {vrp.IExchangeTransactionData|null|undefined} exchange
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.exchange = null;

        /**
         * Transaction lease.
         * @member {vrp.ILeaseTransactionData|null|undefined} lease
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.lease = null;

        /**
         * Transaction leaseCancel.
         * @member {vrp.ILeaseCancelTransactionData|null|undefined} leaseCancel
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.leaseCancel = null;

        /**
         * Transaction createAlias.
         * @member {vrp.ICreateAliasTransactionData|null|undefined} createAlias
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.createAlias = null;

        /**
         * Transaction massTransfer.
         * @member {vrp.IMassTransferTransactionData|null|undefined} massTransfer
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.massTransfer = null;

        /**
         * Transaction dataTransaction.
         * @member {vrp.IDataTransactionData|null|undefined} dataTransaction
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.dataTransaction = null;

        /**
         * Transaction setScript.
         * @member {vrp.ISetScriptTransactionData|null|undefined} setScript
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.setScript = null;

        /**
         * Transaction sponsorFee.
         * @member {vrp.ISponsorFeeTransactionData|null|undefined} sponsorFee
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.sponsorFee = null;

        /**
         * Transaction setAssetScript.
         * @member {vrp.ISetAssetScriptTransactionData|null|undefined} setAssetScript
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.setAssetScript = null;

        /**
         * Transaction invokeScript.
         * @member {vrp.IInvokeScriptTransactionData|null|undefined} invokeScript
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.invokeScript = null;

        /**
         * Transaction updateAssetInfo.
         * @member {vrp.IUpdateAssetInfoTransactionData|null|undefined} updateAssetInfo
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.updateAssetInfo = null;

        /**
         * Transaction anonymousTx.
         * @member {vrp.IPrivatePaymentTransactionData|null|undefined} anonymousTx
         * @memberof vrp.Transaction
         * @instance
         */
        Transaction.prototype.anonymousTx = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Transaction data.
         * @member {"genesis"|"payment"|"issue"|"transfer"|"reissue"|"burn"|"exchange"|"lease"|"leaseCancel"|"createAlias"|"massTransfer"|"dataTransaction"|"setScript"|"sponsorFee"|"setAssetScript"|"invokeScript"|"updateAssetInfo"|"anonymousTx"|undefined} data
         * @memberof vrp.Transaction
         * @instance
         */
        Object.defineProperty(Transaction.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["genesis", "payment", "issue", "transfer", "reissue", "burn", "exchange", "lease", "leaseCancel", "createAlias", "massTransfer", "dataTransaction", "setScript", "sponsorFee", "setAssetScript", "invokeScript", "updateAssetInfo", "anonymousTx"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link vrp.Transaction.verify|verify} messages.
         * @function encode
         * @memberof vrp.Transaction
         * @static
         * @param {vrp.ITransaction} m Transaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.chainId != null && Object.hasOwnProperty.call(m, "chainId"))
                w.uint32(8).int32(m.chainId);
            if (m.senderPublicKey != null && Object.hasOwnProperty.call(m, "senderPublicKey"))
                w.uint32(18).bytes(m.senderPublicKey);
            if (m.fee != null && Object.hasOwnProperty.call(m, "fee"))
                $root.vrp.Amount.encode(m.fee, w.uint32(26).fork()).ldelim();
            if (m.timestamp != null && Object.hasOwnProperty.call(m, "timestamp"))
                w.uint32(32).int64(m.timestamp);
            if (m.version != null && Object.hasOwnProperty.call(m, "version"))
                w.uint32(40).int32(m.version);
            if (m.genesis != null && Object.hasOwnProperty.call(m, "genesis"))
                $root.vrp.GenesisTransactionData.encode(m.genesis, w.uint32(810).fork()).ldelim();
            if (m.payment != null && Object.hasOwnProperty.call(m, "payment"))
                $root.vrp.PaymentTransactionData.encode(m.payment, w.uint32(818).fork()).ldelim();
            if (m.issue != null && Object.hasOwnProperty.call(m, "issue"))
                $root.vrp.IssueTransactionData.encode(m.issue, w.uint32(826).fork()).ldelim();
            if (m.transfer != null && Object.hasOwnProperty.call(m, "transfer"))
                $root.vrp.TransferTransactionData.encode(m.transfer, w.uint32(834).fork()).ldelim();
            if (m.reissue != null && Object.hasOwnProperty.call(m, "reissue"))
                $root.vrp.ReissueTransactionData.encode(m.reissue, w.uint32(842).fork()).ldelim();
            if (m.burn != null && Object.hasOwnProperty.call(m, "burn"))
                $root.vrp.BurnTransactionData.encode(m.burn, w.uint32(850).fork()).ldelim();
            if (m.exchange != null && Object.hasOwnProperty.call(m, "exchange"))
                $root.vrp.ExchangeTransactionData.encode(m.exchange, w.uint32(858).fork()).ldelim();
            if (m.lease != null && Object.hasOwnProperty.call(m, "lease"))
                $root.vrp.LeaseTransactionData.encode(m.lease, w.uint32(866).fork()).ldelim();
            if (m.leaseCancel != null && Object.hasOwnProperty.call(m, "leaseCancel"))
                $root.vrp.LeaseCancelTransactionData.encode(m.leaseCancel, w.uint32(874).fork()).ldelim();
            if (m.createAlias != null && Object.hasOwnProperty.call(m, "createAlias"))
                $root.vrp.CreateAliasTransactionData.encode(m.createAlias, w.uint32(882).fork()).ldelim();
            if (m.massTransfer != null && Object.hasOwnProperty.call(m, "massTransfer"))
                $root.vrp.MassTransferTransactionData.encode(m.massTransfer, w.uint32(890).fork()).ldelim();
            if (m.dataTransaction != null && Object.hasOwnProperty.call(m, "dataTransaction"))
                $root.vrp.DataTransactionData.encode(m.dataTransaction, w.uint32(898).fork()).ldelim();
            if (m.setScript != null && Object.hasOwnProperty.call(m, "setScript"))
                $root.vrp.SetScriptTransactionData.encode(m.setScript, w.uint32(906).fork()).ldelim();
            if (m.sponsorFee != null && Object.hasOwnProperty.call(m, "sponsorFee"))
                $root.vrp.SponsorFeeTransactionData.encode(m.sponsorFee, w.uint32(914).fork()).ldelim();
            if (m.setAssetScript != null && Object.hasOwnProperty.call(m, "setAssetScript"))
                $root.vrp.SetAssetScriptTransactionData.encode(m.setAssetScript, w.uint32(922).fork()).ldelim();
            if (m.invokeScript != null && Object.hasOwnProperty.call(m, "invokeScript"))
                $root.vrp.InvokeScriptTransactionData.encode(m.invokeScript, w.uint32(930).fork()).ldelim();
            if (m.updateAssetInfo != null && Object.hasOwnProperty.call(m, "updateAssetInfo"))
                $root.vrp.UpdateAssetInfoTransactionData.encode(m.updateAssetInfo, w.uint32(938).fork()).ldelim();
            if (m.anonymousTx != null && Object.hasOwnProperty.call(m, "anonymousTx"))
                $root.vrp.PrivatePaymentTransactionData.encode(m.anonymousTx, w.uint32(946).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.Transaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.chainId = r.int32();
                    break;
                case 2:
                    m.senderPublicKey = r.bytes();
                    break;
                case 3:
                    m.fee = $root.vrp.Amount.decode(r, r.uint32());
                    break;
                case 4:
                    m.timestamp = r.int64();
                    break;
                case 5:
                    m.version = r.int32();
                    break;
                case 101:
                    m.genesis = $root.vrp.GenesisTransactionData.decode(r, r.uint32());
                    break;
                case 102:
                    m.payment = $root.vrp.PaymentTransactionData.decode(r, r.uint32());
                    break;
                case 103:
                    m.issue = $root.vrp.IssueTransactionData.decode(r, r.uint32());
                    break;
                case 104:
                    m.transfer = $root.vrp.TransferTransactionData.decode(r, r.uint32());
                    break;
                case 105:
                    m.reissue = $root.vrp.ReissueTransactionData.decode(r, r.uint32());
                    break;
                case 106:
                    m.burn = $root.vrp.BurnTransactionData.decode(r, r.uint32());
                    break;
                case 107:
                    m.exchange = $root.vrp.ExchangeTransactionData.decode(r, r.uint32());
                    break;
                case 108:
                    m.lease = $root.vrp.LeaseTransactionData.decode(r, r.uint32());
                    break;
                case 109:
                    m.leaseCancel = $root.vrp.LeaseCancelTransactionData.decode(r, r.uint32());
                    break;
                case 110:
                    m.createAlias = $root.vrp.CreateAliasTransactionData.decode(r, r.uint32());
                    break;
                case 111:
                    m.massTransfer = $root.vrp.MassTransferTransactionData.decode(r, r.uint32());
                    break;
                case 112:
                    m.dataTransaction = $root.vrp.DataTransactionData.decode(r, r.uint32());
                    break;
                case 113:
                    m.setScript = $root.vrp.SetScriptTransactionData.decode(r, r.uint32());
                    break;
                case 114:
                    m.sponsorFee = $root.vrp.SponsorFeeTransactionData.decode(r, r.uint32());
                    break;
                case 115:
                    m.setAssetScript = $root.vrp.SetAssetScriptTransactionData.decode(r, r.uint32());
                    break;
                case 116:
                    m.invokeScript = $root.vrp.InvokeScriptTransactionData.decode(r, r.uint32());
                    break;
                case 117:
                    m.updateAssetInfo = $root.vrp.UpdateAssetInfoTransactionData.decode(r, r.uint32());
                    break;
                case 118:
                    m.anonymousTx = $root.vrp.PrivatePaymentTransactionData.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Transaction;
    })();

    vrp.GenesisTransactionData = (function() {

        /**
         * Properties of a GenesisTransactionData.
         * @memberof vrp
         * @interface IGenesisTransactionData
         * @property {Uint8Array|null} [recipientAddress] GenesisTransactionData recipientAddress
         * @property {Long|null} [amount] GenesisTransactionData amount
         */

        /**
         * Constructs a new GenesisTransactionData.
         * @memberof vrp
         * @classdesc Represents a GenesisTransactionData.
         * @implements IGenesisTransactionData
         * @constructor
         * @param {vrp.IGenesisTransactionData=} [p] Properties to set
         */
        function GenesisTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * GenesisTransactionData recipientAddress.
         * @member {Uint8Array} recipientAddress
         * @memberof vrp.GenesisTransactionData
         * @instance
         */
        GenesisTransactionData.prototype.recipientAddress = $util.newBuffer([]);

        /**
         * GenesisTransactionData amount.
         * @member {Long} amount
         * @memberof vrp.GenesisTransactionData
         * @instance
         */
        GenesisTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified GenesisTransactionData message. Does not implicitly {@link vrp.GenesisTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.GenesisTransactionData
         * @static
         * @param {vrp.IGenesisTransactionData} m GenesisTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenesisTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipientAddress != null && Object.hasOwnProperty.call(m, "recipientAddress"))
                w.uint32(10).bytes(m.recipientAddress);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a GenesisTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.GenesisTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.GenesisTransactionData} GenesisTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenesisTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.GenesisTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipientAddress = r.bytes();
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GenesisTransactionData;
    })();

    vrp.PaymentTransactionData = (function() {

        /**
         * Properties of a PaymentTransactionData.
         * @memberof vrp
         * @interface IPaymentTransactionData
         * @property {Uint8Array|null} [recipientAddress] PaymentTransactionData recipientAddress
         * @property {Long|null} [amount] PaymentTransactionData amount
         */

        /**
         * Constructs a new PaymentTransactionData.
         * @memberof vrp
         * @classdesc Represents a PaymentTransactionData.
         * @implements IPaymentTransactionData
         * @constructor
         * @param {vrp.IPaymentTransactionData=} [p] Properties to set
         */
        function PaymentTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * PaymentTransactionData recipientAddress.
         * @member {Uint8Array} recipientAddress
         * @memberof vrp.PaymentTransactionData
         * @instance
         */
        PaymentTransactionData.prototype.recipientAddress = $util.newBuffer([]);

        /**
         * PaymentTransactionData amount.
         * @member {Long} amount
         * @memberof vrp.PaymentTransactionData
         * @instance
         */
        PaymentTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified PaymentTransactionData message. Does not implicitly {@link vrp.PaymentTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.PaymentTransactionData
         * @static
         * @param {vrp.IPaymentTransactionData} m PaymentTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipientAddress != null && Object.hasOwnProperty.call(m, "recipientAddress"))
                w.uint32(10).bytes(m.recipientAddress);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a PaymentTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.PaymentTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.PaymentTransactionData} PaymentTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.PaymentTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipientAddress = r.bytes();
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return PaymentTransactionData;
    })();

    vrp.TransferTransactionData = (function() {

        /**
         * Properties of a TransferTransactionData.
         * @memberof vrp
         * @interface ITransferTransactionData
         * @property {vrp.IRecipient|null} [recipient] TransferTransactionData recipient
         * @property {vrp.IAmount|null} [amount] TransferTransactionData amount
         * @property {Uint8Array|null} [attachment] TransferTransactionData attachment
         */

        /**
         * Constructs a new TransferTransactionData.
         * @memberof vrp
         * @classdesc Represents a TransferTransactionData.
         * @implements ITransferTransactionData
         * @constructor
         * @param {vrp.ITransferTransactionData=} [p] Properties to set
         */
        function TransferTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransferTransactionData recipient.
         * @member {vrp.IRecipient|null|undefined} recipient
         * @memberof vrp.TransferTransactionData
         * @instance
         */
        TransferTransactionData.prototype.recipient = null;

        /**
         * TransferTransactionData amount.
         * @member {vrp.IAmount|null|undefined} amount
         * @memberof vrp.TransferTransactionData
         * @instance
         */
        TransferTransactionData.prototype.amount = null;

        /**
         * TransferTransactionData attachment.
         * @member {Uint8Array} attachment
         * @memberof vrp.TransferTransactionData
         * @instance
         */
        TransferTransactionData.prototype.attachment = $util.newBuffer([]);

        /**
         * Encodes the specified TransferTransactionData message. Does not implicitly {@link vrp.TransferTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.TransferTransactionData
         * @static
         * @param {vrp.ITransferTransactionData} m TransferTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipient != null && Object.hasOwnProperty.call(m, "recipient"))
                $root.vrp.Recipient.encode(m.recipient, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                $root.vrp.Amount.encode(m.amount, w.uint32(18).fork()).ldelim();
            if (m.attachment != null && Object.hasOwnProperty.call(m, "attachment"))
                w.uint32(26).bytes(m.attachment);
            return w;
        };

        /**
         * Decodes a TransferTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.TransferTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.TransferTransactionData} TransferTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.TransferTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipient = $root.vrp.Recipient.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = $root.vrp.Amount.decode(r, r.uint32());
                    break;
                case 3:
                    m.attachment = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransferTransactionData;
    })();

    vrp.CreateAliasTransactionData = (function() {

        /**
         * Properties of a CreateAliasTransactionData.
         * @memberof vrp
         * @interface ICreateAliasTransactionData
         * @property {string|null} [alias] CreateAliasTransactionData alias
         */

        /**
         * Constructs a new CreateAliasTransactionData.
         * @memberof vrp
         * @classdesc Represents a CreateAliasTransactionData.
         * @implements ICreateAliasTransactionData
         * @constructor
         * @param {vrp.ICreateAliasTransactionData=} [p] Properties to set
         */
        function CreateAliasTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CreateAliasTransactionData alias.
         * @member {string} alias
         * @memberof vrp.CreateAliasTransactionData
         * @instance
         */
        CreateAliasTransactionData.prototype.alias = "";

        /**
         * Encodes the specified CreateAliasTransactionData message. Does not implicitly {@link vrp.CreateAliasTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.CreateAliasTransactionData
         * @static
         * @param {vrp.ICreateAliasTransactionData} m CreateAliasTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateAliasTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.alias != null && Object.hasOwnProperty.call(m, "alias"))
                w.uint32(10).string(m.alias);
            return w;
        };

        /**
         * Decodes a CreateAliasTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.CreateAliasTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.CreateAliasTransactionData} CreateAliasTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateAliasTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.CreateAliasTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.alias = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CreateAliasTransactionData;
    })();

    vrp.DataTransactionData = (function() {

        /**
         * Properties of a DataTransactionData.
         * @memberof vrp
         * @interface IDataTransactionData
         * @property {Array.<vrp.DataTransactionData.IDataEntry>|null} [data] DataTransactionData data
         */

        /**
         * Constructs a new DataTransactionData.
         * @memberof vrp
         * @classdesc Represents a DataTransactionData.
         * @implements IDataTransactionData
         * @constructor
         * @param {vrp.IDataTransactionData=} [p] Properties to set
         */
        function DataTransactionData(p) {
            this.data = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * DataTransactionData data.
         * @member {Array.<vrp.DataTransactionData.IDataEntry>} data
         * @memberof vrp.DataTransactionData
         * @instance
         */
        DataTransactionData.prototype.data = $util.emptyArray;

        /**
         * Encodes the specified DataTransactionData message. Does not implicitly {@link vrp.DataTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.DataTransactionData
         * @static
         * @param {vrp.IDataTransactionData} m DataTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.data != null && m.data.length) {
                for (var i = 0; i < m.data.length; ++i)
                    $root.vrp.DataTransactionData.DataEntry.encode(m.data[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a DataTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.DataTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.DataTransactionData} DataTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.DataTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.data && m.data.length))
                        m.data = [];
                    m.data.push($root.vrp.DataTransactionData.DataEntry.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        DataTransactionData.DataEntry = (function() {

            /**
             * Properties of a DataEntry.
             * @memberof vrp.DataTransactionData
             * @interface IDataEntry
             * @property {string|null} [key] DataEntry key
             * @property {Long|null} [intValue] DataEntry intValue
             * @property {boolean|null} [boolValue] DataEntry boolValue
             * @property {Uint8Array|null} [binaryValue] DataEntry binaryValue
             * @property {string|null} [stringValue] DataEntry stringValue
             */

            /**
             * Constructs a new DataEntry.
             * @memberof vrp.DataTransactionData
             * @classdesc Represents a DataEntry.
             * @implements IDataEntry
             * @constructor
             * @param {vrp.DataTransactionData.IDataEntry=} [p] Properties to set
             */
            function DataEntry(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * DataEntry key.
             * @member {string} key
             * @memberof vrp.DataTransactionData.DataEntry
             * @instance
             */
            DataEntry.prototype.key = "";

            /**
             * DataEntry intValue.
             * @member {Long|null|undefined} intValue
             * @memberof vrp.DataTransactionData.DataEntry
             * @instance
             */
            DataEntry.prototype.intValue = null;

            /**
             * DataEntry boolValue.
             * @member {boolean|null|undefined} boolValue
             * @memberof vrp.DataTransactionData.DataEntry
             * @instance
             */
            DataEntry.prototype.boolValue = null;

            /**
             * DataEntry binaryValue.
             * @member {Uint8Array|null|undefined} binaryValue
             * @memberof vrp.DataTransactionData.DataEntry
             * @instance
             */
            DataEntry.prototype.binaryValue = null;

            /**
             * DataEntry stringValue.
             * @member {string|null|undefined} stringValue
             * @memberof vrp.DataTransactionData.DataEntry
             * @instance
             */
            DataEntry.prototype.stringValue = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * DataEntry value.
             * @member {"intValue"|"boolValue"|"binaryValue"|"stringValue"|undefined} value
             * @memberof vrp.DataTransactionData.DataEntry
             * @instance
             */
            Object.defineProperty(DataEntry.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["intValue", "boolValue", "binaryValue", "stringValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Encodes the specified DataEntry message. Does not implicitly {@link vrp.DataTransactionData.DataEntry.verify|verify} messages.
             * @function encode
             * @memberof vrp.DataTransactionData.DataEntry
             * @static
             * @param {vrp.DataTransactionData.IDataEntry} m DataEntry message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataEntry.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                    w.uint32(10).string(m.key);
                if (m.intValue != null && Object.hasOwnProperty.call(m, "intValue"))
                    w.uint32(80).int64(m.intValue);
                if (m.boolValue != null && Object.hasOwnProperty.call(m, "boolValue"))
                    w.uint32(88).bool(m.boolValue);
                if (m.binaryValue != null && Object.hasOwnProperty.call(m, "binaryValue"))
                    w.uint32(98).bytes(m.binaryValue);
                if (m.stringValue != null && Object.hasOwnProperty.call(m, "stringValue"))
                    w.uint32(106).string(m.stringValue);
                return w;
            };

            /**
             * Decodes a DataEntry message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.DataTransactionData.DataEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.DataTransactionData.DataEntry} DataEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataEntry.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.DataTransactionData.DataEntry();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.key = r.string();
                        break;
                    case 10:
                        m.intValue = r.int64();
                        break;
                    case 11:
                        m.boolValue = r.bool();
                        break;
                    case 12:
                        m.binaryValue = r.bytes();
                        break;
                    case 13:
                        m.stringValue = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return DataEntry;
        })();

        return DataTransactionData;
    })();

    vrp.MassTransferTransactionData = (function() {

        /**
         * Properties of a MassTransferTransactionData.
         * @memberof vrp
         * @interface IMassTransferTransactionData
         * @property {Uint8Array|null} [assetId] MassTransferTransactionData assetId
         * @property {Array.<vrp.MassTransferTransactionData.ITransfer>|null} [transfers] MassTransferTransactionData transfers
         * @property {Uint8Array|null} [attachment] MassTransferTransactionData attachment
         */

        /**
         * Constructs a new MassTransferTransactionData.
         * @memberof vrp
         * @classdesc Represents a MassTransferTransactionData.
         * @implements IMassTransferTransactionData
         * @constructor
         * @param {vrp.IMassTransferTransactionData=} [p] Properties to set
         */
        function MassTransferTransactionData(p) {
            this.transfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * MassTransferTransactionData assetId.
         * @member {Uint8Array} assetId
         * @memberof vrp.MassTransferTransactionData
         * @instance
         */
        MassTransferTransactionData.prototype.assetId = $util.newBuffer([]);

        /**
         * MassTransferTransactionData transfers.
         * @member {Array.<vrp.MassTransferTransactionData.ITransfer>} transfers
         * @memberof vrp.MassTransferTransactionData
         * @instance
         */
        MassTransferTransactionData.prototype.transfers = $util.emptyArray;

        /**
         * MassTransferTransactionData attachment.
         * @member {Uint8Array} attachment
         * @memberof vrp.MassTransferTransactionData
         * @instance
         */
        MassTransferTransactionData.prototype.attachment = $util.newBuffer([]);

        /**
         * Encodes the specified MassTransferTransactionData message. Does not implicitly {@link vrp.MassTransferTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.MassTransferTransactionData
         * @static
         * @param {vrp.IMassTransferTransactionData} m MassTransferTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MassTransferTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.transfers != null && m.transfers.length) {
                for (var i = 0; i < m.transfers.length; ++i)
                    $root.vrp.MassTransferTransactionData.Transfer.encode(m.transfers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.attachment != null && Object.hasOwnProperty.call(m, "attachment"))
                w.uint32(26).bytes(m.attachment);
            return w;
        };

        /**
         * Decodes a MassTransferTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.MassTransferTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.MassTransferTransactionData} MassTransferTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MassTransferTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.MassTransferTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    if (!(m.transfers && m.transfers.length))
                        m.transfers = [];
                    m.transfers.push($root.vrp.MassTransferTransactionData.Transfer.decode(r, r.uint32()));
                    break;
                case 3:
                    m.attachment = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        MassTransferTransactionData.Transfer = (function() {

            /**
             * Properties of a Transfer.
             * @memberof vrp.MassTransferTransactionData
             * @interface ITransfer
             * @property {vrp.IRecipient|null} [recipient] Transfer recipient
             * @property {Long|null} [amount] Transfer amount
             */

            /**
             * Constructs a new Transfer.
             * @memberof vrp.MassTransferTransactionData
             * @classdesc Represents a Transfer.
             * @implements ITransfer
             * @constructor
             * @param {vrp.MassTransferTransactionData.ITransfer=} [p] Properties to set
             */
            function Transfer(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Transfer recipient.
             * @member {vrp.IRecipient|null|undefined} recipient
             * @memberof vrp.MassTransferTransactionData.Transfer
             * @instance
             */
            Transfer.prototype.recipient = null;

            /**
             * Transfer amount.
             * @member {Long} amount
             * @memberof vrp.MassTransferTransactionData.Transfer
             * @instance
             */
            Transfer.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Encodes the specified Transfer message. Does not implicitly {@link vrp.MassTransferTransactionData.Transfer.verify|verify} messages.
             * @function encode
             * @memberof vrp.MassTransferTransactionData.Transfer
             * @static
             * @param {vrp.MassTransferTransactionData.ITransfer} m Transfer message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transfer.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.recipient != null && Object.hasOwnProperty.call(m, "recipient"))
                    $root.vrp.Recipient.encode(m.recipient, w.uint32(10).fork()).ldelim();
                if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                    w.uint32(16).int64(m.amount);
                return w;
            };

            /**
             * Decodes a Transfer message from the specified reader or buffer.
             * @function decode
             * @memberof vrp.MassTransferTransactionData.Transfer
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {vrp.MassTransferTransactionData.Transfer} Transfer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transfer.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.MassTransferTransactionData.Transfer();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.recipient = $root.vrp.Recipient.decode(r, r.uint32());
                        break;
                    case 2:
                        m.amount = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Transfer;
        })();

        return MassTransferTransactionData;
    })();

    vrp.LeaseTransactionData = (function() {

        /**
         * Properties of a LeaseTransactionData.
         * @memberof vrp
         * @interface ILeaseTransactionData
         * @property {vrp.IRecipient|null} [recipient] LeaseTransactionData recipient
         * @property {Long|null} [amount] LeaseTransactionData amount
         */

        /**
         * Constructs a new LeaseTransactionData.
         * @memberof vrp
         * @classdesc Represents a LeaseTransactionData.
         * @implements ILeaseTransactionData
         * @constructor
         * @param {vrp.ILeaseTransactionData=} [p] Properties to set
         */
        function LeaseTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * LeaseTransactionData recipient.
         * @member {vrp.IRecipient|null|undefined} recipient
         * @memberof vrp.LeaseTransactionData
         * @instance
         */
        LeaseTransactionData.prototype.recipient = null;

        /**
         * LeaseTransactionData amount.
         * @member {Long} amount
         * @memberof vrp.LeaseTransactionData
         * @instance
         */
        LeaseTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified LeaseTransactionData message. Does not implicitly {@link vrp.LeaseTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.LeaseTransactionData
         * @static
         * @param {vrp.ILeaseTransactionData} m LeaseTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaseTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipient != null && Object.hasOwnProperty.call(m, "recipient"))
                $root.vrp.Recipient.encode(m.recipient, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a LeaseTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.LeaseTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.LeaseTransactionData} LeaseTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaseTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.LeaseTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipient = $root.vrp.Recipient.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return LeaseTransactionData;
    })();

    vrp.LeaseCancelTransactionData = (function() {

        /**
         * Properties of a LeaseCancelTransactionData.
         * @memberof vrp
         * @interface ILeaseCancelTransactionData
         * @property {Uint8Array|null} [leaseId] LeaseCancelTransactionData leaseId
         */

        /**
         * Constructs a new LeaseCancelTransactionData.
         * @memberof vrp
         * @classdesc Represents a LeaseCancelTransactionData.
         * @implements ILeaseCancelTransactionData
         * @constructor
         * @param {vrp.ILeaseCancelTransactionData=} [p] Properties to set
         */
        function LeaseCancelTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * LeaseCancelTransactionData leaseId.
         * @member {Uint8Array} leaseId
         * @memberof vrp.LeaseCancelTransactionData
         * @instance
         */
        LeaseCancelTransactionData.prototype.leaseId = $util.newBuffer([]);

        /**
         * Encodes the specified LeaseCancelTransactionData message. Does not implicitly {@link vrp.LeaseCancelTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.LeaseCancelTransactionData
         * @static
         * @param {vrp.ILeaseCancelTransactionData} m LeaseCancelTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaseCancelTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.leaseId != null && Object.hasOwnProperty.call(m, "leaseId"))
                w.uint32(10).bytes(m.leaseId);
            return w;
        };

        /**
         * Decodes a LeaseCancelTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.LeaseCancelTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.LeaseCancelTransactionData} LeaseCancelTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaseCancelTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.LeaseCancelTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.leaseId = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return LeaseCancelTransactionData;
    })();

    vrp.BurnTransactionData = (function() {

        /**
         * Properties of a BurnTransactionData.
         * @memberof vrp
         * @interface IBurnTransactionData
         * @property {vrp.IAmount|null} [assetAmount] BurnTransactionData assetAmount
         */

        /**
         * Constructs a new BurnTransactionData.
         * @memberof vrp
         * @classdesc Represents a BurnTransactionData.
         * @implements IBurnTransactionData
         * @constructor
         * @param {vrp.IBurnTransactionData=} [p] Properties to set
         */
        function BurnTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * BurnTransactionData assetAmount.
         * @member {vrp.IAmount|null|undefined} assetAmount
         * @memberof vrp.BurnTransactionData
         * @instance
         */
        BurnTransactionData.prototype.assetAmount = null;

        /**
         * Encodes the specified BurnTransactionData message. Does not implicitly {@link vrp.BurnTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.BurnTransactionData
         * @static
         * @param {vrp.IBurnTransactionData} m BurnTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BurnTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetAmount != null && Object.hasOwnProperty.call(m, "assetAmount"))
                $root.vrp.Amount.encode(m.assetAmount, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a BurnTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.BurnTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.BurnTransactionData} BurnTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BurnTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.BurnTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetAmount = $root.vrp.Amount.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return BurnTransactionData;
    })();

    vrp.IssueTransactionData = (function() {

        /**
         * Properties of an IssueTransactionData.
         * @memberof vrp
         * @interface IIssueTransactionData
         * @property {string|null} [name] IssueTransactionData name
         * @property {string|null} [description] IssueTransactionData description
         * @property {Long|null} [amount] IssueTransactionData amount
         * @property {number|null} [decimals] IssueTransactionData decimals
         * @property {boolean|null} [reissuable] IssueTransactionData reissuable
         * @property {Uint8Array|null} [script] IssueTransactionData script
         */

        /**
         * Constructs a new IssueTransactionData.
         * @memberof vrp
         * @classdesc Represents an IssueTransactionData.
         * @implements IIssueTransactionData
         * @constructor
         * @param {vrp.IIssueTransactionData=} [p] Properties to set
         */
        function IssueTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * IssueTransactionData name.
         * @member {string} name
         * @memberof vrp.IssueTransactionData
         * @instance
         */
        IssueTransactionData.prototype.name = "";

        /**
         * IssueTransactionData description.
         * @member {string} description
         * @memberof vrp.IssueTransactionData
         * @instance
         */
        IssueTransactionData.prototype.description = "";

        /**
         * IssueTransactionData amount.
         * @member {Long} amount
         * @memberof vrp.IssueTransactionData
         * @instance
         */
        IssueTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IssueTransactionData decimals.
         * @member {number} decimals
         * @memberof vrp.IssueTransactionData
         * @instance
         */
        IssueTransactionData.prototype.decimals = 0;

        /**
         * IssueTransactionData reissuable.
         * @member {boolean} reissuable
         * @memberof vrp.IssueTransactionData
         * @instance
         */
        IssueTransactionData.prototype.reissuable = false;

        /**
         * IssueTransactionData script.
         * @member {Uint8Array} script
         * @memberof vrp.IssueTransactionData
         * @instance
         */
        IssueTransactionData.prototype.script = $util.newBuffer([]);

        /**
         * Encodes the specified IssueTransactionData message. Does not implicitly {@link vrp.IssueTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.IssueTransactionData
         * @static
         * @param {vrp.IIssueTransactionData} m IssueTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(10).string(m.name);
            if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                w.uint32(18).string(m.description);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).int64(m.amount);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(32).int32(m.decimals);
            if (m.reissuable != null && Object.hasOwnProperty.call(m, "reissuable"))
                w.uint32(40).bool(m.reissuable);
            if (m.script != null && Object.hasOwnProperty.call(m, "script"))
                w.uint32(50).bytes(m.script);
            return w;
        };

        /**
         * Decodes an IssueTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.IssueTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.IssueTransactionData} IssueTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.IssueTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.description = r.string();
                    break;
                case 3:
                    m.amount = r.int64();
                    break;
                case 4:
                    m.decimals = r.int32();
                    break;
                case 5:
                    m.reissuable = r.bool();
                    break;
                case 6:
                    m.script = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return IssueTransactionData;
    })();

    vrp.ReissueTransactionData = (function() {

        /**
         * Properties of a ReissueTransactionData.
         * @memberof vrp
         * @interface IReissueTransactionData
         * @property {vrp.IAmount|null} [assetAmount] ReissueTransactionData assetAmount
         * @property {boolean|null} [reissuable] ReissueTransactionData reissuable
         */

        /**
         * Constructs a new ReissueTransactionData.
         * @memberof vrp
         * @classdesc Represents a ReissueTransactionData.
         * @implements IReissueTransactionData
         * @constructor
         * @param {vrp.IReissueTransactionData=} [p] Properties to set
         */
        function ReissueTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ReissueTransactionData assetAmount.
         * @member {vrp.IAmount|null|undefined} assetAmount
         * @memberof vrp.ReissueTransactionData
         * @instance
         */
        ReissueTransactionData.prototype.assetAmount = null;

        /**
         * ReissueTransactionData reissuable.
         * @member {boolean} reissuable
         * @memberof vrp.ReissueTransactionData
         * @instance
         */
        ReissueTransactionData.prototype.reissuable = false;

        /**
         * Encodes the specified ReissueTransactionData message. Does not implicitly {@link vrp.ReissueTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.ReissueTransactionData
         * @static
         * @param {vrp.IReissueTransactionData} m ReissueTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReissueTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetAmount != null && Object.hasOwnProperty.call(m, "assetAmount"))
                $root.vrp.Amount.encode(m.assetAmount, w.uint32(10).fork()).ldelim();
            if (m.reissuable != null && Object.hasOwnProperty.call(m, "reissuable"))
                w.uint32(16).bool(m.reissuable);
            return w;
        };

        /**
         * Decodes a ReissueTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.ReissueTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.ReissueTransactionData} ReissueTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReissueTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.ReissueTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetAmount = $root.vrp.Amount.decode(r, r.uint32());
                    break;
                case 2:
                    m.reissuable = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ReissueTransactionData;
    })();

    vrp.SetAssetScriptTransactionData = (function() {

        /**
         * Properties of a SetAssetScriptTransactionData.
         * @memberof vrp
         * @interface ISetAssetScriptTransactionData
         * @property {Uint8Array|null} [assetId] SetAssetScriptTransactionData assetId
         * @property {Uint8Array|null} [script] SetAssetScriptTransactionData script
         */

        /**
         * Constructs a new SetAssetScriptTransactionData.
         * @memberof vrp
         * @classdesc Represents a SetAssetScriptTransactionData.
         * @implements ISetAssetScriptTransactionData
         * @constructor
         * @param {vrp.ISetAssetScriptTransactionData=} [p] Properties to set
         */
        function SetAssetScriptTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SetAssetScriptTransactionData assetId.
         * @member {Uint8Array} assetId
         * @memberof vrp.SetAssetScriptTransactionData
         * @instance
         */
        SetAssetScriptTransactionData.prototype.assetId = $util.newBuffer([]);

        /**
         * SetAssetScriptTransactionData script.
         * @member {Uint8Array} script
         * @memberof vrp.SetAssetScriptTransactionData
         * @instance
         */
        SetAssetScriptTransactionData.prototype.script = $util.newBuffer([]);

        /**
         * Encodes the specified SetAssetScriptTransactionData message. Does not implicitly {@link vrp.SetAssetScriptTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.SetAssetScriptTransactionData
         * @static
         * @param {vrp.ISetAssetScriptTransactionData} m SetAssetScriptTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetAssetScriptTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.script != null && Object.hasOwnProperty.call(m, "script"))
                w.uint32(18).bytes(m.script);
            return w;
        };

        /**
         * Decodes a SetAssetScriptTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.SetAssetScriptTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.SetAssetScriptTransactionData} SetAssetScriptTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetAssetScriptTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.SetAssetScriptTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    m.script = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SetAssetScriptTransactionData;
    })();

    vrp.SetScriptTransactionData = (function() {

        /**
         * Properties of a SetScriptTransactionData.
         * @memberof vrp
         * @interface ISetScriptTransactionData
         * @property {Uint8Array|null} [script] SetScriptTransactionData script
         */

        /**
         * Constructs a new SetScriptTransactionData.
         * @memberof vrp
         * @classdesc Represents a SetScriptTransactionData.
         * @implements ISetScriptTransactionData
         * @constructor
         * @param {vrp.ISetScriptTransactionData=} [p] Properties to set
         */
        function SetScriptTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SetScriptTransactionData script.
         * @member {Uint8Array} script
         * @memberof vrp.SetScriptTransactionData
         * @instance
         */
        SetScriptTransactionData.prototype.script = $util.newBuffer([]);

        /**
         * Encodes the specified SetScriptTransactionData message. Does not implicitly {@link vrp.SetScriptTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.SetScriptTransactionData
         * @static
         * @param {vrp.ISetScriptTransactionData} m SetScriptTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetScriptTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.script != null && Object.hasOwnProperty.call(m, "script"))
                w.uint32(10).bytes(m.script);
            return w;
        };

        /**
         * Decodes a SetScriptTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.SetScriptTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.SetScriptTransactionData} SetScriptTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetScriptTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.SetScriptTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.script = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SetScriptTransactionData;
    })();

    vrp.ExchangeTransactionData = (function() {

        /**
         * Properties of an ExchangeTransactionData.
         * @memberof vrp
         * @interface IExchangeTransactionData
         * @property {Long|null} [amount] ExchangeTransactionData amount
         * @property {Long|null} [price] ExchangeTransactionData price
         * @property {Long|null} [buyMatcherFee] ExchangeTransactionData buyMatcherFee
         * @property {Long|null} [sellMatcherFee] ExchangeTransactionData sellMatcherFee
         * @property {Array.<vrp.IOrder>|null} [orders] ExchangeTransactionData orders
         */

        /**
         * Constructs a new ExchangeTransactionData.
         * @memberof vrp
         * @classdesc Represents an ExchangeTransactionData.
         * @implements IExchangeTransactionData
         * @constructor
         * @param {vrp.IExchangeTransactionData=} [p] Properties to set
         */
        function ExchangeTransactionData(p) {
            this.orders = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ExchangeTransactionData amount.
         * @member {Long} amount
         * @memberof vrp.ExchangeTransactionData
         * @instance
         */
        ExchangeTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionData price.
         * @member {Long} price
         * @memberof vrp.ExchangeTransactionData
         * @instance
         */
        ExchangeTransactionData.prototype.price = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionData buyMatcherFee.
         * @member {Long} buyMatcherFee
         * @memberof vrp.ExchangeTransactionData
         * @instance
         */
        ExchangeTransactionData.prototype.buyMatcherFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionData sellMatcherFee.
         * @member {Long} sellMatcherFee
         * @memberof vrp.ExchangeTransactionData
         * @instance
         */
        ExchangeTransactionData.prototype.sellMatcherFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionData orders.
         * @member {Array.<vrp.IOrder>} orders
         * @memberof vrp.ExchangeTransactionData
         * @instance
         */
        ExchangeTransactionData.prototype.orders = $util.emptyArray;

        /**
         * Encodes the specified ExchangeTransactionData message. Does not implicitly {@link vrp.ExchangeTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.ExchangeTransactionData
         * @static
         * @param {vrp.IExchangeTransactionData} m ExchangeTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(8).int64(m.amount);
            if (m.price != null && Object.hasOwnProperty.call(m, "price"))
                w.uint32(16).int64(m.price);
            if (m.buyMatcherFee != null && Object.hasOwnProperty.call(m, "buyMatcherFee"))
                w.uint32(24).int64(m.buyMatcherFee);
            if (m.sellMatcherFee != null && Object.hasOwnProperty.call(m, "sellMatcherFee"))
                w.uint32(32).int64(m.sellMatcherFee);
            if (m.orders != null && m.orders.length) {
                for (var i = 0; i < m.orders.length; ++i)
                    $root.vrp.Order.encode(m.orders[i], w.uint32(42).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an ExchangeTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.ExchangeTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.ExchangeTransactionData} ExchangeTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.ExchangeTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.amount = r.int64();
                    break;
                case 2:
                    m.price = r.int64();
                    break;
                case 3:
                    m.buyMatcherFee = r.int64();
                    break;
                case 4:
                    m.sellMatcherFee = r.int64();
                    break;
                case 5:
                    if (!(m.orders && m.orders.length))
                        m.orders = [];
                    m.orders.push($root.vrp.Order.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ExchangeTransactionData;
    })();

    vrp.SponsorFeeTransactionData = (function() {

        /**
         * Properties of a SponsorFeeTransactionData.
         * @memberof vrp
         * @interface ISponsorFeeTransactionData
         * @property {vrp.IAmount|null} [minFee] SponsorFeeTransactionData minFee
         */

        /**
         * Constructs a new SponsorFeeTransactionData.
         * @memberof vrp
         * @classdesc Represents a SponsorFeeTransactionData.
         * @implements ISponsorFeeTransactionData
         * @constructor
         * @param {vrp.ISponsorFeeTransactionData=} [p] Properties to set
         */
        function SponsorFeeTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SponsorFeeTransactionData minFee.
         * @member {vrp.IAmount|null|undefined} minFee
         * @memberof vrp.SponsorFeeTransactionData
         * @instance
         */
        SponsorFeeTransactionData.prototype.minFee = null;

        /**
         * Encodes the specified SponsorFeeTransactionData message. Does not implicitly {@link vrp.SponsorFeeTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.SponsorFeeTransactionData
         * @static
         * @param {vrp.ISponsorFeeTransactionData} m SponsorFeeTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SponsorFeeTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.minFee != null && Object.hasOwnProperty.call(m, "minFee"))
                $root.vrp.Amount.encode(m.minFee, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SponsorFeeTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.SponsorFeeTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.SponsorFeeTransactionData} SponsorFeeTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SponsorFeeTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.SponsorFeeTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.minFee = $root.vrp.Amount.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SponsorFeeTransactionData;
    })();

    vrp.InvokeScriptTransactionData = (function() {

        /**
         * Properties of an InvokeScriptTransactionData.
         * @memberof vrp
         * @interface IInvokeScriptTransactionData
         * @property {vrp.IRecipient|null} [dApp] InvokeScriptTransactionData dApp
         * @property {Uint8Array|null} [functionCall] InvokeScriptTransactionData functionCall
         * @property {Array.<vrp.IAmount>|null} [payments] InvokeScriptTransactionData payments
         */

        /**
         * Constructs a new InvokeScriptTransactionData.
         * @memberof vrp
         * @classdesc Represents an InvokeScriptTransactionData.
         * @implements IInvokeScriptTransactionData
         * @constructor
         * @param {vrp.IInvokeScriptTransactionData=} [p] Properties to set
         */
        function InvokeScriptTransactionData(p) {
            this.payments = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * InvokeScriptTransactionData dApp.
         * @member {vrp.IRecipient|null|undefined} dApp
         * @memberof vrp.InvokeScriptTransactionData
         * @instance
         */
        InvokeScriptTransactionData.prototype.dApp = null;

        /**
         * InvokeScriptTransactionData functionCall.
         * @member {Uint8Array} functionCall
         * @memberof vrp.InvokeScriptTransactionData
         * @instance
         */
        InvokeScriptTransactionData.prototype.functionCall = $util.newBuffer([]);

        /**
         * InvokeScriptTransactionData payments.
         * @member {Array.<vrp.IAmount>} payments
         * @memberof vrp.InvokeScriptTransactionData
         * @instance
         */
        InvokeScriptTransactionData.prototype.payments = $util.emptyArray;

        /**
         * Encodes the specified InvokeScriptTransactionData message. Does not implicitly {@link vrp.InvokeScriptTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.InvokeScriptTransactionData
         * @static
         * @param {vrp.IInvokeScriptTransactionData} m InvokeScriptTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvokeScriptTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.dApp != null && Object.hasOwnProperty.call(m, "dApp"))
                $root.vrp.Recipient.encode(m.dApp, w.uint32(10).fork()).ldelim();
            if (m.functionCall != null && Object.hasOwnProperty.call(m, "functionCall"))
                w.uint32(18).bytes(m.functionCall);
            if (m.payments != null && m.payments.length) {
                for (var i = 0; i < m.payments.length; ++i)
                    $root.vrp.Amount.encode(m.payments[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an InvokeScriptTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.InvokeScriptTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.InvokeScriptTransactionData} InvokeScriptTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvokeScriptTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeScriptTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.dApp = $root.vrp.Recipient.decode(r, r.uint32());
                    break;
                case 2:
                    m.functionCall = r.bytes();
                    break;
                case 3:
                    if (!(m.payments && m.payments.length))
                        m.payments = [];
                    m.payments.push($root.vrp.Amount.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return InvokeScriptTransactionData;
    })();

    vrp.UpdateAssetInfoTransactionData = (function() {

        /**
         * Properties of an UpdateAssetInfoTransactionData.
         * @memberof vrp
         * @interface IUpdateAssetInfoTransactionData
         * @property {Uint8Array|null} [assetId] UpdateAssetInfoTransactionData assetId
         * @property {string|null} [name] UpdateAssetInfoTransactionData name
         * @property {string|null} [description] UpdateAssetInfoTransactionData description
         * @property {string|null} [image] UpdateAssetInfoTransactionData image
         */

        /**
         * Constructs a new UpdateAssetInfoTransactionData.
         * @memberof vrp
         * @classdesc Represents an UpdateAssetInfoTransactionData.
         * @implements IUpdateAssetInfoTransactionData
         * @constructor
         * @param {vrp.IUpdateAssetInfoTransactionData=} [p] Properties to set
         */
        function UpdateAssetInfoTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * UpdateAssetInfoTransactionData assetId.
         * @member {Uint8Array} assetId
         * @memberof vrp.UpdateAssetInfoTransactionData
         * @instance
         */
        UpdateAssetInfoTransactionData.prototype.assetId = $util.newBuffer([]);

        /**
         * UpdateAssetInfoTransactionData name.
         * @member {string} name
         * @memberof vrp.UpdateAssetInfoTransactionData
         * @instance
         */
        UpdateAssetInfoTransactionData.prototype.name = "";

        /**
         * UpdateAssetInfoTransactionData description.
         * @member {string} description
         * @memberof vrp.UpdateAssetInfoTransactionData
         * @instance
         */
        UpdateAssetInfoTransactionData.prototype.description = "";

        /**
         * UpdateAssetInfoTransactionData image.
         * @member {string} image
         * @memberof vrp.UpdateAssetInfoTransactionData
         * @instance
         */
        UpdateAssetInfoTransactionData.prototype.image = "";

        /**
         * Encodes the specified UpdateAssetInfoTransactionData message. Does not implicitly {@link vrp.UpdateAssetInfoTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.UpdateAssetInfoTransactionData
         * @static
         * @param {vrp.IUpdateAssetInfoTransactionData} m UpdateAssetInfoTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAssetInfoTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.assetId != null && Object.hasOwnProperty.call(m, "assetId"))
                w.uint32(10).bytes(m.assetId);
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(18).string(m.name);
            if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                w.uint32(26).string(m.description);
            if (m.image != null && Object.hasOwnProperty.call(m, "image"))
                w.uint32(34).string(m.image);
            return w;
        };

        /**
         * Decodes an UpdateAssetInfoTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.UpdateAssetInfoTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.UpdateAssetInfoTransactionData} UpdateAssetInfoTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAssetInfoTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.UpdateAssetInfoTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.assetId = r.bytes();
                    break;
                case 2:
                    m.name = r.string();
                    break;
                case 3:
                    m.description = r.string();
                    break;
                case 4:
                    m.image = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return UpdateAssetInfoTransactionData;
    })();

    vrp.InvokeExpressionTransactionData = (function() {

        /**
         * Properties of an InvokeExpressionTransactionData.
         * @memberof vrp
         * @interface IInvokeExpressionTransactionData
         * @property {Uint8Array|null} [expression] InvokeExpressionTransactionData expression
         */

        /**
         * Constructs a new InvokeExpressionTransactionData.
         * @memberof vrp
         * @classdesc Represents an InvokeExpressionTransactionData.
         * @implements IInvokeExpressionTransactionData
         * @constructor
         * @param {vrp.IInvokeExpressionTransactionData=} [p] Properties to set
         */
        function InvokeExpressionTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * InvokeExpressionTransactionData expression.
         * @member {Uint8Array} expression
         * @memberof vrp.InvokeExpressionTransactionData
         * @instance
         */
        InvokeExpressionTransactionData.prototype.expression = $util.newBuffer([]);

        /**
         * Encodes the specified InvokeExpressionTransactionData message. Does not implicitly {@link vrp.InvokeExpressionTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.InvokeExpressionTransactionData
         * @static
         * @param {vrp.IInvokeExpressionTransactionData} m InvokeExpressionTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvokeExpressionTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.expression != null && Object.hasOwnProperty.call(m, "expression"))
                w.uint32(10).bytes(m.expression);
            return w;
        };

        /**
         * Decodes an InvokeExpressionTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.InvokeExpressionTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.InvokeExpressionTransactionData} InvokeExpressionTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvokeExpressionTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.InvokeExpressionTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.expression = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return InvokeExpressionTransactionData;
    })();

    vrp.PrivatePaymentTransactionData = (function() {

        /**
         * Properties of a PrivatePaymentTransactionData.
         * @memberof vrp
         * @interface IPrivatePaymentTransactionData
         * @property {Uint8Array|null} [recipientAddress] PrivatePaymentTransactionData recipientAddress
         * @property {Long|null} [amount] PrivatePaymentTransactionData amount
         */

        /**
         * Constructs a new PrivatePaymentTransactionData.
         * @memberof vrp
         * @classdesc Represents a PrivatePaymentTransactionData.
         * @implements IPrivatePaymentTransactionData
         * @constructor
         * @param {vrp.IPrivatePaymentTransactionData=} [p] Properties to set
         */
        function PrivatePaymentTransactionData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * PrivatePaymentTransactionData recipientAddress.
         * @member {Uint8Array} recipientAddress
         * @memberof vrp.PrivatePaymentTransactionData
         * @instance
         */
        PrivatePaymentTransactionData.prototype.recipientAddress = $util.newBuffer([]);

        /**
         * PrivatePaymentTransactionData amount.
         * @member {Long} amount
         * @memberof vrp.PrivatePaymentTransactionData
         * @instance
         */
        PrivatePaymentTransactionData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Encodes the specified PrivatePaymentTransactionData message. Does not implicitly {@link vrp.PrivatePaymentTransactionData.verify|verify} messages.
         * @function encode
         * @memberof vrp.PrivatePaymentTransactionData
         * @static
         * @param {vrp.IPrivatePaymentTransactionData} m PrivatePaymentTransactionData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivatePaymentTransactionData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.recipientAddress != null && Object.hasOwnProperty.call(m, "recipientAddress"))
                w.uint32(10).bytes(m.recipientAddress);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a PrivatePaymentTransactionData message from the specified reader or buffer.
         * @function decode
         * @memberof vrp.PrivatePaymentTransactionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {vrp.PrivatePaymentTransactionData} PrivatePaymentTransactionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivatePaymentTransactionData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.vrp.PrivatePaymentTransactionData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.recipientAddress = r.bytes();
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return PrivatePaymentTransactionData;
    })();

    return vrp;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [p] Properties to set
             */
            function DoubleValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} m DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(9).double(m.value);
                return w;
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DoubleValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.double();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [p] Properties to set
             */
            function FloatValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} m FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(13).float(m.value);
                return w;
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FloatValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.float();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [p] Properties to set
             */
            function Int64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Int64Value value.
             * @member {Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} m Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).int64(m.value);
                return w;
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [p] Properties to set
             */
            function UInt64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt64Value value.
             * @member {Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} m UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).uint64(m.value);
                return w;
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.uint64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [p] Properties to set
             */
            function Int32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} m Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).int32(m.value);
                return w;
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.int32();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [p] Properties to set
             */
            function UInt32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} m UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).uint32(m.value);
                return w;
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.uint32();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [p] Properties to set
             */
            function BoolValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} m BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).bool(m.value);
                return w;
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BoolValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [p] Properties to set
             */
            function StringValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} m StringValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(10).string(m.value);
                return w;
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.StringValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [p] Properties to set
             */
            function BytesValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} m BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(10).bytes(m.value);
                return w;
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BytesValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BytesValue;
        })();

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [p] Properties to set
             */
            function Empty(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} m Empty message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                return w;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Empty();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Empty;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
