// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vrp/invoke_script_result.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "vrp/InvokeScriptResult.pbobjc.h"
#import "vrp/Transaction.pbobjc.h"
#import "vrp/Amount.pbobjc.h"
#import "vrp/Recipient.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Amount);
GPBObjCClassDeclaration(DataTransactionData_DataEntry);
GPBObjCClassDeclaration(InvokeScriptResult);
GPBObjCClassDeclaration(InvokeScriptResult_Burn);
GPBObjCClassDeclaration(InvokeScriptResult_Call);
GPBObjCClassDeclaration(InvokeScriptResult_Call_Argument);
GPBObjCClassDeclaration(InvokeScriptResult_Call_Argument_List);
GPBObjCClassDeclaration(InvokeScriptResult_ErrorMessage);
GPBObjCClassDeclaration(InvokeScriptResult_Invocation);
GPBObjCClassDeclaration(InvokeScriptResult_Issue);
GPBObjCClassDeclaration(InvokeScriptResult_Lease);
GPBObjCClassDeclaration(InvokeScriptResult_LeaseCancel);
GPBObjCClassDeclaration(InvokeScriptResult_Payment);
GPBObjCClassDeclaration(InvokeScriptResult_PrivatePayment);
GPBObjCClassDeclaration(InvokeScriptResult_Reissue);
GPBObjCClassDeclaration(InvokeScriptResult_SponsorFee);
GPBObjCClassDeclaration(Recipient);

#pragma mark - InvokeScriptResultRoot

@implementation InvokeScriptResultRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - InvokeScriptResultRoot_FileDescriptor

static GPBFileDescriptor *InvokeScriptResultRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"vrp"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - InvokeScriptResult

@implementation InvokeScriptResult

@dynamic dataArray, dataArray_Count;
@dynamic transfersArray, transfersArray_Count;
@dynamic issuesArray, issuesArray_Count;
@dynamic reissuesArray, reissuesArray_Count;
@dynamic burnsArray, burnsArray_Count;
@dynamic hasErrorMessage, errorMessage;
@dynamic sponsorFeesArray, sponsorFeesArray_Count;
@dynamic leasesArray, leasesArray_Count;
@dynamic leaseCancelsArray, leaseCancelsArray_Count;
@dynamic invokesArray, invokesArray_Count;
@dynamic privatePaymentArray, privatePaymentArray_Count;

typedef struct InvokeScriptResult__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dataArray;
  NSMutableArray *transfersArray;
  NSMutableArray *issuesArray;
  NSMutableArray *reissuesArray;
  NSMutableArray *burnsArray;
  InvokeScriptResult_ErrorMessage *errorMessage;
  NSMutableArray *sponsorFeesArray;
  NSMutableArray *leasesArray;
  NSMutableArray *leaseCancelsArray;
  NSMutableArray *invokesArray;
  NSMutableArray *privatePaymentArray;
} InvokeScriptResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DataTransactionData_DataEntry),
        .number = InvokeScriptResult_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transfersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Payment),
        .number = InvokeScriptResult_FieldNumber_TransfersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, transfersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "issuesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Issue),
        .number = InvokeScriptResult_FieldNumber_IssuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, issuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reissuesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Reissue),
        .number = InvokeScriptResult_FieldNumber_ReissuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, reissuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "burnsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Burn),
        .number = InvokeScriptResult_FieldNumber_BurnsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, burnsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_ErrorMessage),
        .number = InvokeScriptResult_FieldNumber_ErrorMessage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, errorMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sponsorFeesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_SponsorFee),
        .number = InvokeScriptResult_FieldNumber_SponsorFeesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, sponsorFeesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "leasesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Lease),
        .number = InvokeScriptResult_FieldNumber_LeasesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, leasesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "leaseCancelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_LeaseCancel),
        .number = InvokeScriptResult_FieldNumber_LeaseCancelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, leaseCancelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "invokesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Invocation),
        .number = InvokeScriptResult_FieldNumber_InvokesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, invokesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "privatePaymentArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_PrivatePayment),
        .number = InvokeScriptResult_FieldNumber_PrivatePaymentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult__storage_, privatePaymentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Payment

@implementation InvokeScriptResult_Payment

@dynamic address;
@dynamic hasAmount, amount;

typedef struct InvokeScriptResult_Payment__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  Amount *amount;
} InvokeScriptResult_Payment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Payment_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Payment__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = InvokeScriptResult_Payment_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Payment__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Payment class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Payment__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_PrivatePayment

@implementation InvokeScriptResult_PrivatePayment

@dynamic address;
@dynamic hasAmount, amount;

typedef struct InvokeScriptResult_PrivatePayment__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  Amount *amount;
} InvokeScriptResult_PrivatePayment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_PrivatePayment_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_PrivatePayment__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = InvokeScriptResult_PrivatePayment_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_PrivatePayment__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_PrivatePayment class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_PrivatePayment__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Issue

@implementation InvokeScriptResult_Issue

@dynamic assetId;
@dynamic name;
@dynamic description_p;
@dynamic image;
@dynamic amount;
@dynamic decimals;
@dynamic reissuable;
@dynamic script;
@dynamic nonce;

typedef struct InvokeScriptResult_Issue__storage_ {
  uint32_t _has_storage_[1];
  int32_t decimals;
  NSData *assetId;
  NSString *name;
  NSString *description_p;
  NSString *image;
  NSData *script;
  int64_t amount;
  int64_t nonce;
} InvokeScriptResult_Issue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Image,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, image),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Decimals,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, decimals),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reissuable",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Reissuable,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "script",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Script,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, script),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Issue_FieldNumber_Nonce,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Issue__storage_, nonce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Issue class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Issue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Reissue

@implementation InvokeScriptResult_Reissue

@dynamic assetId;
@dynamic amount;
@dynamic isReissuable;

typedef struct InvokeScriptResult_Reissue__storage_ {
  uint32_t _has_storage_[1];
  NSData *assetId;
  int64_t amount;
} InvokeScriptResult_Reissue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Reissue_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Reissue__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Reissue_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Reissue__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isReissuable",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Reissue_FieldNumber_IsReissuable,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Reissue class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Reissue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Burn

@implementation InvokeScriptResult_Burn

@dynamic assetId;
@dynamic amount;

typedef struct InvokeScriptResult_Burn__storage_ {
  uint32_t _has_storage_[1];
  NSData *assetId;
  int64_t amount;
} InvokeScriptResult_Burn__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Burn_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Burn__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Burn_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Burn__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Burn class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Burn__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_SponsorFee

@implementation InvokeScriptResult_SponsorFee

@dynamic hasMinFee, minFee;

typedef struct InvokeScriptResult_SponsorFee__storage_ {
  uint32_t _has_storage_[1];
  Amount *minFee;
} InvokeScriptResult_SponsorFee__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minFee",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = InvokeScriptResult_SponsorFee_FieldNumber_MinFee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_SponsorFee__storage_, minFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_SponsorFee class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_SponsorFee__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Lease

@implementation InvokeScriptResult_Lease

@dynamic hasRecipient, recipient;
@dynamic amount;
@dynamic nonce;
@dynamic leaseId;

typedef struct InvokeScriptResult_Lease__storage_ {
  uint32_t _has_storage_[1];
  Recipient *recipient;
  NSData *leaseId;
  int64_t amount;
  int64_t nonce;
} InvokeScriptResult_Lease__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recipient",
        .dataTypeSpecific.clazz = GPBObjCClass(Recipient),
        .number = InvokeScriptResult_Lease_FieldNumber_Recipient,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Lease__storage_, recipient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Lease_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Lease__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Lease_FieldNumber_Nonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Lease__storage_, nonce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "leaseId",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Lease_FieldNumber_LeaseId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Lease__storage_, leaseId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Lease class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Lease__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_LeaseCancel

@implementation InvokeScriptResult_LeaseCancel

@dynamic leaseId;

typedef struct InvokeScriptResult_LeaseCancel__storage_ {
  uint32_t _has_storage_[1];
  NSData *leaseId;
} InvokeScriptResult_LeaseCancel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "leaseId",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_LeaseCancel_FieldNumber_LeaseId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_LeaseCancel__storage_, leaseId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_LeaseCancel class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_LeaseCancel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_ErrorMessage

@implementation InvokeScriptResult_ErrorMessage

@dynamic code;
@dynamic text;

typedef struct InvokeScriptResult_ErrorMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *text;
} InvokeScriptResult_ErrorMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_ErrorMessage_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_ErrorMessage__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_ErrorMessage_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_ErrorMessage__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_ErrorMessage class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_ErrorMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Call

@implementation InvokeScriptResult_Call

@dynamic function;
@dynamic argsBytesArray, argsBytesArray_Count;
@dynamic argsArray, argsArray_Count;

typedef struct InvokeScriptResult_Call__storage_ {
  uint32_t _has_storage_[1];
  NSString *function;
  NSMutableArray *argsBytesArray;
  NSMutableArray *argsArray;
} InvokeScriptResult_Call__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "function",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Call_FieldNumber_Function,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call__storage_, function),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argsBytesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Call_FieldNumber_ArgsBytesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call__storage_, argsBytesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "argsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Call_Argument),
        .number = InvokeScriptResult_Call_FieldNumber_ArgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call__storage_, argsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Call class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Call__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Call_Argument

@implementation InvokeScriptResult_Call_Argument

@dynamic valueOneOfCase;
@dynamic integerValue;
@dynamic binaryValue;
@dynamic stringValue;
@dynamic booleanValue;
@dynamic caseObj;
@dynamic list;

typedef struct InvokeScriptResult_Call_Argument__storage_ {
  uint32_t _has_storage_[2];
  NSData *binaryValue;
  NSString *stringValue;
  NSData *caseObj;
  InvokeScriptResult_Call_Argument_List *list;
  int64_t integerValue;
} InvokeScriptResult_Call_Argument__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "integerValue",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Call_Argument_FieldNumber_IntegerValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call_Argument__storage_, integerValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "binaryValue",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Call_Argument_FieldNumber_BinaryValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call_Argument__storage_, binaryValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "stringValue",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Call_Argument_FieldNumber_StringValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call_Argument__storage_, stringValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "booleanValue",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Call_Argument_FieldNumber_BooleanValue,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "caseObj",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Call_Argument_FieldNumber_CaseObj,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call_Argument__storage_, caseObj),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "list",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Call_Argument_List),
        .number = InvokeScriptResult_Call_Argument_FieldNumber_List,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call_Argument__storage_, list),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Call_Argument class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Call_Argument__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult_Call)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void InvokeScriptResult_Call_Argument_ClearValueOneOfCase(InvokeScriptResult_Call_Argument *message) {
  GPBDescriptor *descriptor = [InvokeScriptResult_Call_Argument descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - InvokeScriptResult_Call_Argument_List

@implementation InvokeScriptResult_Call_Argument_List

@dynamic itemsArray, itemsArray_Count;

typedef struct InvokeScriptResult_Call_Argument_List__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} InvokeScriptResult_Call_Argument_List__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Call_Argument),
        .number = InvokeScriptResult_Call_Argument_List_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Call_Argument_List__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Call_Argument_List class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Call_Argument_List__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult_Call_Argument)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptResult_Invocation

@implementation InvokeScriptResult_Invocation

@dynamic dApp;
@dynamic hasCall, call;
@dynamic paymentsArray, paymentsArray_Count;
@dynamic hasStateChanges, stateChanges;

typedef struct InvokeScriptResult_Invocation__storage_ {
  uint32_t _has_storage_[1];
  NSData *dApp;
  InvokeScriptResult_Call *call;
  NSMutableArray *paymentsArray;
  InvokeScriptResult *stateChanges;
} InvokeScriptResult_Invocation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dApp",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptResult_Invocation_FieldNumber_DApp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Invocation__storage_, dApp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "call",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult_Call),
        .number = InvokeScriptResult_Invocation_FieldNumber_Call,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Invocation__storage_, call),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paymentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = InvokeScriptResult_Invocation_FieldNumber_PaymentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Invocation__storage_, paymentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stateChanges",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptResult),
        .number = InvokeScriptResult_Invocation_FieldNumber_StateChanges,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InvokeScriptResult_Invocation__storage_, stateChanges),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptResult_Invocation class]
                                     rootClass:[InvokeScriptResultRoot class]
                                          file:InvokeScriptResultRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptResult_Invocation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\004\000\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(InvokeScriptResult)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
