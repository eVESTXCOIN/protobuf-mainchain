// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vrp/transaction.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "vrp/Transaction.pbobjc.h"
#import "vrp/Amount.pbobjc.h"
#import "vrp/Recipient.pbobjc.h"
#import "vrp/Order.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Amount);
GPBObjCClassDeclaration(BurnTransactionData);
GPBObjCClassDeclaration(CreateAliasTransactionData);
GPBObjCClassDeclaration(DataTransactionData);
GPBObjCClassDeclaration(DataTransactionData_DataEntry);
GPBObjCClassDeclaration(ExchangeTransactionData);
GPBObjCClassDeclaration(GenesisTransactionData);
GPBObjCClassDeclaration(InvokeScriptTransactionData);
GPBObjCClassDeclaration(IssueTransactionData);
GPBObjCClassDeclaration(LeaseCancelTransactionData);
GPBObjCClassDeclaration(LeaseTransactionData);
GPBObjCClassDeclaration(MassTransferTransactionData);
GPBObjCClassDeclaration(MassTransferTransactionData_Transfer);
GPBObjCClassDeclaration(Order);
GPBObjCClassDeclaration(PaymentTransactionData);
GPBObjCClassDeclaration(PrivatePaymentTransactionData);
GPBObjCClassDeclaration(Recipient);
GPBObjCClassDeclaration(ReissueTransactionData);
GPBObjCClassDeclaration(SetAssetScriptTransactionData);
GPBObjCClassDeclaration(SetScriptTransactionData);
GPBObjCClassDeclaration(SponsorFeeTransactionData);
GPBObjCClassDeclaration(Transaction);
GPBObjCClassDeclaration(TransferTransactionData);
GPBObjCClassDeclaration(UpdateAssetInfoTransactionData);

#pragma mark - TransactionRoot

@implementation TransactionRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - TransactionRoot_FileDescriptor

static GPBFileDescriptor *TransactionRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"vrp"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - SignedTransaction

@implementation SignedTransaction

@dynamic transactionOneOfCase;
@dynamic vrpTransaction;
@dynamic ethereumTransaction;
@dynamic proofsArray, proofsArray_Count;

typedef struct SignedTransaction__storage_ {
  uint32_t _has_storage_[2];
  Transaction *vrpTransaction;
  NSMutableArray *proofsArray;
  NSData *ethereumTransaction;
} SignedTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vrpTransaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = SignedTransaction_FieldNumber_VrpTransaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SignedTransaction__storage_, vrpTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proofsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SignedTransaction_FieldNumber_ProofsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SignedTransaction__storage_, proofsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ethereumTransaction",
        .dataTypeSpecific.clazz = Nil,
        .number = SignedTransaction_FieldNumber_EthereumTransaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SignedTransaction__storage_, ethereumTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignedTransaction class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignedTransaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "transaction",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SignedTransaction_ClearTransactionOneOfCase(SignedTransaction *message) {
  GPBDescriptor *descriptor = [SignedTransaction descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Transaction

@implementation Transaction

@dynamic dataOneOfCase;
@dynamic chainId;
@dynamic senderPublicKey;
@dynamic hasFee, fee;
@dynamic timestamp;
@dynamic version;
@dynamic genesis;
@dynamic payment;
@dynamic issue;
@dynamic transfer;
@dynamic reissue;
@dynamic burn;
@dynamic exchange;
@dynamic lease;
@dynamic leaseCancel;
@dynamic createAlias;
@dynamic massTransfer;
@dynamic dataTransaction;
@dynamic setScript;
@dynamic sponsorFee;
@dynamic setAssetScript;
@dynamic invokeScript;
@dynamic updateAssetInfo;
@dynamic anonymousTx;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[2];
  int32_t chainId;
  int32_t version;
  NSData *senderPublicKey;
  Amount *fee;
  GenesisTransactionData *genesis;
  PaymentTransactionData *payment;
  IssueTransactionData *issue;
  TransferTransactionData *transfer;
  ReissueTransactionData *reissue;
  BurnTransactionData *burn;
  ExchangeTransactionData *exchange;
  LeaseTransactionData *lease;
  LeaseCancelTransactionData *leaseCancel;
  CreateAliasTransactionData *createAlias;
  MassTransferTransactionData *massTransfer;
  DataTransactionData *dataTransaction;
  SetScriptTransactionData *setScript;
  SponsorFeeTransactionData *sponsorFee;
  SetAssetScriptTransactionData *setAssetScript;
  InvokeScriptTransactionData *invokeScript;
  UpdateAssetInfoTransactionData *updateAssetInfo;
  PrivatePaymentTransactionData *anonymousTx;
  int64_t timestamp;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_ChainId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, chainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "senderPublicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_SenderPublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, senderPublicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = Transaction_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_Version,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "genesis",
        .dataTypeSpecific.clazz = GPBObjCClass(GenesisTransactionData),
        .number = Transaction_FieldNumber_Genesis,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, genesis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payment",
        .dataTypeSpecific.clazz = GPBObjCClass(PaymentTransactionData),
        .number = Transaction_FieldNumber_Payment,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, payment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "issue",
        .dataTypeSpecific.clazz = GPBObjCClass(IssueTransactionData),
        .number = Transaction_FieldNumber_Issue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, issue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transfer",
        .dataTypeSpecific.clazz = GPBObjCClass(TransferTransactionData),
        .number = Transaction_FieldNumber_Transfer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, transfer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reissue",
        .dataTypeSpecific.clazz = GPBObjCClass(ReissueTransactionData),
        .number = Transaction_FieldNumber_Reissue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, reissue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "burn",
        .dataTypeSpecific.clazz = GPBObjCClass(BurnTransactionData),
        .number = Transaction_FieldNumber_Burn,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, burn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exchange",
        .dataTypeSpecific.clazz = GPBObjCClass(ExchangeTransactionData),
        .number = Transaction_FieldNumber_Exchange,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, exchange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lease",
        .dataTypeSpecific.clazz = GPBObjCClass(LeaseTransactionData),
        .number = Transaction_FieldNumber_Lease,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, lease),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "leaseCancel",
        .dataTypeSpecific.clazz = GPBObjCClass(LeaseCancelTransactionData),
        .number = Transaction_FieldNumber_LeaseCancel,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, leaseCancel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createAlias",
        .dataTypeSpecific.clazz = GPBObjCClass(CreateAliasTransactionData),
        .number = Transaction_FieldNumber_CreateAlias,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, createAlias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "massTransfer",
        .dataTypeSpecific.clazz = GPBObjCClass(MassTransferTransactionData),
        .number = Transaction_FieldNumber_MassTransfer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, massTransfer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataTransaction",
        .dataTypeSpecific.clazz = GPBObjCClass(DataTransactionData),
        .number = Transaction_FieldNumber_DataTransaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, dataTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setScript",
        .dataTypeSpecific.clazz = GPBObjCClass(SetScriptTransactionData),
        .number = Transaction_FieldNumber_SetScript,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, setScript),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sponsorFee",
        .dataTypeSpecific.clazz = GPBObjCClass(SponsorFeeTransactionData),
        .number = Transaction_FieldNumber_SponsorFee,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, sponsorFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAssetScript",
        .dataTypeSpecific.clazz = GPBObjCClass(SetAssetScriptTransactionData),
        .number = Transaction_FieldNumber_SetAssetScript,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, setAssetScript),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "invokeScript",
        .dataTypeSpecific.clazz = GPBObjCClass(InvokeScriptTransactionData),
        .number = Transaction_FieldNumber_InvokeScript,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, invokeScript),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateAssetInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UpdateAssetInfoTransactionData),
        .number = Transaction_FieldNumber_UpdateAssetInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, updateAssetInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "anonymousTx",
        .dataTypeSpecific.clazz = GPBObjCClass(PrivatePaymentTransactionData),
        .number = Transaction_FieldNumber_AnonymousTx,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, anonymousTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Transaction_ClearDataOneOfCase(Transaction *message) {
  GPBDescriptor *descriptor = [Transaction descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GenesisTransactionData

@implementation GenesisTransactionData

@dynamic recipientAddress;
@dynamic amount;

typedef struct GenesisTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *recipientAddress;
  int64_t amount;
} GenesisTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recipientAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = GenesisTransactionData_FieldNumber_RecipientAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenesisTransactionData__storage_, recipientAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = GenesisTransactionData_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenesisTransactionData__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenesisTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenesisTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentTransactionData

@implementation PaymentTransactionData

@dynamic recipientAddress;
@dynamic amount;

typedef struct PaymentTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *recipientAddress;
  int64_t amount;
} PaymentTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recipientAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PaymentTransactionData_FieldNumber_RecipientAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentTransactionData__storage_, recipientAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = PaymentTransactionData_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentTransactionData__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferTransactionData

@implementation TransferTransactionData

@dynamic hasRecipient, recipient;
@dynamic hasAmount, amount;
@dynamic attachment;

typedef struct TransferTransactionData__storage_ {
  uint32_t _has_storage_[1];
  Recipient *recipient;
  Amount *amount;
  NSData *attachment;
} TransferTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recipient",
        .dataTypeSpecific.clazz = GPBObjCClass(Recipient),
        .number = TransferTransactionData_FieldNumber_Recipient,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferTransactionData__storage_, recipient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = TransferTransactionData_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferTransactionData__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachment",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferTransactionData_FieldNumber_Attachment,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferTransactionData__storage_, attachment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateAliasTransactionData

@implementation CreateAliasTransactionData

@dynamic alias;

typedef struct CreateAliasTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSString *alias;
} CreateAliasTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "alias",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateAliasTransactionData_FieldNumber_Alias,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateAliasTransactionData__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateAliasTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateAliasTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DataTransactionData

@implementation DataTransactionData

@dynamic dataArray, dataArray_Count;

typedef struct DataTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dataArray;
} DataTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DataTransactionData_DataEntry),
        .number = DataTransactionData_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DataTransactionData__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DataTransactionData_DataEntry

@implementation DataTransactionData_DataEntry

@dynamic valueOneOfCase;
@dynamic key;
@dynamic intValue;
@dynamic boolValue;
@dynamic binaryValue;
@dynamic stringValue;

typedef struct DataTransactionData_DataEntry__storage_ {
  uint32_t _has_storage_[2];
  NSString *key;
  NSData *binaryValue;
  NSString *stringValue;
  int64_t intValue;
} DataTransactionData_DataEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = DataTransactionData_DataEntry_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DataTransactionData_DataEntry__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "intValue",
        .dataTypeSpecific.clazz = Nil,
        .number = DataTransactionData_DataEntry_FieldNumber_IntValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DataTransactionData_DataEntry__storage_, intValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "boolValue",
        .dataTypeSpecific.clazz = Nil,
        .number = DataTransactionData_DataEntry_FieldNumber_BoolValue,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "binaryValue",
        .dataTypeSpecific.clazz = Nil,
        .number = DataTransactionData_DataEntry_FieldNumber_BinaryValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DataTransactionData_DataEntry__storage_, binaryValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "stringValue",
        .dataTypeSpecific.clazz = Nil,
        .number = DataTransactionData_DataEntry_FieldNumber_StringValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DataTransactionData_DataEntry__storage_, stringValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataTransactionData_DataEntry class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataTransactionData_DataEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(DataTransactionData)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DataTransactionData_DataEntry_ClearValueOneOfCase(DataTransactionData_DataEntry *message) {
  GPBDescriptor *descriptor = [DataTransactionData_DataEntry descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - MassTransferTransactionData

@implementation MassTransferTransactionData

@dynamic assetId;
@dynamic transfersArray, transfersArray_Count;
@dynamic attachment;

typedef struct MassTransferTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *assetId;
  NSMutableArray *transfersArray;
  NSData *attachment;
} MassTransferTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = MassTransferTransactionData_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MassTransferTransactionData__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transfersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MassTransferTransactionData_Transfer),
        .number = MassTransferTransactionData_FieldNumber_TransfersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MassTransferTransactionData__storage_, transfersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachment",
        .dataTypeSpecific.clazz = Nil,
        .number = MassTransferTransactionData_FieldNumber_Attachment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MassTransferTransactionData__storage_, attachment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MassTransferTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MassTransferTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MassTransferTransactionData_Transfer

@implementation MassTransferTransactionData_Transfer

@dynamic hasRecipient, recipient;
@dynamic amount;

typedef struct MassTransferTransactionData_Transfer__storage_ {
  uint32_t _has_storage_[1];
  Recipient *recipient;
  int64_t amount;
} MassTransferTransactionData_Transfer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recipient",
        .dataTypeSpecific.clazz = GPBObjCClass(Recipient),
        .number = MassTransferTransactionData_Transfer_FieldNumber_Recipient,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MassTransferTransactionData_Transfer__storage_, recipient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = MassTransferTransactionData_Transfer_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MassTransferTransactionData_Transfer__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MassTransferTransactionData_Transfer class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MassTransferTransactionData_Transfer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(MassTransferTransactionData)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LeaseTransactionData

@implementation LeaseTransactionData

@dynamic hasRecipient, recipient;
@dynamic amount;

typedef struct LeaseTransactionData__storage_ {
  uint32_t _has_storage_[1];
  Recipient *recipient;
  int64_t amount;
} LeaseTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recipient",
        .dataTypeSpecific.clazz = GPBObjCClass(Recipient),
        .number = LeaseTransactionData_FieldNumber_Recipient,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LeaseTransactionData__storage_, recipient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = LeaseTransactionData_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LeaseTransactionData__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LeaseTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LeaseTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LeaseCancelTransactionData

@implementation LeaseCancelTransactionData

@dynamic leaseId;

typedef struct LeaseCancelTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *leaseId;
} LeaseCancelTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "leaseId",
        .dataTypeSpecific.clazz = Nil,
        .number = LeaseCancelTransactionData_FieldNumber_LeaseId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LeaseCancelTransactionData__storage_, leaseId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LeaseCancelTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LeaseCancelTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BurnTransactionData

@implementation BurnTransactionData

@dynamic hasAssetAmount, assetAmount;

typedef struct BurnTransactionData__storage_ {
  uint32_t _has_storage_[1];
  Amount *assetAmount;
} BurnTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetAmount",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = BurnTransactionData_FieldNumber_AssetAmount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BurnTransactionData__storage_, assetAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BurnTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BurnTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IssueTransactionData

@implementation IssueTransactionData

@dynamic name;
@dynamic description_p;
@dynamic amount;
@dynamic decimals;
@dynamic reissuable;
@dynamic script;

typedef struct IssueTransactionData__storage_ {
  uint32_t _has_storage_[1];
  int32_t decimals;
  NSString *name;
  NSString *description_p;
  NSData *script;
  int64_t amount;
} IssueTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = IssueTransactionData_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IssueTransactionData__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = IssueTransactionData_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IssueTransactionData__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = IssueTransactionData_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IssueTransactionData__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.clazz = Nil,
        .number = IssueTransactionData_FieldNumber_Decimals,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IssueTransactionData__storage_, decimals),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reissuable",
        .dataTypeSpecific.clazz = Nil,
        .number = IssueTransactionData_FieldNumber_Reissuable,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "script",
        .dataTypeSpecific.clazz = Nil,
        .number = IssueTransactionData_FieldNumber_Script,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(IssueTransactionData__storage_, script),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IssueTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IssueTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReissueTransactionData

@implementation ReissueTransactionData

@dynamic hasAssetAmount, assetAmount;
@dynamic reissuable;

typedef struct ReissueTransactionData__storage_ {
  uint32_t _has_storage_[1];
  Amount *assetAmount;
} ReissueTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetAmount",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = ReissueTransactionData_FieldNumber_AssetAmount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReissueTransactionData__storage_, assetAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reissuable",
        .dataTypeSpecific.clazz = Nil,
        .number = ReissueTransactionData_FieldNumber_Reissuable,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReissueTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReissueTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetAssetScriptTransactionData

@implementation SetAssetScriptTransactionData

@dynamic assetId;
@dynamic script;

typedef struct SetAssetScriptTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *assetId;
  NSData *script;
} SetAssetScriptTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = SetAssetScriptTransactionData_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAssetScriptTransactionData__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "script",
        .dataTypeSpecific.clazz = Nil,
        .number = SetAssetScriptTransactionData_FieldNumber_Script,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetAssetScriptTransactionData__storage_, script),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAssetScriptTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAssetScriptTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetScriptTransactionData

@implementation SetScriptTransactionData

@dynamic script;

typedef struct SetScriptTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *script;
} SetScriptTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "script",
        .dataTypeSpecific.clazz = Nil,
        .number = SetScriptTransactionData_FieldNumber_Script,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetScriptTransactionData__storage_, script),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetScriptTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetScriptTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExchangeTransactionData

@implementation ExchangeTransactionData

@dynamic amount;
@dynamic price;
@dynamic buyMatcherFee;
@dynamic sellMatcherFee;
@dynamic ordersArray, ordersArray_Count;

typedef struct ExchangeTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *ordersArray;
  int64_t amount;
  int64_t price;
  int64_t buyMatcherFee;
  int64_t sellMatcherFee;
} ExchangeTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = ExchangeTransactionData_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExchangeTransactionData__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "price",
        .dataTypeSpecific.clazz = Nil,
        .number = ExchangeTransactionData_FieldNumber_Price,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExchangeTransactionData__storage_, price),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "buyMatcherFee",
        .dataTypeSpecific.clazz = Nil,
        .number = ExchangeTransactionData_FieldNumber_BuyMatcherFee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExchangeTransactionData__storage_, buyMatcherFee),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sellMatcherFee",
        .dataTypeSpecific.clazz = Nil,
        .number = ExchangeTransactionData_FieldNumber_SellMatcherFee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExchangeTransactionData__storage_, sellMatcherFee),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ordersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Order),
        .number = ExchangeTransactionData_FieldNumber_OrdersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExchangeTransactionData__storage_, ordersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExchangeTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExchangeTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SponsorFeeTransactionData

@implementation SponsorFeeTransactionData

@dynamic hasMinFee, minFee;

typedef struct SponsorFeeTransactionData__storage_ {
  uint32_t _has_storage_[1];
  Amount *minFee;
} SponsorFeeTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minFee",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = SponsorFeeTransactionData_FieldNumber_MinFee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SponsorFeeTransactionData__storage_, minFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SponsorFeeTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SponsorFeeTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeScriptTransactionData

@implementation InvokeScriptTransactionData

@dynamic hasDApp, dApp;
@dynamic functionCall;
@dynamic paymentsArray, paymentsArray_Count;

typedef struct InvokeScriptTransactionData__storage_ {
  uint32_t _has_storage_[1];
  Recipient *dApp;
  NSData *functionCall;
  NSMutableArray *paymentsArray;
} InvokeScriptTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dApp",
        .dataTypeSpecific.clazz = GPBObjCClass(Recipient),
        .number = InvokeScriptTransactionData_FieldNumber_DApp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeScriptTransactionData__storage_, dApp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "functionCall",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeScriptTransactionData_FieldNumber_FunctionCall,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InvokeScriptTransactionData__storage_, functionCall),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Amount),
        .number = InvokeScriptTransactionData_FieldNumber_PaymentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InvokeScriptTransactionData__storage_, paymentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeScriptTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeScriptTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateAssetInfoTransactionData

@implementation UpdateAssetInfoTransactionData

@dynamic assetId;
@dynamic name;
@dynamic description_p;
@dynamic image;

typedef struct UpdateAssetInfoTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *assetId;
  NSString *name;
  NSString *description_p;
  NSString *image;
} UpdateAssetInfoTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateAssetInfoTransactionData_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateAssetInfoTransactionData__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateAssetInfoTransactionData_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateAssetInfoTransactionData__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateAssetInfoTransactionData_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateAssetInfoTransactionData__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateAssetInfoTransactionData_FieldNumber_Image,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateAssetInfoTransactionData__storage_, image),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateAssetInfoTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateAssetInfoTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvokeExpressionTransactionData

@implementation InvokeExpressionTransactionData

@dynamic expression;

typedef struct InvokeExpressionTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *expression;
} InvokeExpressionTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "expression",
        .dataTypeSpecific.clazz = Nil,
        .number = InvokeExpressionTransactionData_FieldNumber_Expression,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InvokeExpressionTransactionData__storage_, expression),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvokeExpressionTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InvokeExpressionTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrivatePaymentTransactionData

@implementation PrivatePaymentTransactionData

@dynamic recipientAddress;
@dynamic amount;

typedef struct PrivatePaymentTransactionData__storage_ {
  uint32_t _has_storage_[1];
  NSData *recipientAddress;
  int64_t amount;
} PrivatePaymentTransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recipientAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivatePaymentTransactionData_FieldNumber_RecipientAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PrivatePaymentTransactionData__storage_, recipientAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = PrivatePaymentTransactionData_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PrivatePaymentTransactionData__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrivatePaymentTransactionData class]
                                     rootClass:[TransactionRoot class]
                                          file:TransactionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrivatePaymentTransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
